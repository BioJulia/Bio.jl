{
    "docs": [
        {
            "location": "/", 
            "text": "Bio.jl Documentation\n\n\n\n\nInstallation\n\n\nBio.Seq: Biological Sequences\n\n\nBiological symbols\n\n\nSequences\n\n\nConstructing sequences\n\n\nIndexing and modifying\n\n\nOther operations on sequences\n\n\nCompact representation\n\n\nNucleotide k-mers\n\n\nSequence records\n\n\n\n\n\n\nAlign: Sequence Alignments\n\n\nRepresenting alignments\n\n\nAligned sequence\n\n\nOperating on alignments\n\n\nPairwise alignment\n\n\nSubstitution matrices\n\n\n\n\n\n\nIntervals: Genomic Interval Manipulation\n\n\nInterval types\n\n\nCollections of intervals\n\n\nIntersection\n\n\nInterval streams\n\n\n\n\n\n\nBio.Structure: Macromolecular Structures\n\n\nParsing PDB files\n\n\nManipulating Structures\n\n\nWriting PDB files\n\n\nExamples\n\n\n\n\n\n\nTools: Misc tools and function wrappers\n\n\nBlast wrapper", 
            "title": "Home"
        }, 
        {
            "location": "/#biojl-documentation", 
            "text": "Installation  Bio.Seq: Biological Sequences  Biological symbols  Sequences  Constructing sequences  Indexing and modifying  Other operations on sequences  Compact representation  Nucleotide k-mers  Sequence records    Align: Sequence Alignments  Representing alignments  Aligned sequence  Operating on alignments  Pairwise alignment  Substitution matrices    Intervals: Genomic Interval Manipulation  Interval types  Collections of intervals  Intersection  Interval streams    Bio.Structure: Macromolecular Structures  Parsing PDB files  Manipulating Structures  Writing PDB files  Examples    Tools: Misc tools and function wrappers  Blast wrapper", 
            "title": "Bio.jl Documentation"
        }, 
        {
            "location": "/man/install/", 
            "text": "Installation\n\n\nInstall Bio.jl using the package manager.\n\n\nPkg\n.\nadd\n(\nBio\n)\n\n\n\n\n\n\nAlternatively, clone the latest version or a specific branch using Pkg.clone.", 
            "title": "Installation"
        }, 
        {
            "location": "/man/install/#installation", 
            "text": "Install Bio.jl using the package manager.  Pkg . add ( Bio )   Alternatively, clone the latest version or a specific branch using Pkg.clone.", 
            "title": "Installation"
        }, 
        {
            "location": "/man/reading/", 
            "text": "Reading and writing data\n\n\nBio.jl has a unified interface for reading and writing files in a variety of formats. To initialize a parser for a particular format, the \nopen\n method is extended with a file format type parameter (currently supported formats types are \nBED\n, \nFASTQ\n, and \nFASTA\n).\n\n\nopen\n{\nT\n \n:\n \nFileFormat\n}(\nfilename\n::\nString\n,\n \n::\nType\n{\nT\n};\n \nmemory_map\n::\nBool\n=\nfalse\n)\n\n\nopen\n{\nT\n \n:\n \nFileFormat\n}(\nsource\n::\nIO\n,\n \n::\nType\n{\nT\n})\n\n\nopen\n{\nT\n \n:\n \nFileFormat\n}(\ndata\n::\nVector\n{\nUInt8\n},\n \n::\nType\n{\nT\n})\n\n\n\n\n\n\n\n\nParsing by iteration\n\n\nParsers in Bio.jl all read and return entries one at a time. The most convenient way to do this by iteration.\n\n\nstream\n \n=\n \nopen\n(\ninput.bed\n,\n \nBED\n)\n\n\nfor\n \nentry\n \nin\n \nstream\n\n    \n# perform some operation on entry\n\n\nend\n\n\n\n\n\n\n\n\nIn-place parsing\n\n\nIterating through entries in a file is convenient, but for each entry in the file, the parser must allocate, and ultimately the garbage collector must spend time to deallocate it. For performance critical applications, a separate lower level parsing interface can be used that avoid unnecessary allocation by overwriting one entry. For files with a large number of small entries, this can greatly speed up reading.\n\n\nInstead of looping over a parser stream \nread!\n is called with a preallocated entry.\n\n\nstream\n \n=\n \nopen\n(\ninput.bed\n,\n \nBED\n)\n\n\nentry\n \n=\n \nBEDInterval\n()\n\n\nwhile\n \n!\neof\n(\nstream\n)\n\n    \nread!\n(\ninput\n,\n \nentry\n)\n\n    \n# perform some operation on `entry`\n\n\nend\n\n\n\n\n\n\nSome care is necessary when using this interface. Because \nentry\n is completely overwritten on each iteration, one must manually copy any field from \nentry\n that should be preserved. For example, if we wish to save the \nseqname\n field from \nentry\n when parsing BED, we must call \ncopy(entry.seqname)\n.\n\n\nEmpty entry types that correspond to the file format be found using \neltype\n, making it easy to allocate an empty entry for any parser stream.\n\n\nentry\n \n=\n \neltype\n(\nstream\n)()", 
            "title": "IO API"
        }, 
        {
            "location": "/man/reading/#reading-and-writing-data", 
            "text": "Bio.jl has a unified interface for reading and writing files in a variety of formats. To initialize a parser for a particular format, the  open  method is extended with a file format type parameter (currently supported formats types are  BED ,  FASTQ , and  FASTA ).  open { T   :   FileFormat }( filename :: String ,   :: Type { T };   memory_map :: Bool = false )  open { T   :   FileFormat }( source :: IO ,   :: Type { T })  open { T   :   FileFormat }( data :: Vector { UInt8 },   :: Type { T })", 
            "title": "Reading and writing data"
        }, 
        {
            "location": "/man/reading/#parsing-by-iteration", 
            "text": "Parsers in Bio.jl all read and return entries one at a time. The most convenient way to do this by iteration.  stream   =   open ( input.bed ,   BED )  for   entry   in   stream \n     # perform some operation on entry  end", 
            "title": "Parsing by iteration"
        }, 
        {
            "location": "/man/reading/#in-place-parsing", 
            "text": "Iterating through entries in a file is convenient, but for each entry in the file, the parser must allocate, and ultimately the garbage collector must spend time to deallocate it. For performance critical applications, a separate lower level parsing interface can be used that avoid unnecessary allocation by overwriting one entry. For files with a large number of small entries, this can greatly speed up reading.  Instead of looping over a parser stream  read!  is called with a preallocated entry.  stream   =   open ( input.bed ,   BED )  entry   =   BEDInterval ()  while   ! eof ( stream ) \n     read! ( input ,   entry ) \n     # perform some operation on `entry`  end   Some care is necessary when using this interface. Because  entry  is completely overwritten on each iteration, one must manually copy any field from  entry  that should be preserved. For example, if we wish to save the  seqname  field from  entry  when parsing BED, we must call  copy(entry.seqname) .  Empty entry types that correspond to the file format be found using  eltype , making it easy to allocate an empty entry for any parser stream.  entry   =   eltype ( stream )()", 
            "title": "In-place parsing"
        }, 
        {
            "location": "/man/seq/", 
            "text": "Bio.Seq: Biological Sequences\n\n\nThe \nBio.Seq\n module provides several data types for handling biological symbols and sequences.\n\n\n\n\nBiological symbols\n\n\nThe \nBio.Seq\n module provides three biological symbol (character) types:\n\n\n\n\n\n\n\n\nType\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nDNANucleotide\n\n\nDNA nucleotide\n\n\n\n\n\n\nRNANucleotide\n\n\nRNA nucleotide\n\n\n\n\n\n\nAminoAcid\n\n\nAmino acid\n\n\n\n\n\n\n\n\nThese symbols can be elements of sequences like characters can be elements of strings.  See \nSequences\n and \nNucleotide k-mers\n section for details.\n\n\n\n\nDNA and RNA nucleotides\n\n\nSet of nucleotide symbols in Bio.jl covers IUPAC nucleotide base plus a gap symbol:\n\n\n\n\n\n\n\n\nSymbol\n\n\nConstant\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n'A'\n\n\nDNA_A\n / \nRNA_A\n\n\nA; Adenine\n\n\n\n\n\n\n'C'\n\n\nDNA_C\n / \nRNA_C\n\n\nC; Cytosine\n\n\n\n\n\n\n'G'\n\n\nDNA_G\n / \nRNA_G\n\n\nG; Guanine\n\n\n\n\n\n\n'T'\n\n\nDNA_T\n\n\nT; Thymine (DNA only)\n\n\n\n\n\n\n'U'\n\n\nRNA_U\n\n\nU; Uracil (RNA only)\n\n\n\n\n\n\n'M'\n\n\nDNA_M\n / \nRNA_M\n\n\nA or C\n\n\n\n\n\n\n'R'\n\n\nDNA_R\n / \nRNA_R\n\n\nA or G\n\n\n\n\n\n\n'W'\n\n\nDNA_W\n / \nRNA_W\n\n\nA or T\n\n\n\n\n\n\n'S'\n\n\nDNA_S\n / \nRNA_S\n\n\nC or G\n\n\n\n\n\n\n'Y'\n\n\nDNA_Y\n / \nRNA_Y\n\n\nC or T\n\n\n\n\n\n\n'K'\n\n\nDNA_K\n / \nRNA_K\n\n\nG or T\n\n\n\n\n\n\n'V'\n\n\nDNA_V\n / \nRNA_V\n\n\nA or C or G; not T\n\n\n\n\n\n\n'H'\n\n\nDNA_H\n / \nRNA_H\n\n\nA or C or T; not G\n\n\n\n\n\n\n'D'\n\n\nDNA_D\n / \nRNA_D\n\n\nA or G or T; not C\n\n\n\n\n\n\n'B'\n\n\nDNA_B\n / \nRNA_B\n\n\nC or G or T; not A\n\n\n\n\n\n\n'N'\n\n\nDNA_N\n / \nRNA_N\n\n\nA or C or G or T\n\n\n\n\n\n\n'-'\n\n\nDNA_Gap\n / \nRNA_Gap\n\n\nGap (none of the above)\n\n\n\n\n\n\n\n\nhttp://www.insdc.org/documents/feature_table.html#7.4.1\n\n\nSymbols are accessible as constants with \nDNA_\n or \nRNA_\n prefix:\n\n\njulia\n \nDNA_A\n\n\nA\n\n\n\njulia\n \nDNA_T\n\n\nT\n\n\n\njulia\n \nRNA_U\n\n\nU\n\n\n\njulia\n \nDNA_Gap\n\n\n-\n\n\n\njulia\n \ntypeof\n(\nDNA_A\n)\n\n\nBio\n.\nSeq\n.\nDNANucleotide\n\n\n\njulia\n \ntypeof\n(\nRNA_A\n)\n\n\nBio\n.\nSeq\n.\nRNANucleotide\n\n\n\n\n\n\nSymbols can be constructed by converting regular characters:\n\n\njulia\n \nconvert\n(\nDNANucleotide\n,\n \nC\n)\n\n\nC\n\n\n\njulia\n \nconvert\n(\nDNANucleotide\n,\n \nC\n)\n \n===\n \nDNA_C\n\n\ntrue\n\n\n\n\n\n\n\n\nAmino acids\n\n\nSet of amino acid symbols also covers IUPAC amino acid symbols plus a gap symbol:\n\n\n\n\n\n\n\n\nSymbol\n\n\nConstant\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n'A'\n\n\nAA_A\n\n\nAlanine\n\n\n\n\n\n\n'R'\n\n\nAA_R\n\n\nArginine\n\n\n\n\n\n\n'N'\n\n\nAA_N\n\n\nAsparagine\n\n\n\n\n\n\n'D'\n\n\nAA_D\n\n\nAspartic acid (Aspartate)\n\n\n\n\n\n\n'C'\n\n\nAA_C\n\n\nCysteine\n\n\n\n\n\n\n'Q'\n\n\nAA_Q\n\n\nGlutamine\n\n\n\n\n\n\n'E'\n\n\nAA_E\n\n\nGlutamic acid (Glutamate)\n\n\n\n\n\n\n'G'\n\n\nAA_G\n\n\nGlycine\n\n\n\n\n\n\n'H'\n\n\nAA_H\n\n\nHistidine\n\n\n\n\n\n\n'I'\n\n\nAA_I\n\n\nIsoleucine\n\n\n\n\n\n\n'L'\n\n\nAA_L\n\n\nLeucine\n\n\n\n\n\n\n'K'\n\n\nAA_K\n\n\nLysine\n\n\n\n\n\n\n'M'\n\n\nAA_M\n\n\nMethionine\n\n\n\n\n\n\n'F'\n\n\nAA_F\n\n\nPhenylalanine\n\n\n\n\n\n\n'P'\n\n\nAA_P\n\n\nProline\n\n\n\n\n\n\n'S'\n\n\nAA_S\n\n\nSerine\n\n\n\n\n\n\n'T'\n\n\nAA_T\n\n\nThreonine\n\n\n\n\n\n\n'W'\n\n\nAA_W\n\n\nTryptophan\n\n\n\n\n\n\n'Y'\n\n\nAA_Y\n\n\nTyrosine\n\n\n\n\n\n\n'V'\n\n\nAA_V\n\n\nValine\n\n\n\n\n\n\n'O'\n\n\nAA_O\n\n\nPyrrolysine\n\n\n\n\n\n\n'U'\n\n\nAA_U\n\n\nSelenocysteine\n\n\n\n\n\n\n'B'\n\n\nAA_B\n\n\nAspartic acid or Asparagine\n\n\n\n\n\n\n'J'\n\n\nAA_J\n\n\nLeucine or Isoleucine\n\n\n\n\n\n\n'Z'\n\n\nAA_Z\n\n\nGlutamine or Glutamic acid\n\n\n\n\n\n\n'X'\n\n\nAA_X\n\n\nAny amino acid\n\n\n\n\n\n\n'*'\n\n\nAA_Term\n\n\nTermination codon\n\n\n\n\n\n\n'-'\n\n\nAA_Gap\n\n\nGap (none of the above)\n\n\n\n\n\n\n\n\nhttp://www.insdc.org/documents/feature_table.html#7.4.3\n\n\nSymbols are accessible as constants with \nAA_\n prefix:\n\n\njulia\n \nAA_A\n\n\nA\n\n\n\njulia\n \nAA_Q\n\n\nQ\n\n\n\njulia\n \nAA_Term\n\n\n*\n\n\n\njulia\n \ntypeof\n(\nAA_A\n)\n\n\nBio\n.\nSeq\n.\nAminoAcid\n\n\n\n\n\n\nSymbols can be constructed by converting regular characters:\n\n\njulia\n \nconvert\n(\nAminoAcid\n,\n \nA\n)\n\n\nA\n\n\n\njulia\n \nconvert\n(\nAminoAcid\n,\n \nP\n)\n \n===\n \nAA_P\n\n\ntrue\n\n\n\n\n\n\n\n\nArithmetic\n\n\nBiological symbols behaves like \nChar\n:\n\n\njulia\n \nDNA_A\n \n==\n \nDNA_A\n  \n# equivalence\n\n\ntrue\n\n\n\njulia\n \nDNA_A\n \n \nDNA_C\n \n \nDNA_G\n \n \nDNA_T\n  \n# order\n\n\ntrue\n\n\n\njulia\n \nDNA_A\n \n+\n \n1\n  \n# addition\n\n\nC\n\n\n\njulia\n \nDNA_T\n \n-\n \n3\n  \n# subtraction\n\n\nA\n\n\n\njulia\n \nDNA_T\n \n-\n \nDNA_C\n  \n# difference\n\n\n2\n\n\n\n\n\n\nNote that these operations do \nnot\n check bounds of valid range:\n\n\njulia\n \nDNA_C\n \n-\n \n2\n\n\nInvalid\n \nDNA\n \nNucleotide\n\n\n\njulia\n \nDNA_A\n \n+\n \n30\n\n\nInvalid\n \nDNA\n \nNucleotide\n\n\n\n\n\n\n\n\nOther functions\n\n\n#\n\n\nBio.Seq.alphabet\n \n \nFunction\n.\n\n\nalphabet(typ)\n\n\n\n\n\nReturn an iterator of symbols of \ntyp\n.\n\n\ntyp\n is one of \nDNANucleotide\n, \nRNANucleotide\n, or \nAminoAcid\n.\n\n\n#\n\n\nBio.Seq.gap\n \n \nFunction\n.\n\n\ngap(typ)\n\n\n\n\n\nReturn the gap symbol of \ntyp\n.\n\n\ntyp\n is one of \nDNANucleotide\n, \nRNANucleotide\n, \nAminoAcid\n, or \nChar\n.\n\n\n\n\nSequences\n\n\nThe \nBio.Seq\n module provides representations and tools for manipulating nucleotide and amino acid sequences. Sequences in Bio.jl are more strictly typed than in many other libraries. They are special purpose types rather than simply strings. Bio.jl currently provides a single generic sequence type: \nBioSequence{A\n:Alphabet}\n. \nBioSequence\n is parameterized by an alphabet type \nA\n that defines the domain (or set) of biological symbols, and each alphabet has an associated symbol type. For example, \nAminoAcidAlphabet\n is associated with \nAminoAcid\n and hence an object of \nBioSequence{AminoAcidAlphabet}\n represents a sequence of amino acids.  Symbols from multiple alphabets can't be intermixed in one sequence type.\n\n\nThe following table summarizes common sequence types that are defined in the \nBio.Seq\n module:\n\n\n\n\n\n\n\n\nType\n\n\nSymbol type\n\n\nType alias\n\n\n\n\n\n\n\n\n\n\nBioSequence{DNAAlphabet{4}}\n\n\nDNANucleotide\n\n\nDNASequence\n\n\n\n\n\n\nBioSequence{RNAAlphabet{4}}\n\n\nRNANucleotide\n\n\nRNASequence\n\n\n\n\n\n\nBioSequence{AminoAcidAlphabet}\n\n\nAminoAcid\n\n\nAminoAcidSequence\n\n\n\n\n\n\nBioSequence{CharAlphabet}\n\n\nChar\n\n\nCharSequence\n\n\n\n\n\n\n\n\nThough this strictness sacrifices some convenience, it also means you can always rely on a \nDNASequence\n to store DNA and nothing but DNA, without having to check, or deal with lowercase versus uppercase and so on. Strict separation of sequence types also means we are free to choose the most efficient representation. DNA and RNA sequences are encoded using four bits per base by default making them memory efficient, and also allowing us to speed up many common operations like nucleotide composition, reverse complement, and \nk\n-mer enumeration.\n\n\n\n\nConstructing sequences\n\n\nSequence types corresponding to these alphabets can be constructed a number of different ways. Most immediately, sequence literals can be constructed using the string macros \ndna\n, \nrna\n, \naa\n, and \nchar\n:\n\n\n# String decorators are provided for common sequence types\n\n\njulia\n \ndna\nTACGTANNATC\n\n\n11\nnt\n \nDNA\n \nSequence\n:\n\n\nTACGTANNATC\n\n\n\njulia\n \nrna\nAUUUGNCCANU\n\n\n11\nnt\n \nRNA\n \nSequence\n:\n\n\nAUUUGNCCANU\n\n\n\njulia\n \naa\nARNDCQEGHILKMFPSTWYVX\n\n\n21\naa\n \nAmino\n \nAcid\n \nSequence\n:\n\n\nARNDCQEGHILKMFPSTWYVX\n\n\n\njulia\n \nchar\n\u03b1\u03b2\u03b3\u03b4\u03f5\n\n\n5\nchar\n \nChar\n \nSequence\n:\n\n\n\u03b1\u03b2\u03b3\u03b4\u03f5\n\n\n\n\n\n\nSequence can also be constructed from strings or arrays of nucleotide or amino acid symbols using constructors or the \nconvert\n function:\n\n\njulia\n \nDNASequence\n(\nTTANC\n)\n\n\n5\nnt\n \nDNA\n \nSequence\n:\n\n\nTTANC\n\n\n\njulia\n \nDNASequence\n([\nDNA_T\n,\n \nDNA_T\n,\n \nDNA_A\n,\n \nDNA_N\n,\n \nDNA_C\n])\n\n\n5\nnt\n \nDNA\n \nSequence\n:\n\n\nTTANC\n\n\n\njulia\n \nconvert\n(\nDNASequence\n,\n \n[\nDNA_T\n,\n \nDNA_T\n,\n \nDNA_A\n,\n \nDNA_N\n,\n \nDNA_C\n])\n\n\n5\nnt\n \nDNA\n \nSequence\n:\n\n\nTTANC\n\n\n\n\n\n\nUsing \nconvert\n, these operations are reversible: sequences can be converted to strings or arrays:\n\n\njulia\n \nconvert\n(\nASCIIString\n,\n \ndna\nTTANGTA\n)\n\n\nTTANGTA\n\n\n\njulia\n \nconvert\n(\nVector\n{\nDNANucleotide\n},\n \ndna\nTTANGTA\n)\n\n\n7\n-\nelement\n \nArray\n{\nBio\n.\nSeq\n.\nDNANucleotide\n,\n1\n}:\n\n \nT\n\n \nT\n\n \nA\n\n \nN\n\n \nG\n\n \nT\n\n \nA\n\n\n\n\n\n\nSequences can also be concatenated into longer sequences:\n\n\njulia\n \nDNASequence\n(\ndna\nACGT\n,\n \ndna\nNNNN\n,\n \ndna\nTGCA\n)\n\n\n12\nnt\n \nDNA\n \nSequence\n:\n\n\nACGTNNNNTGCA\n\n\n\njulia\n \ndna\nACGT\n \n*\n \ndna\nTGCA\n\n\n8\nnt\n \nDNA\n \nSequence\n:\n\n\nACGTTGCA\n\n\n\njulia\n \nrepeat\n(\ndna\nTA\n,\n \n10\n)\n\n\n20\nnt\n \nDNA\n \nSequence\n:\n\n\nTATATATATATATATATATA\n\n\n\njulia\n \ndna\nTA\n \n^\n \n10\n\n\n20\nnt\n \nDNA\n \nSequence\n:\n\n\nTATATATATATATATATATA\n\n\n\n\n\n\nDespite being separate types, \nDNASequence\n and \nRNASequence\n can freely be converted between efficiently without copying the underlying data:\n\n\njulia\n \ndna\n \n=\n \ndna\nTTANGTAGACCG\n\n\n12\nnt\n \nDNA\n \nSequence\n:\n\n\nTTANGTAGACCG\n\n\n\njulia\n \nrna\n \n=\n \nconvert\n(\nRNASequence\n,\n \ndna\n)\n\n\n12\nnt\n \nRNA\n \nSequence\n:\n\n\nUUANGUAGACCG\n\n\n\njulia\n \ndna\n.\ndata\n \n===\n \nrna\n.\ndata\n  \n# underlying data are same\n\n\ntrue\n\n\n\n\n\n\nA translatable \nRNASequence\n can also be converted to an \nAminoAcidSequence\n using the \ntranslate\n function described below.\n\n\n\n\nIndexing and modifying\n\n\nSequences for the most part behave like other vector or string types. They can be indexed using integers or ranges:\n\n\njulia\n \nseq\n \n=\n \ndna\nACGTTTANAGTNNAGTACC\n\n\n19\nnt\n \nDNA\n \nSequence\n:\n\n\nACGTTTANAGTNNAGTACC\n\n\n\njulia\n \nseq\n[\n5\n]\n\n\nT\n\n\n\njulia\n \nseq\n[\n6\n:\nend\n]\n\n\n14\nnt\n \nDNA\n \nSequence\n:\n\n\nTANAGTNNAGTACC\n\n\n\n\n\n\nIndexing by range creates a subsequence of the original sequence. Unlike \nASCIIString\n and \nVector\n in the standard library, creating a subsequences is copy-free: a subsequence is just a reference to the original sequence with its range.  You may think that this is unsafe because modifying subsequences propagates to the original sequence, but this doesn't happen actually:\n\n\njulia\n \nseq\n \n=\n \ndna\nAAAA\n  \n# create a sequence\n\n\n4\nnt\n \nDNA\n \nSequence\n:\n\n\nAAAA\n\n\n\njulia\n \nsubseq\n \n=\n \nseq\n[\n1\n:\n2\n]\n  \n# create a subsequence from `seq`\n\n\n2\nnt\n \nDNA\n \nSequence\n:\n\n\nAA\n\n\n\njulia\n \nsubseq\n[\n2\n]\n \n=\n \nDNA_T\n  \n# modify the second element of it\n\n\nT\n\n\n\njulia\n \nsubseq\n  \n# the subsequence is modified\n\n\n2\nnt\n \nDNA\n \nSequence\n:\n\n\nAT\n\n\n\njulia\n \nseq\n  \n# but the original sequence is not\n\n\n4\nnt\n \nDNA\n \nSequence\n:\n\n\nAAAA\n\n\n\n\n\n\nThis is because modifying a sequence checks whether its underlying data are shared with other sequences under the hood. If and only if the data are shared, the subsequence creates a copy of itself. Any modifying operation does this check. This is called \ncopy-on-write\n strategy and users don't need to care about it because it is transparent from outward.\n\n\nThe following modifying operations are currently supported:\n\n\nsetindex!\n(\nseq\n,\n \nitem\n,\n \nindex\n)\n\n\npush!\n(\nseq\n,\n \nitem\n)\n\n\npop!\n(\nseq\n)\n\n\nshift!\n(\nseq\n)\n\n\nunshift!\n(\nseq\n,\n \nitem\n)\n\n\ninsert!\n(\nseq\n,\n \nindex\n,\n \nitem\n)\n\n\ndeleteat!\n(\nseq\n,\n \nindex\n)\n\n\nappend!\n(\nseq\n,\n \nother_seq\n)\n\n\ncopy!\n(\ndst_seq\n,\n \ndest_offset\n,\n \nsrc_seq\n,\n \nsrc_offset\n,\n \nlen\n)\n\n\nreverse!\n(\nseq\n)\n\n\n\n\n\n\n#\n\n\nBio.Seq.complement!\n \n \nMethod\n.\n\n\ncomplement!(seq)\n\n\n\n\n\nMake a complement sequence of \nseq\n in place.\n\n\nAmbiguous nucleotides are left as-is.\n\n\n#\n\n\nBio.Seq.reverse_complement!\n \n \nMethod\n.\n\n\nreverse_complement!(seq)\n\n\n\n\n\nMake a reversed complement sequence of \nseq\n in place.\n\n\nAmbiguous nucleotides are left as-is.\n\n\njulia\n \nseq\n \n=\n \ndna\nACG\n\n\n3\nnt\n \nDNA\n \nSequence\n:\n\n\nACG\n\n\n\njulia\n \npush!\n(\nseq\n,\n \nDNA_T\n)\n\n\n4\nnt\n \nDNA\n \nSequence\n:\n\n\nACGT\n\n\n\njulia\n \nappend!\n(\nseq\n,\n \ndna\nAT\n)\n\n\n6\nnt\n \nDNA\n \nSequence\n:\n\n\nACGTAT\n\n\n\njulia\n \nreverse!\n(\nseq\n)\n\n\n6\nnt\n \nDNA\n \nSequence\n:\n\n\nTATGCA\n\n\n\njulia\n \nSeq\n.\ncomplement!\n(\nseq\n)\n  \n# semantically differs from Base.complement!\n\n\n6\nnt\n \nDNA\n \nSequence\n:\n\n\nATACGT\n\n\n\njulia\n \nreverse_complement!\n(\nseq\n)\n\n\n6\nnt\n \nDNA\n \nSequence\n:\n\n\nACGTAT\n\n\n\n\n\n\nSequences also work as iterators over symbols:\n\n\njulia\n \nn\n \n=\n \n0\n\n\n0\n\n\n\njulia\n \nfor\n \nnt\n \nin\n \ndna\nATNGNNT\n\n           \nif\n \nnt\n \n==\n \nDNA_N\n\n               \nn\n \n+=\n \n1\n\n           \nend\n\n       \nend\n\n\n\njulia\n \nn\n\n\n3\n\n\n\n\n\n\n\n\nOther operations on sequences\n\n\nA number of common sequence operations are provided in the \nBio.Seq\n module:\n\n\n#\n\n\nBio.Seq.complement\n \n \nFunction\n.\n\n\ncomplement(kmer::Kmer)\n\n\nThe Kmer complement of \nkmer\n\n\ncomplement(seq)\n\n\n\n\n\nMake a complement sequence of \nseq\n.\n\n\nAmbiguous nucleotides are left as-is.\n\n\n#\n\n\nBio.Seq.reverse_complement\n \n \nFunction\n.\n\n\nreverse_complement(kmer::Kmer)\n\n\nReversed complement of \nkmer\n\n\nreverse_complement(seq)\n\n\n\n\n\nMake a reversed complement sequence of \nseq\n.\n\n\nAmbiguous nucleotides are left as-is.\n\n\n#\n\n\nBio.Seq.mismatches\n \n \nFunction\n.\n\n\nmismatches(a::Kmer, b::Kmer)\n\n\nReturn the number of mismatches between \na\n and \nb\n.\n\n\nArguments\n\n\n\n\na\n: first sequence to compare\n\n\nb\n: second sequence to compare\n\n\n\n\nReturns\n\n\nThe number of mismatches\n\n\nmismatches(a::NucleotideSequence, b::NucleotideSequence, [nmatches=false])\n\n\nReturn the number of mismatches between \na\n and \nb\n.\n\n\nIf \na\n and \nb\n are of differing lengths, only the first \nmin(length(a), length(b))\n nucleotides are compared.\n\n\nArguments\n\n\n\n\na\n: first sequence to compare\n\n\nb\n: second sequence to compare\n\n\nnmatches\n: if true, N matches anything, if false, N matches only itself (false)\n\n\n\n\nReturns\n\n\nThe number of mismatches\n\n\n#\n\n\nBio.Seq.composition\n \n \nFunction\n.\n\n\ncomposition(seq)\n\n\n\n\n\nCalculate composition of biological symbols in \nseq\n.\n\n\n\n\nTranslation\n\n\nThe \ntranslate\n funtion translates a sequence of codons in a RNA sequence to a amino acid sequence besed on a genetic code mapping.  The \nBio.Seq\n module contains all NCBI defined genetic codes and they are registered in \nncbi_trans_table\n.\n\n\n#\n\n\nBio.Seq.translate\n \n \nFunction\n.\n\n\ntranslate(rna_seq, code=standard_genetic_code, allow_ambiguous_codons=true)\n\n\n\n\n\nTranslate an \nRNASequence\n to an \nAminoAcidSequence\n.\n\n\nTranslation uses genetic code \ncode\n to map codons to amino acids. See \nncbi_trans_table\n for available genetic codes. If codons in the given RNA sequence cannot determine a unique amino acid, they will be translated to \nAA_X\n if \nallow_ambiguous_codons\n is \ntrue\n and otherwise result in an error.\n\n\n#\n\n\nBio.Seq.ncbi_trans_table\n \n \nConstant\n.\n\n\nGenetic code list of NCBI.\n\n\nThe standard genetic code is \nncbi_trans_table[1]\n and others can be shown by \nshow(ncbi_trans_table)\n. For more details, consult the next link: http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes.\n\n\njulia\n \nncbi_trans_table\n\n\nTranslation\n \nTables\n:\n\n  \n1.\n \nThe\n \nStandard\n \nCode\n \n(\nstandard_genetic_code\n)\n\n  \n2.\n \nThe\n \nVertebrate\n \nMitochondrial\n \nCode\n \n(\nvertebrate_mitochondrial_genetic_code\n)\n\n  \n3.\n \nThe\n \nYeast\n \nMitochondrial\n \nCode\n \n(\nyeast_mitochondrial_genetic_code\n)\n\n  \n4.\n \nThe\n \nMold\n,\n \nProtozoan\n,\n \nand\n \nCoelenterate\n \nMitochondrial\n \nCode\n \nand\n \nthe\n \nMycoplasma\n/\nSpiroplasma\n \nCode\n \n(\nmold_mitochondrial_genetic_code\n)\n\n  \n5.\n \nThe\n \nInvertebrate\n \nMitochondrial\n \nCode\n \n(\ninvertebrate_mitochondrial_genetic_code\n)\n\n  \n6.\n \nThe\n \nCiliate\n,\n \nDasycladacean\n \nand\n \nHexamita\n \nNuclear\n \nCode\n \n(\nciliate_nuclear_genetic_code\n)\n\n  \n9.\n \nThe\n \nEchinoderm\n \nand\n \nFlatworm\n \nMitochondrial\n \nCode\n \n(\nechinoderm_mitochondrial_genetic_code\n)\n\n \n10.\n \nThe\n \nEuplotid\n \nNuclear\n \nCode\n \n(\neuplotid_nuclear_genetic_code\n)\n\n \n11.\n \nThe\n \nBacterial\n,\n \nArchaeal\n \nand\n \nPlant\n \nPlastid\n \nCode\n \n(\nbacterial_plastid_genetic_code\n)\n\n \n12.\n \nThe\n \nAlternative\n \nYeast\n \nNuclear\n \nCode\n \n(\nalternative_yeast_nuclear_genetic_code\n)\n\n \n13.\n \nThe\n \nAscidian\n \nMitochondrial\n \nCode\n \n(\nascidian_mitochondrial_genetic_code\n)\n\n \n14.\n \nThe\n \nAlternative\n \nFlatworm\n \nMitochondrial\n \nCode\n \n(\nalternative_flatworm_mitochondrial_genetic_code\n)\n\n \n16.\n \nChlorophycean\n \nMitochondrial\n \nCode\n \n(\nchlorophycean_mitochondrial_genetic_code\n)\n\n \n21.\n \nTrematode\n \nMitochondrial\n \nCode\n \n(\ntrematode_mitochondrial_genetic_code\n)\n\n \n22.\n \nScenedesmus\n \nobliquus\n \nMitochondrial\n \nCode\n \n(\nscenedesmus_obliquus_mitochondrial_genetic_code\n)\n\n \n23.\n \nThraustochytrium\n \nMitochondrial\n \nCode\n \n(\nthraustochytrium_mitochondrial_genetic_code\n)\n\n \n24.\n \nPterobranchia\n \nMitochondrial\n \nCode\n \n(\npterobrachia_mitochondrial_genetic_code\n)\n\n \n25.\n \nCandidate\n \nDivision\n \nSR1\n \nand\n \nGracilibacteria\n \nCode\n \n(\ncandidate_division_sr1_genetic_code\n)\n\n\n\n\n\n\nhttp://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes\n\n\n\n\nCompact representation\n\n\nAs we saw above, DNA and RNA sequences can store any ambiguous nucleotides like 'N'.  If you are sure that nucleotide sequences store unambiguous nucleotides only, you can save the memory space of sequences. \nDNAAlphabet{2}\n is an alphabet that uses two bits per base and limits to only unambiguous nucleotide symbols (ACGT in DNA and ACGU in RNA). To create a sequence of this alphabet, you need to explicitly pass \nDNAAlphabet{2}\n to \nBioSequence\n as its parametric type:\n\n\njulia\n \nseq\n \n=\n \nBioSequence\n{\nDNAAlphabet\n{\n2\n}}(\nACGT\n)\n\n\n4\nnt\n \nDNA\n \nSequence\n:\n\n\nACGT\n\n\n\n\n\n\nRecall that \nDNASequence\n is a type alias of \nBioSequence{DNAAlphabet{4}}\n, which uses four bits per base. That is, \nBioSequence{DNAAlphabet{2}}\n saves half of memory footprint compared to \nBioSequence{DNAAlphabet{4}}\n. If you need to handle reference sequences that are composed of five nucleotides, ACGTN, consider to use \nReferenceSequences.jl\n. \nReferenceSequence\n, exported from this package, compresses positions of 'N' and enables to handle long DNA sequences with the near space of two-bit encoding.\n\n\n\n\nNucleotide k-mers\n\n\nA common strategy to simplify the analysis of sequence data is to operate or short k-mers, for size fixed size \nk\n. These can be packed into machine integers allowing extremely efficient code. The \nBio.Seq\n module has built in support for representing short sequences in 64-bit integers. Besides being fixed length, \nKmer\n types, unlike other sequence types cannot contain ambiguous symbols like 'N'.\n\n\nThe \nKmer{T,k}\n type parameterized on alphabet (\nT\n, either \nDNANucleotide\n, or \nRNANucleotide\n) and size \nk\n. A number of functions are provided for operating on \nKmers\n.\n\n\n#\n\n\nBio.Seq.each\n \n \nFunction\n.\n\n\nInitialize an iterator over all k-mers in a sequence.\n\n\nAny k-mer containing an N will be skipped over.\n\n\nArguments\n\n\n\n\nt\n: Kmer type to enumerate.\n\n\nseq\n: A NucleotideSequence\n\n\nstep\n: number of positions between iterated k-mers (default: 1)\n\n\n\n\nReturns\n\n\nA EachKmerIterator constructed with these parameters\n\n\nExamples\n\n\n# iterate over codons\nfor (pos, codon) in each(DNAKmer{3}, dna\nATCCTANAGNTACT\n, 3)\n    @show pos, codon\nend\n\n\n\n\n\n#\n\n\nBio.Seq.KmerCounts\n \n \nType\n.\n\n\nCount ocurrences of short (\n= 32) k-mers in a sequence.\n\n\nThis method uses a dense table to store counts, requiring O(4^k) memory, so is not recommended for large k-mer sizes.\n\n\nArguments:\n\n\n\n\n'seq`: A NucleotideSequence\n\n\nstep\n: K-mers counted are separated by this many nucleotides (deafult: 1)\n\n\n\n\n#\n\n\nBio.Seq.canonical\n \n \nFunction\n.\n\n\nCanonical k-mer of \nx\n\n\nA canonical k-mer is the numerical lesser of a k-mer and its reverse complement. This is useful in hashing/counting k-mers in data that is not strand specific, and thus observing k-mer is equivalent to observing its reverse complement.\n\n\n#\n\n\nBio.Seq.neighbors\n \n \nFunction\n.\n\n\nIterate through k-mers neighboring \nx\n on a de Bruijn graph.\n\n\n\n\nSequence records\n\n\nThe \nSeqRecord\n type is used to represent a named sequence, optionally with accompanying metadata. It is defined as: sequence. It is as:\n\n\ntype\n SeqRecord\n{\nS\n,\n \nT\n}\n\n    \nname\n::\nString\n\n    \nseq\n::\nS\n\n    \nmetadata\n::\nT\n\n\nend\n\n\n\n\n\n\nThe type of the \nmetadata\n field depends on the source of the sequence record. For example, if a record is read from a FASTA file, metadata contains the description field. If from a FASTQ file, a quality scores assigned to base calls during sequencing.", 
            "title": "Biological Sequences"
        }, 
        {
            "location": "/man/seq/#bioseq-biological-sequences", 
            "text": "The  Bio.Seq  module provides several data types for handling biological symbols and sequences.", 
            "title": "Bio.Seq: Biological Sequences"
        }, 
        {
            "location": "/man/seq/#biological-symbols", 
            "text": "The  Bio.Seq  module provides three biological symbol (character) types:     Type  Meaning      DNANucleotide  DNA nucleotide    RNANucleotide  RNA nucleotide    AminoAcid  Amino acid     These symbols can be elements of sequences like characters can be elements of strings.  See  Sequences  and  Nucleotide k-mers  section for details.", 
            "title": "Biological symbols"
        }, 
        {
            "location": "/man/seq/#dna-and-rna-nucleotides", 
            "text": "Set of nucleotide symbols in Bio.jl covers IUPAC nucleotide base plus a gap symbol:     Symbol  Constant  Meaning      'A'  DNA_A  /  RNA_A  A; Adenine    'C'  DNA_C  /  RNA_C  C; Cytosine    'G'  DNA_G  /  RNA_G  G; Guanine    'T'  DNA_T  T; Thymine (DNA only)    'U'  RNA_U  U; Uracil (RNA only)    'M'  DNA_M  /  RNA_M  A or C    'R'  DNA_R  /  RNA_R  A or G    'W'  DNA_W  /  RNA_W  A or T    'S'  DNA_S  /  RNA_S  C or G    'Y'  DNA_Y  /  RNA_Y  C or T    'K'  DNA_K  /  RNA_K  G or T    'V'  DNA_V  /  RNA_V  A or C or G; not T    'H'  DNA_H  /  RNA_H  A or C or T; not G    'D'  DNA_D  /  RNA_D  A or G or T; not C    'B'  DNA_B  /  RNA_B  C or G or T; not A    'N'  DNA_N  /  RNA_N  A or C or G or T    '-'  DNA_Gap  /  RNA_Gap  Gap (none of the above)     http://www.insdc.org/documents/feature_table.html#7.4.1  Symbols are accessible as constants with  DNA_  or  RNA_  prefix:  julia   DNA_A  A  julia   DNA_T  T  julia   RNA_U  U  julia   DNA_Gap  -  julia   typeof ( DNA_A )  Bio . Seq . DNANucleotide  julia   typeof ( RNA_A )  Bio . Seq . RNANucleotide   Symbols can be constructed by converting regular characters:  julia   convert ( DNANucleotide ,   C )  C  julia   convert ( DNANucleotide ,   C )   ===   DNA_C  true", 
            "title": "DNA and RNA nucleotides"
        }, 
        {
            "location": "/man/seq/#amino-acids", 
            "text": "Set of amino acid symbols also covers IUPAC amino acid symbols plus a gap symbol:     Symbol  Constant  Meaning      'A'  AA_A  Alanine    'R'  AA_R  Arginine    'N'  AA_N  Asparagine    'D'  AA_D  Aspartic acid (Aspartate)    'C'  AA_C  Cysteine    'Q'  AA_Q  Glutamine    'E'  AA_E  Glutamic acid (Glutamate)    'G'  AA_G  Glycine    'H'  AA_H  Histidine    'I'  AA_I  Isoleucine    'L'  AA_L  Leucine    'K'  AA_K  Lysine    'M'  AA_M  Methionine    'F'  AA_F  Phenylalanine    'P'  AA_P  Proline    'S'  AA_S  Serine    'T'  AA_T  Threonine    'W'  AA_W  Tryptophan    'Y'  AA_Y  Tyrosine    'V'  AA_V  Valine    'O'  AA_O  Pyrrolysine    'U'  AA_U  Selenocysteine    'B'  AA_B  Aspartic acid or Asparagine    'J'  AA_J  Leucine or Isoleucine    'Z'  AA_Z  Glutamine or Glutamic acid    'X'  AA_X  Any amino acid    '*'  AA_Term  Termination codon    '-'  AA_Gap  Gap (none of the above)     http://www.insdc.org/documents/feature_table.html#7.4.3  Symbols are accessible as constants with  AA_  prefix:  julia   AA_A  A  julia   AA_Q  Q  julia   AA_Term  *  julia   typeof ( AA_A )  Bio . Seq . AminoAcid   Symbols can be constructed by converting regular characters:  julia   convert ( AminoAcid ,   A )  A  julia   convert ( AminoAcid ,   P )   ===   AA_P  true", 
            "title": "Amino acids"
        }, 
        {
            "location": "/man/seq/#arithmetic", 
            "text": "Biological symbols behaves like  Char :  julia   DNA_A   ==   DNA_A    # equivalence  true  julia   DNA_A     DNA_C     DNA_G     DNA_T    # order  true  julia   DNA_A   +   1    # addition  C  julia   DNA_T   -   3    # subtraction  A  julia   DNA_T   -   DNA_C    # difference  2   Note that these operations do  not  check bounds of valid range:  julia   DNA_C   -   2  Invalid   DNA   Nucleotide  julia   DNA_A   +   30  Invalid   DNA   Nucleotide", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/man/seq/#other-functions", 
            "text": "#  Bio.Seq.alphabet     Function .  alphabet(typ)  Return an iterator of symbols of  typ .  typ  is one of  DNANucleotide ,  RNANucleotide , or  AminoAcid .  #  Bio.Seq.gap     Function .  gap(typ)  Return the gap symbol of  typ .  typ  is one of  DNANucleotide ,  RNANucleotide ,  AminoAcid , or  Char .", 
            "title": "Other functions"
        }, 
        {
            "location": "/man/seq/#sequences", 
            "text": "The  Bio.Seq  module provides representations and tools for manipulating nucleotide and amino acid sequences. Sequences in Bio.jl are more strictly typed than in many other libraries. They are special purpose types rather than simply strings. Bio.jl currently provides a single generic sequence type:  BioSequence{A :Alphabet} .  BioSequence  is parameterized by an alphabet type  A  that defines the domain (or set) of biological symbols, and each alphabet has an associated symbol type. For example,  AminoAcidAlphabet  is associated with  AminoAcid  and hence an object of  BioSequence{AminoAcidAlphabet}  represents a sequence of amino acids.  Symbols from multiple alphabets can't be intermixed in one sequence type.  The following table summarizes common sequence types that are defined in the  Bio.Seq  module:     Type  Symbol type  Type alias      BioSequence{DNAAlphabet{4}}  DNANucleotide  DNASequence    BioSequence{RNAAlphabet{4}}  RNANucleotide  RNASequence    BioSequence{AminoAcidAlphabet}  AminoAcid  AminoAcidSequence    BioSequence{CharAlphabet}  Char  CharSequence     Though this strictness sacrifices some convenience, it also means you can always rely on a  DNASequence  to store DNA and nothing but DNA, without having to check, or deal with lowercase versus uppercase and so on. Strict separation of sequence types also means we are free to choose the most efficient representation. DNA and RNA sequences are encoded using four bits per base by default making them memory efficient, and also allowing us to speed up many common operations like nucleotide composition, reverse complement, and  k -mer enumeration.", 
            "title": "Sequences"
        }, 
        {
            "location": "/man/seq/#constructing-sequences", 
            "text": "Sequence types corresponding to these alphabets can be constructed a number of different ways. Most immediately, sequence literals can be constructed using the string macros  dna ,  rna ,  aa , and  char :  # String decorators are provided for common sequence types  julia   dna TACGTANNATC  11 nt   DNA   Sequence :  TACGTANNATC  julia   rna AUUUGNCCANU  11 nt   RNA   Sequence :  AUUUGNCCANU  julia   aa ARNDCQEGHILKMFPSTWYVX  21 aa   Amino   Acid   Sequence :  ARNDCQEGHILKMFPSTWYVX  julia   char \u03b1\u03b2\u03b3\u03b4\u03f5  5 char   Char   Sequence :  \u03b1\u03b2\u03b3\u03b4\u03f5   Sequence can also be constructed from strings or arrays of nucleotide or amino acid symbols using constructors or the  convert  function:  julia   DNASequence ( TTANC )  5 nt   DNA   Sequence :  TTANC  julia   DNASequence ([ DNA_T ,   DNA_T ,   DNA_A ,   DNA_N ,   DNA_C ])  5 nt   DNA   Sequence :  TTANC  julia   convert ( DNASequence ,   [ DNA_T ,   DNA_T ,   DNA_A ,   DNA_N ,   DNA_C ])  5 nt   DNA   Sequence :  TTANC   Using  convert , these operations are reversible: sequences can be converted to strings or arrays:  julia   convert ( ASCIIString ,   dna TTANGTA )  TTANGTA  julia   convert ( Vector { DNANucleotide },   dna TTANGTA )  7 - element   Array { Bio . Seq . DNANucleotide , 1 }: \n  T \n  T \n  A \n  N \n  G \n  T \n  A   Sequences can also be concatenated into longer sequences:  julia   DNASequence ( dna ACGT ,   dna NNNN ,   dna TGCA )  12 nt   DNA   Sequence :  ACGTNNNNTGCA  julia   dna ACGT   *   dna TGCA  8 nt   DNA   Sequence :  ACGTTGCA  julia   repeat ( dna TA ,   10 )  20 nt   DNA   Sequence :  TATATATATATATATATATA  julia   dna TA   ^   10  20 nt   DNA   Sequence :  TATATATATATATATATATA   Despite being separate types,  DNASequence  and  RNASequence  can freely be converted between efficiently without copying the underlying data:  julia   dna   =   dna TTANGTAGACCG  12 nt   DNA   Sequence :  TTANGTAGACCG  julia   rna   =   convert ( RNASequence ,   dna )  12 nt   RNA   Sequence :  UUANGUAGACCG  julia   dna . data   ===   rna . data    # underlying data are same  true   A translatable  RNASequence  can also be converted to an  AminoAcidSequence  using the  translate  function described below.", 
            "title": "Constructing sequences"
        }, 
        {
            "location": "/man/seq/#indexing-and-modifying", 
            "text": "Sequences for the most part behave like other vector or string types. They can be indexed using integers or ranges:  julia   seq   =   dna ACGTTTANAGTNNAGTACC  19 nt   DNA   Sequence :  ACGTTTANAGTNNAGTACC  julia   seq [ 5 ]  T  julia   seq [ 6 : end ]  14 nt   DNA   Sequence :  TANAGTNNAGTACC   Indexing by range creates a subsequence of the original sequence. Unlike  ASCIIString  and  Vector  in the standard library, creating a subsequences is copy-free: a subsequence is just a reference to the original sequence with its range.  You may think that this is unsafe because modifying subsequences propagates to the original sequence, but this doesn't happen actually:  julia   seq   =   dna AAAA    # create a sequence  4 nt   DNA   Sequence :  AAAA  julia   subseq   =   seq [ 1 : 2 ]    # create a subsequence from `seq`  2 nt   DNA   Sequence :  AA  julia   subseq [ 2 ]   =   DNA_T    # modify the second element of it  T  julia   subseq    # the subsequence is modified  2 nt   DNA   Sequence :  AT  julia   seq    # but the original sequence is not  4 nt   DNA   Sequence :  AAAA   This is because modifying a sequence checks whether its underlying data are shared with other sequences under the hood. If and only if the data are shared, the subsequence creates a copy of itself. Any modifying operation does this check. This is called  copy-on-write  strategy and users don't need to care about it because it is transparent from outward.  The following modifying operations are currently supported:  setindex! ( seq ,   item ,   index )  push! ( seq ,   item )  pop! ( seq )  shift! ( seq )  unshift! ( seq ,   item )  insert! ( seq ,   index ,   item )  deleteat! ( seq ,   index )  append! ( seq ,   other_seq )  copy! ( dst_seq ,   dest_offset ,   src_seq ,   src_offset ,   len )  reverse! ( seq )   #  Bio.Seq.complement!     Method .  complement!(seq)  Make a complement sequence of  seq  in place.  Ambiguous nucleotides are left as-is.  #  Bio.Seq.reverse_complement!     Method .  reverse_complement!(seq)  Make a reversed complement sequence of  seq  in place.  Ambiguous nucleotides are left as-is.  julia   seq   =   dna ACG  3 nt   DNA   Sequence :  ACG  julia   push! ( seq ,   DNA_T )  4 nt   DNA   Sequence :  ACGT  julia   append! ( seq ,   dna AT )  6 nt   DNA   Sequence :  ACGTAT  julia   reverse! ( seq )  6 nt   DNA   Sequence :  TATGCA  julia   Seq . complement! ( seq )    # semantically differs from Base.complement!  6 nt   DNA   Sequence :  ATACGT  julia   reverse_complement! ( seq )  6 nt   DNA   Sequence :  ACGTAT   Sequences also work as iterators over symbols:  julia   n   =   0  0  julia   for   nt   in   dna ATNGNNT \n            if   nt   ==   DNA_N \n                n   +=   1 \n            end \n        end  julia   n  3", 
            "title": "Indexing and modifying"
        }, 
        {
            "location": "/man/seq/#other-operations-on-sequences", 
            "text": "A number of common sequence operations are provided in the  Bio.Seq  module:  #  Bio.Seq.complement     Function .  complement(kmer::Kmer)  The Kmer complement of  kmer  complement(seq)  Make a complement sequence of  seq .  Ambiguous nucleotides are left as-is.  #  Bio.Seq.reverse_complement     Function .  reverse_complement(kmer::Kmer)  Reversed complement of  kmer  reverse_complement(seq)  Make a reversed complement sequence of  seq .  Ambiguous nucleotides are left as-is.  #  Bio.Seq.mismatches     Function .  mismatches(a::Kmer, b::Kmer)  Return the number of mismatches between  a  and  b .", 
            "title": "Other operations on sequences"
        }, 
        {
            "location": "/man/seq/#arguments", 
            "text": "a : first sequence to compare  b : second sequence to compare", 
            "title": "Arguments"
        }, 
        {
            "location": "/man/seq/#returns", 
            "text": "The number of mismatches  mismatches(a::NucleotideSequence, b::NucleotideSequence, [nmatches=false])  Return the number of mismatches between  a  and  b .  If  a  and  b  are of differing lengths, only the first  min(length(a), length(b))  nucleotides are compared.", 
            "title": "Returns"
        }, 
        {
            "location": "/man/seq/#arguments_1", 
            "text": "a : first sequence to compare  b : second sequence to compare  nmatches : if true, N matches anything, if false, N matches only itself (false)", 
            "title": "Arguments"
        }, 
        {
            "location": "/man/seq/#returns_1", 
            "text": "The number of mismatches  #  Bio.Seq.composition     Function .  composition(seq)  Calculate composition of biological symbols in  seq .", 
            "title": "Returns"
        }, 
        {
            "location": "/man/seq/#translation", 
            "text": "The  translate  funtion translates a sequence of codons in a RNA sequence to a amino acid sequence besed on a genetic code mapping.  The  Bio.Seq  module contains all NCBI defined genetic codes and they are registered in  ncbi_trans_table .  #  Bio.Seq.translate     Function .  translate(rna_seq, code=standard_genetic_code, allow_ambiguous_codons=true)  Translate an  RNASequence  to an  AminoAcidSequence .  Translation uses genetic code  code  to map codons to amino acids. See  ncbi_trans_table  for available genetic codes. If codons in the given RNA sequence cannot determine a unique amino acid, they will be translated to  AA_X  if  allow_ambiguous_codons  is  true  and otherwise result in an error.  #  Bio.Seq.ncbi_trans_table     Constant .  Genetic code list of NCBI.  The standard genetic code is  ncbi_trans_table[1]  and others can be shown by  show(ncbi_trans_table) . For more details, consult the next link: http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes.  julia   ncbi_trans_table  Translation   Tables : \n   1.   The   Standard   Code   ( standard_genetic_code ) \n   2.   The   Vertebrate   Mitochondrial   Code   ( vertebrate_mitochondrial_genetic_code ) \n   3.   The   Yeast   Mitochondrial   Code   ( yeast_mitochondrial_genetic_code ) \n   4.   The   Mold ,   Protozoan ,   and   Coelenterate   Mitochondrial   Code   and   the   Mycoplasma / Spiroplasma   Code   ( mold_mitochondrial_genetic_code ) \n   5.   The   Invertebrate   Mitochondrial   Code   ( invertebrate_mitochondrial_genetic_code ) \n   6.   The   Ciliate ,   Dasycladacean   and   Hexamita   Nuclear   Code   ( ciliate_nuclear_genetic_code ) \n   9.   The   Echinoderm   and   Flatworm   Mitochondrial   Code   ( echinoderm_mitochondrial_genetic_code ) \n  10.   The   Euplotid   Nuclear   Code   ( euplotid_nuclear_genetic_code ) \n  11.   The   Bacterial ,   Archaeal   and   Plant   Plastid   Code   ( bacterial_plastid_genetic_code ) \n  12.   The   Alternative   Yeast   Nuclear   Code   ( alternative_yeast_nuclear_genetic_code ) \n  13.   The   Ascidian   Mitochondrial   Code   ( ascidian_mitochondrial_genetic_code ) \n  14.   The   Alternative   Flatworm   Mitochondrial   Code   ( alternative_flatworm_mitochondrial_genetic_code ) \n  16.   Chlorophycean   Mitochondrial   Code   ( chlorophycean_mitochondrial_genetic_code ) \n  21.   Trematode   Mitochondrial   Code   ( trematode_mitochondrial_genetic_code ) \n  22.   Scenedesmus   obliquus   Mitochondrial   Code   ( scenedesmus_obliquus_mitochondrial_genetic_code ) \n  23.   Thraustochytrium   Mitochondrial   Code   ( thraustochytrium_mitochondrial_genetic_code ) \n  24.   Pterobranchia   Mitochondrial   Code   ( pterobrachia_mitochondrial_genetic_code ) \n  25.   Candidate   Division   SR1   and   Gracilibacteria   Code   ( candidate_division_sr1_genetic_code )   http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes", 
            "title": "Translation"
        }, 
        {
            "location": "/man/seq/#compact-representation", 
            "text": "As we saw above, DNA and RNA sequences can store any ambiguous nucleotides like 'N'.  If you are sure that nucleotide sequences store unambiguous nucleotides only, you can save the memory space of sequences.  DNAAlphabet{2}  is an alphabet that uses two bits per base and limits to only unambiguous nucleotide symbols (ACGT in DNA and ACGU in RNA). To create a sequence of this alphabet, you need to explicitly pass  DNAAlphabet{2}  to  BioSequence  as its parametric type:  julia   seq   =   BioSequence { DNAAlphabet { 2 }}( ACGT )  4 nt   DNA   Sequence :  ACGT   Recall that  DNASequence  is a type alias of  BioSequence{DNAAlphabet{4}} , which uses four bits per base. That is,  BioSequence{DNAAlphabet{2}}  saves half of memory footprint compared to  BioSequence{DNAAlphabet{4}} . If you need to handle reference sequences that are composed of five nucleotides, ACGTN, consider to use  ReferenceSequences.jl .  ReferenceSequence , exported from this package, compresses positions of 'N' and enables to handle long DNA sequences with the near space of two-bit encoding.", 
            "title": "Compact representation"
        }, 
        {
            "location": "/man/seq/#nucleotide-k-mers", 
            "text": "A common strategy to simplify the analysis of sequence data is to operate or short k-mers, for size fixed size  k . These can be packed into machine integers allowing extremely efficient code. The  Bio.Seq  module has built in support for representing short sequences in 64-bit integers. Besides being fixed length,  Kmer  types, unlike other sequence types cannot contain ambiguous symbols like 'N'.  The  Kmer{T,k}  type parameterized on alphabet ( T , either  DNANucleotide , or  RNANucleotide ) and size  k . A number of functions are provided for operating on  Kmers .  #  Bio.Seq.each     Function .  Initialize an iterator over all k-mers in a sequence.  Any k-mer containing an N will be skipped over.", 
            "title": "Nucleotide k-mers"
        }, 
        {
            "location": "/man/seq/#arguments_2", 
            "text": "t : Kmer type to enumerate.  seq : A NucleotideSequence  step : number of positions between iterated k-mers (default: 1)", 
            "title": "Arguments"
        }, 
        {
            "location": "/man/seq/#returns_2", 
            "text": "A EachKmerIterator constructed with these parameters", 
            "title": "Returns"
        }, 
        {
            "location": "/man/seq/#examples", 
            "text": "# iterate over codons\nfor (pos, codon) in each(DNAKmer{3}, dna ATCCTANAGNTACT , 3)\n    @show pos, codon\nend  #  Bio.Seq.KmerCounts     Type .  Count ocurrences of short ( = 32) k-mers in a sequence.  This method uses a dense table to store counts, requiring O(4^k) memory, so is not recommended for large k-mer sizes.", 
            "title": "Examples"
        }, 
        {
            "location": "/man/seq/#arguments_3", 
            "text": "'seq`: A NucleotideSequence  step : K-mers counted are separated by this many nucleotides (deafult: 1)   #  Bio.Seq.canonical     Function .  Canonical k-mer of  x  A canonical k-mer is the numerical lesser of a k-mer and its reverse complement. This is useful in hashing/counting k-mers in data that is not strand specific, and thus observing k-mer is equivalent to observing its reverse complement.  #  Bio.Seq.neighbors     Function .  Iterate through k-mers neighboring  x  on a de Bruijn graph.", 
            "title": "Arguments:"
        }, 
        {
            "location": "/man/seq/#sequence-records", 
            "text": "The  SeqRecord  type is used to represent a named sequence, optionally with accompanying metadata. It is defined as: sequence. It is as:  type  SeqRecord { S ,   T } \n     name :: String \n     seq :: S \n     metadata :: T  end   The type of the  metadata  field depends on the source of the sequence record. For example, if a record is read from a FASTA file, metadata contains the description field. If from a FASTQ file, a quality scores assigned to base calls during sequencing.", 
            "title": "Sequence records"
        }, 
        {
            "location": "/man/alignments/", 
            "text": "Align: Sequence Alignments\n\n\nThe \nAlign\n module contains tools for computing and working with sequence alignments.\n\n\n\n\nRepresenting alignments\n\n\nThe \nAlignment\n type can represent a wide variety of global or local sequence alignments while facilitating efficient coordinate transformation.  Alignment are always relative to a possibly unspecified reference sequence and represent a series of \nedit operations\n performed on that reference to transform it to the query sequence.\n\n\nTo represent an alignment we use a series of \"anchors\" stored in the \nAlignmentAnchor\n type. Anchors are form of run-length encoding alignment operations, but rather than store an operation along with a length, we store the end-point of that operation in both reference and query coordinates.\n\n\nimmutable\n \nAlignmentAnchor\n\n    \nseqpos\n::\nInt\n\n    \nrefpos\n::\nInt\n\n    \nop\n::\nOperation\n\n\nend\n\n\n\n\n\n\nEvery alignment starts with a special \nOP_START\n operation which is used to give the position in the reference and query prior to the start of the alignment, or 0, if the alignment starts at position 1.\n\n\nFor example, consider the following alignment:\n\n\n              0   4        9  12 15     19\n              |   |        |  |  |      |\n    query:     TGGC----ATCATTTAACG---CAAG\nreference: AGGGTGGCATTTATCAG---ACGTTTCGAGAC\n              |   |   |    |     |  |   |\n              4   8   12   17    20 23  27\n\n\n\n\n\nUsing anchors we would represent this as the following series of anchors:\n\n\n[\n\n    \nAlignmentAnchor\n(\n \n0\n,\n  \n4\n,\n \nOP_START\n),\n\n    \nAlignmentAnchor\n(\n \n4\n,\n  \n8\n,\n \nOP_MATCH\n),\n\n    \nAlignmentAnchor\n(\n \n4\n,\n \n12\n,\n \nOP_DELETE\n),\n\n    \nAlignmentAnchor\n(\n \n9\n,\n \n17\n,\n \nOP_MATCH\n),\n\n    \nAlignmentAnchor\n(\n12\n,\n \n17\n,\n \nOP_INSERT\n),\n\n    \nAlignmentAnchor\n(\n15\n,\n \n20\n,\n \nOP_MATCH\n),\n\n    \nAlignmentAnchor\n(\n15\n,\n \n23\n,\n \nOP_DELETE\n),\n\n    \nAlignmentAnchor\n(\n19\n,\n \n27\n,\n \nOP_MATCH\n)\n\n\n]\n\n\n\n\n\n\nAn \nAlignment\n object can be created from a series of anchors:\n\n\njulia\n \nAlignment\n([\n\n           \nAlignmentAnchor\n(\n0\n,\n \n4\n,\n \nOP_START\n),\n\n           \nAlignmentAnchor\n(\n4\n,\n \n8\n,\n \nOP_MATCH\n),\n\n           \nAlignmentAnchor\n(\n4\n,\n \n12\n,\n \nOP_DELETE\n)\n\n       \n])\n\n\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n\n\n\u00b7\u00b7\u00b7\u00b7\n----\n\n\n\n\n\n\n\n\nOperations\n\n\nAlignment operations follow closely from those used in the \nSAM/BAM format\n and are stored in the \nOperation\n bitstype.\n\n\n\n\n\n\n\n\nOperation\n\n\nOperation Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOP_MATCH\n\n\nmatch\n\n\nnon-specific match\n\n\n\n\n\n\nOP_INSERT\n\n\ninsert\n\n\ninsertion into reference sequence\n\n\n\n\n\n\nOP_DELETE\n\n\ndelete\n\n\ndeletion from reference sequence\n\n\n\n\n\n\nOP_SKIP\n\n\ndelete\n\n\n(typically long) deletion from the reference, e.g. due to RNA splicing\n\n\n\n\n\n\nOP_SOFT_CLIP\n\n\ninsert\n\n\nsequence removed from the beginning or end of the query sequence but stored\n\n\n\n\n\n\nOP_HARD_CLIP\n\n\ninsert\n\n\nsequence removed from the beginning or end of the query sequence and not stored\n\n\n\n\n\n\nOP_PAD\n\n\nspecial\n\n\nnot currently supported, but present for SAM/BAM compatibility\n\n\n\n\n\n\nOP_SEQ_MATCH\n\n\nmatch\n\n\nmatch operation with matching sequence positions\n\n\n\n\n\n\nOP_SEQ_MISMATCH\n\n\nmatch\n\n\nmatch operation with mismatching sequence positions\n\n\n\n\n\n\nOP_BACK\n\n\nspecial\n\n\nnot currently supported, but present for SAM/BAM compatibility\n\n\n\n\n\n\nOP_START\n\n\nspecial\n\n\nindicate the start of an alignment within the reference and query sequence\n\n\n\n\n\n\n\n\n\n\nAligned sequence\n\n\nA sequence aligned to another sequence is represented by the \nAlignedSequence\n type, which is a pair of the aligned sequence and an \nAlignment\n object.\n\n\nThe following example creates an aligned sequence object from a sequence and an alignment:\n\n\njulia\n \nAlignedSequence\n(\n  \n# pass an Alignment object\n\n           \ndna\nACGTAT\n,\n\n           \nAlignment\n([\n\n               \nAlignmentAnchor\n(\n0\n,\n \n0\n,\n \nOP_START\n),\n\n               \nAlignmentAnchor\n(\n3\n,\n \n3\n,\n \nOP_MATCH\n),\n\n               \nAlignmentAnchor\n(\n6\n,\n \n3\n,\n \nOP_INSERT\n)\n\n           \n])\n\n       \n)\n\n\n\u00b7\u00b7\u00b7\n---\n\n\nACGTAT\n\n\n\njulia\n \nAlignedSequence\n(\n  \n# or pass a vector of anchors\n\n           \ndna\nACGTAT\n,\n\n           \n[\n\n               \nAlignmentAnchor\n(\n0\n,\n \n0\n,\n \nOP_START\n),\n\n               \nAlignmentAnchor\n(\n3\n,\n \n3\n,\n \nOP_MATCH\n),\n\n               \nAlignmentAnchor\n(\n6\n,\n \n3\n,\n \nOP_INSERT\n)\n\n           \n]\n\n       \n)\n\n\n\u00b7\u00b7\u00b7\n---\n\n\nACGTAT\n\n\n\n\n\n\nIf you already have an aligned sequence with gap symbols, it can be converted to an \nAlignedSequence\n object by passing a reference sequence with it:\n\n\njulia\n \nseq\n \n=\n \ndna\nACGT--AAT--\n\n\n11\nnt\n \nDNA\n \nSequence\n:\n\n\nACGT\n--\nAAT\n--\n\n\n\njulia\n \nref\n \n=\n \ndna\nACGTTTAT-GG\n\n\n11\nnt\n \nDNA\n \nSequence\n:\n\n\nACGTTTAT\n-\nGG\n\n\n\njulia\n \nAlignedSequence\n(\nseq\n,\n \nref\n)\n\n\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n-\n\u00b7\u00b7\n\n\nACGT\n--\nAAT\n--\n\n\n\n\n\n\n\n\nOperating on alignments\n\n\n#\n\n\nBase.first\n \n \nFunction\n.\n\n\n..  first(coll)\n\n\nGet the first element of an iterable collection. Returns the start point of a \n:obj:\n`Range`\n\neven if it is empty.\n\n\n\n\n\nFirst position in the reference sequence.\n\n\n#\n\n\nBase.last\n \n \nFunction\n.\n\n\n..  last(coll)\n\n\nGet the last element of an ordered collection, if it can be computed in O(1) time.\nThis is accomplished by calling \n:func:\n`endof`\n to get the last index.\nReturns the end point of a \n:obj:\n`Range`\n even if it is empty.\n\n\n\n\n\nLast position in the reference sequence.\n\n\n#\n\n\nBio.Align.seq2ref\n \n \nFunction\n.\n\n\nseq2ref(i, aln)\n\n\n\n\n\nMap a position from sequence to reference.\n\n\n#\n\n\nBio.Align.ref2seq\n \n \nFunction\n.\n\n\nref2seq(i, aln)\n\n\n\n\n\nMap a position from reference to sequence.\n\n\n#\n\n\nBio.Align.cigar\n \n \nFunction\n.\n\n\nOutput a CIGAR string encoding of an \nAlignment\n. This is not entirely lossless as it discards the alignments start positions.\n\n\n\n\nPairwise alignment\n\n\nPairwise alignment is a sequence alignment between two sequences.  The \nBio.Align\n module implements several pairwise alignment methods that maximize alignment score or minimize alignment cost.\n\n\nA pair of optimization type and score (or cost) model determines the best alignments between two sequences. The next example uses a pair of \nGlobalAlignment\n and \nAffineGapScoreModel\n to obtain the best alignment:\n\n\njulia\n \nproblem\n \n=\n \nGlobalAlignment\n()\n\n\nBio\n.\nAlign\n.\nGlobalAlignment\n()\n\n\n\njulia\n \nscoremodel\n \n=\n \nAffineGapScoreModel\n(\n\n                  \nmatch\n=\n5\n,\n\n                  \nmismatch\n=-\n4\n,\n\n                  \ngap_open\n=-\n4\n,\n\n                  \ngap_extend\n=-\n1\n\n              \n)\n\n\nBio\n.\nAlign\n.\nAffineGapScoreModel\n{\nInt64\n}:\n\n       \nmatch\n \n=\n \n5\n\n    \nmismatch\n \n=\n \n-\n4\n\n    \ngap_open\n \n=\n \n-\n4\n\n  \ngap_extend\n \n=\n \n-\n1\n\n\n\njulia\n \npairalign\n(\nproblem\n,\n \ndna\nCGGATTA\n,\n \ndna\nGGTTTAC\n,\n \nscoremodel\n)\n\n\nBio\n.\nAlign\n.\nPairwiseAlignmentResult\n{\nInt64\n,\nBio\n.\nSeq\n.\nBioSequence\n{\nBio\n.\nSeq\n.\nDNAAlphabet\n{\n4\n}},\nBio\n.\nSeq\n.\nBioSequence\n{\nBio\n.\nSeq\n.\nDNAAlphabet\n{\n4\n}}}:\n\n  \nscore\n:\n \n11\n\n  \nseq\n:\n \n1\n \nCGGATTA\n-\n \n7\n\n          \n||\n \n|||\n\n  \nref\n:\n \n0\n \n-\nGGTTTAC\n \n7\n\n\n\n\n\n\npairalign\n takes an alignment type as its first argument, then two sequences to align, and score (or cost) model. Alignment type is one of the following four types:\n\n\n\n\nGlobalAlignment\n: global-to-global alignment\n\n\nSemiGlobalAlignment\n: local-to-global alignment\n\n\nLocalAlignment\n: local-to-local alignment\n\n\nOverlapAlignment\n: end-free alignment\n\n\n\n\nFor scoring model, \nAffineGapScoreModel\n is currently supported. It imposes an \naffine gap penalty\n for insertions and deletions: \ngap_open + k * gap_extend\n for a consecutive insertion/deletion of length \nk\n. The affine gap penalty is flexible enough to create a constant and linear scoring model. Setting \ngap_extend = 0\n or \ngap_open = 0\n, they are equivalent to the constant or linear gap penalty, respectively. The first argument of \nAffineGapScoreModel\n can be a substitution matrix like \nAffineGapScoreModel(BLOSUM62, gap_open=-10, gap_extend=-1)\n. For details on substitution matrices, see the \nSubstitution matrices\n section.\n\n\nAlignment type can also be a distance of two sequences:\n\n\n\n\nEditDistance\n\n\nLevenshteinDistance\n\n\nHammingDistance\n\n\n\n\nIn this alignment, \nCostModel\n is used instead of \nAffineGapScoreModel\n to define cost of substitution, insertion, and deletion:\n\n\njulia\n \ncostmodel\n \n=\n \nCostModel\n(\nmatch\n=\n0\n,\n \nmismatch\n=\n1\n,\n \ninsertion\n=\n1\n,\n \ndeletion\n=\n1\n);\n\n\n\njulia\n \npairalign\n(\nEditDistance\n(),\n \nabcd\n,\n \nadcde\n,\n \ncostmodel\n)\n\n\nBio\n.\nAlign\n.\nPairwiseAlignmentResult\n{\nInt64\n,\nASCIIString\n,\nASCIIString\n}:\n\n  \ndistance\n:\n \n2\n\n  \nseq\n:\n \n1\n \nabcd\n-\n \n4\n\n         \n|\n \n||\n\n  \nref\n:\n \n1\n \nadcde\n \n5\n\n\n\n\n\n\n\n\nOperations on pairwise alignment\n\n\npairalign\n returns a \nPairwiseAlignmentResult\n object and some accessors are provided for it.\n\n\n#\n\n\nBio.Align.score\n \n \nFunction\n.\n\n\nscore(alignment_result)\n\n\n\n\n\nReturn score of alignment.\n\n\n#\n\n\nBio.Align.distance\n \n \nFunction\n.\n\n\ndistance(alignment_result)\n\n\n\n\n\nRetrun distance of alignment.\n\n\n#\n\n\nBio.Align.hasalignment\n \n \nFunction\n.\n\n\nhasalignment(alignment_result)\n\n\n\n\n\nCheck if alignment is stored or not.\n\n\n#\n\n\nBio.Align.alignment\n \n \nFunction\n.\n\n\nalignment(alignment_result)\n\n\n\n\n\nReturn alignment if any.\n\n\nSee also: \nhasalignment\n\n\nPairwise alignment also implements some useful operations on it.\n\n\n#\n\n\nBio.Align.count_matches\n \n \nFunction\n.\n\n\ncount_matches(aln)\n\n\n\n\n\nCount the number of matching positions.\n\n\n#\n\n\nBio.Align.count_mismatches\n \n \nFunction\n.\n\n\ncount_mismatches(aln)\n\n\n\n\n\nCount the number of mismatching positions.\n\n\n#\n\n\nBio.Align.count_insertions\n \n \nFunction\n.\n\n\ncount_insertions(aln)\n\n\n\n\n\nCount the number of inserting positions.\n\n\n#\n\n\nBio.Align.count_deletions\n \n \nFunction\n.\n\n\ncount_deletions(aln)\n\n\n\n\n\nCount the number of deleting positions.\n\n\n#\n\n\nBio.Align.count_aligned\n \n \nFunction\n.\n\n\ncount_aligned(aln)\n\n\n\n\n\nCount the number of aligned positions.\n\n\nThe example below shows a use case of these operations:\n\n\njulia\n \ns1\n \n=\n \ndna\nCCTAGGAGGG\n;\n\n\n\njulia\n \ns2\n \n=\n \ndna\nACCTGGTATGATAGCG\n;\n\n\n\njulia\n \nscoremodel\n \n=\n \nAffineGapScoreModel\n(\nEDNAFULL\n,\n \ngap_open\n=-\n5\n,\n \ngap_extend\n=-\n1\n);\n\n\n\njulia\n \nres\n \n=\n \npairalign\n(\nGlobalAlignment\n(),\n \ns1\n,\n \ns2\n,\n \nscoremodel\n)\n  \n# run pairwise alignment\n\n\nBio\n.\nAlign\n.\nPairwiseAlignmentResult\n{\nInt64\n,\nBio\n.\nSeq\n.\nBioSequence\n{\nBio\n.\nSeq\n.\nDNAAlphabet\n{\n4\n}},\nBio\n.\nSeq\n.\nBioSequence\n{\nBio\n.\nSeq\n.\nDNAAlphabet\n{\n4\n}}}:\n\n  \nscore\n:\n \n13\n\n  \nseq\n:\n  \n0\n \n-\nCCTAGG\n------\nAGGG\n \n10\n\n           \n|||\n \n||\n      \n||\n \n|\n\n  \nref\n:\n  \n1\n \nACCT\n-\nGGTATGATAGCG\n \n16\n\n\n\n\njulia\n \nscore\n(\nres\n)\n  \n# get the achieved score of this alignment\n\n\n13\n\n\n\njulia\n \naln\n \n=\n \nalignment\n(\nres\n)\n\n\nPairwiseAlignment\n{\nBio\n.\nSeq\n.\nBioSequence\n{\nBio\n.\nSeq\n.\nDNAAlphabet\n{\n4\n}},\nBio\n.\nSeq\n.\nBioSequence\n{\nBio\n.\nSeq\n.\nDNAAlphabet\n{\n4\n}}}:\n\n  \nseq\n:\n  \n0\n \n-\nCCTAGG\n------\nAGGG\n \n10\n\n           \n|||\n \n||\n      \n||\n \n|\n\n  \nref\n:\n  \n1\n \nACCT\n-\nGGTATGATAGCG\n \n16\n\n\n\n\njulia\n \ncount_matches\n(\naln\n)\n\n\n8\n\n\n\njulia\n \ncount_mismatches\n(\naln\n)\n\n\n1\n\n\n\njulia\n \ncount_insertions\n(\naln\n)\n\n\n1\n\n\n\njulia\n \ncount_deletions\n(\naln\n)\n\n\n7\n\n\n\njulia\n \ncount_aligned\n(\naln\n)\n\n\n17\n\n\n\njulia\n \ncollect\n(\naln\n)\n  \n# pairwise alignment is iterable\n\n\n17\n-\nelement\n \nArray\n{\nTuple\n{\nBio\n.\nSeq\n.\nDNANucleotide\n,\nBio\n.\nSeq\n.\nDNANucleotide\n},\n1\n}:\n\n \n(\n-\n,\nA\n)\n\n \n(\nC\n,\nC\n)\n\n \n(\nC\n,\nC\n)\n\n \n(\nT\n,\nT\n)\n\n \n(\nA\n,\n-\n)\n\n \n(\nG\n,\nG\n)\n\n \n(\nG\n,\nG\n)\n\n \n(\n-\n,\nT\n)\n\n \n(\n-\n,\nA\n)\n\n \n(\n-\n,\nT\n)\n\n \n(\n-\n,\nG\n)\n\n \n(\n-\n,\nA\n)\n\n \n(\n-\n,\nT\n)\n\n \n(\nA\n,\nA\n)\n\n \n(\nG\n,\nG\n)\n\n \n(\nG\n,\nC\n)\n\n \n(\nG\n,\nG\n)\n\n\n\njulia\n \nDNASequence\n([\nx\n \nfor\n \n(\nx\n,\n \n_\n)\n \nin\n \naln\n])\n  \n# create aligned `s1` with gaps\n\n\n17\nnt\n \nDNA\n \nSequence\n:\n\n\n-\nCCTAGG\n------\nAGGG\n\n\n\njulia\n \nDNASequence\n([\ny\n \nfor\n \n(\n_\n,\n \ny\n)\n \nin\n \naln\n])\n  \n# create aligned `s2` with gaps\n\n\n17\nnt\n \nDNA\n \nSequence\n:\n\n\nACCT\n-\nGGTATGATAGCG\n\n\n\n\n\n\n\n\nSubstitution matrices\n\n\nA substitution matrix is a function of substitution score (or cost) from one symbol to other. Substitution value of \nsubmat\n from \nx\n to \ny\n can be obtained by writing \nsubmat[x,y]\n. In \nBio.Align\n, \nSubstitutionMatrix\n and \nDichotomousSubstitutionMatrix\n are two distinct types representing substitution matrices.\n\n\nSubstitutionMatrix\n is a general substitution matrix type that is a thin wrapper of regular matrix.\n\n\nSome common substitution matrices are provided. For DNA and RNA, \nEDNAFULL\n is defined:\n\n\njulia\n \nEDNAFULL\n\n\nBio\n.\nAlign\n.\nSubstitutionMatrix\n{\nBio\n.\nSeq\n.\nDNANucleotide\n,\nInt64\n}:\n\n     \nA\n  \nC\n  \nG\n  \nT\n  \nM\n  \nR\n  \nW\n  \nS\n  \nY\n  \nK\n  \nV\n  \nH\n  \nD\n  \nB\n  \nN\n\n  \nA\n  \n5\n \n-\n4\n \n-\n4\n \n-\n4\n  \n1\n  \n1\n  \n1\n \n-\n4\n \n-\n4\n \n-\n4\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n4\n \n-\n2\n\n  \nC\n \n-\n4\n  \n5\n \n-\n4\n \n-\n4\n  \n1\n \n-\n4\n \n-\n4\n  \n1\n  \n1\n \n-\n4\n \n-\n1\n \n-\n1\n \n-\n4\n \n-\n1\n \n-\n2\n\n  \nG\n \n-\n4\n \n-\n4\n  \n5\n \n-\n4\n \n-\n4\n  \n1\n \n-\n4\n  \n1\n \n-\n4\n  \n1\n \n-\n1\n \n-\n4\n \n-\n1\n \n-\n1\n \n-\n2\n\n  \nT\n \n-\n4\n \n-\n4\n \n-\n4\n  \n5\n \n-\n4\n \n-\n4\n  \n1\n \n-\n4\n  \n1\n  \n1\n \n-\n4\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n2\n\n  \nM\n  \n1\n  \n1\n \n-\n4\n \n-\n4\n \n-\n1\n \n-\n2\n \n-\n2\n \n-\n2\n \n-\n2\n \n-\n4\n \n-\n1\n \n-\n1\n \n-\n3\n \n-\n3\n \n-\n1\n\n  \nR\n  \n1\n \n-\n4\n  \n1\n \n-\n4\n \n-\n2\n \n-\n1\n \n-\n2\n \n-\n2\n \n-\n4\n \n-\n2\n \n-\n1\n \n-\n3\n \n-\n1\n \n-\n3\n \n-\n1\n\n  \nW\n  \n1\n \n-\n4\n \n-\n4\n  \n1\n \n-\n2\n \n-\n2\n \n-\n1\n \n-\n4\n \n-\n2\n \n-\n2\n \n-\n3\n \n-\n1\n \n-\n1\n \n-\n3\n \n-\n1\n\n  \nS\n \n-\n4\n  \n1\n  \n1\n \n-\n4\n \n-\n2\n \n-\n2\n \n-\n4\n \n-\n1\n \n-\n2\n \n-\n2\n \n-\n1\n \n-\n3\n \n-\n3\n \n-\n1\n \n-\n1\n\n  \nY\n \n-\n4\n  \n1\n \n-\n4\n  \n1\n \n-\n2\n \n-\n4\n \n-\n2\n \n-\n2\n \n-\n1\n \n-\n2\n \n-\n3\n \n-\n1\n \n-\n3\n \n-\n1\n \n-\n1\n\n  \nK\n \n-\n4\n \n-\n4\n  \n1\n  \n1\n \n-\n4\n \n-\n2\n \n-\n2\n \n-\n2\n \n-\n2\n \n-\n1\n \n-\n3\n \n-\n3\n \n-\n1\n \n-\n1\n \n-\n1\n\n  \nV\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n4\n \n-\n1\n \n-\n1\n \n-\n3\n \n-\n1\n \n-\n3\n \n-\n3\n \n-\n1\n \n-\n2\n \n-\n2\n \n-\n2\n \n-\n1\n\n  \nH\n \n-\n1\n \n-\n1\n \n-\n4\n \n-\n1\n \n-\n1\n \n-\n3\n \n-\n1\n \n-\n3\n \n-\n1\n \n-\n3\n \n-\n2\n \n-\n1\n \n-\n2\n \n-\n2\n \n-\n1\n\n  \nD\n \n-\n1\n \n-\n4\n \n-\n1\n \n-\n1\n \n-\n3\n \n-\n1\n \n-\n1\n \n-\n3\n \n-\n3\n \n-\n1\n \n-\n2\n \n-\n2\n \n-\n1\n \n-\n2\n \n-\n1\n\n  \nB\n \n-\n4\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n3\n \n-\n3\n \n-\n3\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n2\n \n-\n2\n \n-\n2\n \n-\n1\n \n-\n1\n\n  \nN\n \n-\n2\n \n-\n2\n \n-\n2\n \n-\n2\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n1\n\n\n(\nunderlined\n \nvalues\n \nare\n \ndefault\n \nones\n)\n\n\n\n\n\n\nFor amino acids, PAM (Point Accepted Mutation) and BLOSUM (BLOcks SUbstitution Matrix) matrices are defined:\n\n\njulia\n \nBLOSUM62\n\n\nBio\n.\nAlign\n.\nSubstitutionMatrix\n{\nBio\n.\nSeq\n.\nAminoAcid\n,\nInt64\n}:\n\n     \nA\n  \nR\n  \nN\n  \nD\n  \nC\n  \nQ\n  \nE\n  \nG\n  \nH\n  \nI\n  \nL\n  \nK\n  \nM\n  \nF\n  \nP\n  \nS\n  \nT\n  \nW\n  \nY\n  \nV\n  \nO\n  \nU\n  \nB\n  \nJ\n  \nZ\n  \nX\n  \n*\n\n  \nA\n  \n4\n \n-\n1\n \n-\n2\n \n-\n2\n  \n0\n \n-\n1\n \n-\n1\n  \n0\n \n-\n2\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n2\n \n-\n1\n  \n1\n  \n0\n \n-\n3\n \n-\n2\n  \n0\n  \n0\n\u0332\n  \n0\n\u0332\n \n-\n2\n  \n0\n\u0332\n \n-\n1\n  \n0\n \n-\n4\n\n  \nR\n \n-\n1\n  \n5\n  \n0\n \n-\n2\n \n-\n3\n  \n1\n  \n0\n \n-\n2\n  \n0\n \n-\n3\n \n-\n2\n  \n2\n \n-\n1\n \n-\n3\n \n-\n2\n \n-\n1\n \n-\n1\n \n-\n3\n \n-\n2\n \n-\n3\n  \n0\n\u0332\n  \n0\n\u0332\n \n-\n1\n  \n0\n\u0332\n  \n0\n \n-\n1\n \n-\n4\n\n  \nN\n \n-\n2\n  \n0\n  \n6\n  \n1\n \n-\n3\n  \n0\n  \n0\n  \n0\n  \n1\n \n-\n3\n \n-\n3\n  \n0\n \n-\n2\n \n-\n3\n \n-\n2\n  \n1\n  \n0\n \n-\n4\n \n-\n2\n \n-\n3\n  \n0\n\u0332\n  \n0\n\u0332\n  \n3\n  \n0\n\u0332\n  \n0\n \n-\n1\n \n-\n4\n\n  \nD\n \n-\n2\n \n-\n2\n  \n1\n  \n6\n \n-\n3\n  \n0\n  \n2\n \n-\n1\n \n-\n1\n \n-\n3\n \n-\n4\n \n-\n1\n \n-\n3\n \n-\n3\n \n-\n1\n  \n0\n \n-\n1\n \n-\n4\n \n-\n3\n \n-\n3\n  \n0\n\u0332\n  \n0\n\u0332\n  \n4\n  \n0\n\u0332\n  \n1\n \n-\n1\n \n-\n4\n\n  \nC\n  \n0\n \n-\n3\n \n-\n3\n \n-\n3\n  \n9\n \n-\n3\n \n-\n4\n \n-\n3\n \n-\n3\n \n-\n1\n \n-\n1\n \n-\n3\n \n-\n1\n \n-\n2\n \n-\n3\n \n-\n1\n \n-\n1\n \n-\n2\n \n-\n2\n \n-\n1\n  \n0\n\u0332\n  \n0\n\u0332\n \n-\n3\n  \n0\n\u0332\n \n-\n3\n \n-\n2\n \n-\n4\n\n  \nQ\n \n-\n1\n  \n1\n  \n0\n  \n0\n \n-\n3\n  \n5\n  \n2\n \n-\n2\n  \n0\n \n-\n3\n \n-\n2\n  \n1\n  \n0\n \n-\n3\n \n-\n1\n  \n0\n \n-\n1\n \n-\n2\n \n-\n1\n \n-\n2\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n  \n0\n\u0332\n  \n3\n \n-\n1\n \n-\n4\n\n  \nE\n \n-\n1\n  \n0\n  \n0\n  \n2\n \n-\n4\n  \n2\n  \n5\n \n-\n2\n  \n0\n \n-\n3\n \n-\n3\n  \n1\n \n-\n2\n \n-\n3\n \n-\n1\n  \n0\n \n-\n1\n \n-\n3\n \n-\n2\n \n-\n2\n  \n0\n\u0332\n  \n0\n\u0332\n  \n1\n  \n0\n\u0332\n  \n4\n \n-\n1\n \n-\n4\n\n  \nG\n  \n0\n \n-\n2\n  \n0\n \n-\n1\n \n-\n3\n \n-\n2\n \n-\n2\n  \n6\n \n-\n2\n \n-\n4\n \n-\n4\n \n-\n2\n \n-\n3\n \n-\n3\n \n-\n2\n  \n0\n \n-\n2\n \n-\n2\n \n-\n3\n \n-\n3\n  \n0\n\u0332\n  \n0\n\u0332\n \n-\n1\n  \n0\n\u0332\n \n-\n2\n \n-\n1\n \n-\n4\n\n  \nH\n \n-\n2\n  \n0\n  \n1\n \n-\n1\n \n-\n3\n  \n0\n  \n0\n \n-\n2\n  \n8\n \n-\n3\n \n-\n3\n \n-\n1\n \n-\n2\n \n-\n1\n \n-\n2\n \n-\n1\n \n-\n2\n \n-\n2\n  \n2\n \n-\n3\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n  \n0\n\u0332\n  \n0\n \n-\n1\n \n-\n4\n\n  \nI\n \n-\n1\n \n-\n3\n \n-\n3\n \n-\n3\n \n-\n1\n \n-\n3\n \n-\n3\n \n-\n4\n \n-\n3\n  \n4\n  \n2\n \n-\n3\n  \n1\n  \n0\n \n-\n3\n \n-\n2\n \n-\n1\n \n-\n3\n \n-\n1\n  \n3\n  \n0\n\u0332\n  \n0\n\u0332\n \n-\n3\n  \n0\n\u0332\n \n-\n3\n \n-\n1\n \n-\n4\n\n  \nL\n \n-\n1\n \n-\n2\n \n-\n3\n \n-\n4\n \n-\n1\n \n-\n2\n \n-\n3\n \n-\n4\n \n-\n3\n  \n2\n  \n4\n \n-\n2\n  \n2\n  \n0\n \n-\n3\n \n-\n2\n \n-\n1\n \n-\n2\n \n-\n1\n  \n1\n  \n0\n\u0332\n  \n0\n\u0332\n \n-\n4\n  \n0\n\u0332\n \n-\n3\n \n-\n1\n \n-\n4\n\n  \nK\n \n-\n1\n  \n2\n  \n0\n \n-\n1\n \n-\n3\n  \n1\n  \n1\n \n-\n2\n \n-\n1\n \n-\n3\n \n-\n2\n  \n5\n \n-\n1\n \n-\n3\n \n-\n1\n  \n0\n \n-\n1\n \n-\n3\n \n-\n2\n \n-\n2\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n  \n0\n\u0332\n  \n1\n \n-\n1\n \n-\n4\n\n  \nM\n \n-\n1\n \n-\n1\n \n-\n2\n \n-\n3\n \n-\n1\n  \n0\n \n-\n2\n \n-\n3\n \n-\n2\n  \n1\n  \n2\n \n-\n1\n  \n5\n  \n0\n \n-\n2\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n1\n  \n1\n  \n0\n\u0332\n  \n0\n\u0332\n \n-\n3\n  \n0\n\u0332\n \n-\n1\n \n-\n1\n \n-\n4\n\n  \nF\n \n-\n2\n \n-\n3\n \n-\n3\n \n-\n3\n \n-\n2\n \n-\n3\n \n-\n3\n \n-\n3\n \n-\n1\n  \n0\n  \n0\n \n-\n3\n  \n0\n  \n6\n \n-\n4\n \n-\n2\n \n-\n2\n  \n1\n  \n3\n \n-\n1\n  \n0\n\u0332\n  \n0\n\u0332\n \n-\n3\n  \n0\n\u0332\n \n-\n3\n \n-\n1\n \n-\n4\n\n  \nP\n \n-\n1\n \n-\n2\n \n-\n2\n \n-\n1\n \n-\n3\n \n-\n1\n \n-\n1\n \n-\n2\n \n-\n2\n \n-\n3\n \n-\n3\n \n-\n1\n \n-\n2\n \n-\n4\n  \n7\n \n-\n1\n \n-\n1\n \n-\n4\n \n-\n3\n \n-\n2\n  \n0\n\u0332\n  \n0\n\u0332\n \n-\n2\n  \n0\n\u0332\n \n-\n1\n \n-\n2\n \n-\n4\n\n  \nS\n  \n1\n \n-\n1\n  \n1\n  \n0\n \n-\n1\n  \n0\n  \n0\n  \n0\n \n-\n1\n \n-\n2\n \n-\n2\n  \n0\n \n-\n1\n \n-\n2\n \n-\n1\n  \n4\n  \n1\n \n-\n3\n \n-\n2\n \n-\n2\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n  \n0\n\u0332\n  \n0\n  \n0\n \n-\n4\n\n  \nT\n  \n0\n \n-\n1\n  \n0\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n2\n \n-\n2\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n2\n \n-\n1\n  \n1\n  \n5\n \n-\n2\n \n-\n2\n  \n0\n  \n0\n\u0332\n  \n0\n\u0332\n \n-\n1\n  \n0\n\u0332\n \n-\n1\n  \n0\n \n-\n4\n\n  \nW\n \n-\n3\n \n-\n3\n \n-\n4\n \n-\n4\n \n-\n2\n \n-\n2\n \n-\n3\n \n-\n2\n \n-\n2\n \n-\n3\n \n-\n2\n \n-\n3\n \n-\n1\n  \n1\n \n-\n4\n \n-\n3\n \n-\n2\n \n11\n  \n2\n \n-\n3\n  \n0\n\u0332\n  \n0\n\u0332\n \n-\n4\n  \n0\n\u0332\n \n-\n3\n \n-\n2\n \n-\n4\n\n  \nY\n \n-\n2\n \n-\n2\n \n-\n2\n \n-\n3\n \n-\n2\n \n-\n1\n \n-\n2\n \n-\n3\n  \n2\n \n-\n1\n \n-\n1\n \n-\n2\n \n-\n1\n  \n3\n \n-\n3\n \n-\n2\n \n-\n2\n  \n2\n  \n7\n \n-\n1\n  \n0\n\u0332\n  \n0\n\u0332\n \n-\n3\n  \n0\n\u0332\n \n-\n2\n \n-\n1\n \n-\n4\n\n  \nV\n  \n0\n \n-\n3\n \n-\n3\n \n-\n3\n \n-\n1\n \n-\n2\n \n-\n2\n \n-\n3\n \n-\n3\n  \n3\n  \n1\n \n-\n2\n  \n1\n \n-\n1\n \n-\n2\n \n-\n2\n  \n0\n \n-\n3\n \n-\n1\n  \n4\n  \n0\n\u0332\n  \n0\n\u0332\n \n-\n3\n  \n0\n\u0332\n \n-\n2\n \n-\n1\n \n-\n4\n\n  \nO\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n\n  \nU\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n\n  \nB\n \n-\n2\n \n-\n1\n  \n3\n  \n4\n \n-\n3\n  \n0\n  \n1\n \n-\n1\n  \n0\n \n-\n3\n \n-\n4\n  \n0\n \n-\n3\n \n-\n3\n \n-\n2\n  \n0\n \n-\n1\n \n-\n4\n \n-\n3\n \n-\n3\n  \n0\n\u0332\n  \n0\n\u0332\n  \n4\n  \n0\n\u0332\n  \n1\n \n-\n1\n \n-\n4\n\n  \nJ\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n  \n0\n\u0332\n\n  \nZ\n \n-\n1\n  \n0\n  \n0\n  \n1\n \n-\n3\n  \n3\n  \n4\n \n-\n2\n  \n0\n \n-\n3\n \n-\n3\n  \n1\n \n-\n1\n \n-\n3\n \n-\n1\n  \n0\n \n-\n1\n \n-\n3\n \n-\n2\n \n-\n2\n  \n0\n\u0332\n  \n0\n\u0332\n  \n1\n  \n0\n\u0332\n  \n4\n \n-\n1\n \n-\n4\n\n  \nX\n  \n0\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n2\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n1\n \n-\n2\n  \n0\n  \n0\n \n-\n2\n \n-\n1\n \n-\n1\n  \n0\n\u0332\n  \n0\n\u0332\n \n-\n1\n  \n0\n\u0332\n \n-\n1\n \n-\n1\n \n-\n4\n\n  \n*\n \n-\n4\n \n-\n4\n \n-\n4\n \n-\n4\n \n-\n4\n \n-\n4\n \n-\n4\n \n-\n4\n \n-\n4\n \n-\n4\n \n-\n4\n \n-\n4\n \n-\n4\n \n-\n4\n \n-\n4\n \n-\n4\n \n-\n4\n \n-\n4\n \n-\n4\n \n-\n4\n  \n0\n\u0332\n  \n0\n\u0332\n \n-\n4\n  \n0\n\u0332\n \n-\n4\n \n-\n4\n  \n1\n\n\n(\nunderlined\n \nvalues\n \nare\n \ndefault\n \nones\n)\n\n\n\n\n\n\n\n\n\n\n\n\nMatrix\n\n\nConstants\n\n\n\n\n\n\n\n\n\n\nPAM\n\n\nPAM30\n, \nPAM70\n, \nPAM250\n\n\n\n\n\n\nBLOSUM\n\n\nBLOSUM45\n, \nBLOSUM50\n, \nBLOSUM62\n, \nBLOSUM80\n, \nBLOSUM90\n\n\n\n\n\n\n\n\nThese matrices are downloaded from: \nftp://ftp.ncbi.nih.gov/blast/matrices/\n.\n\n\nSubstitutionMatrix\n can be modified like a regular matrix:\n\n\njulia\n \nmysubmat\n \n=\n \ncopy\n(\nBLOSUM62\n);\n  \n# create a copy\n\n\n\njulia\n \nmysubmat\n[\nAA_A\n,\nAA_R\n]\n  \n# score of AA_A =\n AA_R substitution is -1\n\n\n-\n1\n\n\n\njulia\n \nmysubmat\n[\nAA_A\n,\nAA_R\n]\n \n=\n \n-\n3\n  \n# set the score to -3\n\n\n-\n3\n\n\n\njulia\n \nmysubmat\n[\nAA_A\n,\nAA_R\n]\n  \n# the score is modified\n\n\n-\n3\n\n\n\n\n\n\nMake sure to create a copy of the original matrix when you create a matrix from a predefined matrix. In the above case, \nBLOSUM62\n is shared in the whole program and modification on it will affect any result that uses \nBLOSUM62\n.\n\n\nDichotomousSubstitutionMatrix\n is a specialized matrix for matching or mismatching substitution.  This is a preferable choice when performance is more important than flexibility because looking up score is faster than \nSubstitutionMatrix\n.\n\n\njulia\n \nsubmat\n \n=\n \nDichotomousSubstitutionMatrix\n(\n1\n,\n \n-\n1\n)\n\n\nBio\n.\nAlign\n.\nDichotomousSubstitutionMatrix\n{\nInt64\n}:\n\n     \nmatch\n \n=\n  \n1\n\n  \nmismatch\n \n=\n \n-\n1\n\n\n\njulia\n \nsubmat\n[\nA\n,\nA\n]\n  \n# match\n\n\n1\n\n\n\njulia\n \nsubmat\n[\nA\n,\nB\n]\n  \n# mismatch\n\n\n-\n1", 
            "title": "Alignments"
        }, 
        {
            "location": "/man/alignments/#align-sequence-alignments", 
            "text": "The  Align  module contains tools for computing and working with sequence alignments.", 
            "title": "Align: Sequence Alignments"
        }, 
        {
            "location": "/man/alignments/#representing-alignments", 
            "text": "The  Alignment  type can represent a wide variety of global or local sequence alignments while facilitating efficient coordinate transformation.  Alignment are always relative to a possibly unspecified reference sequence and represent a series of  edit operations  performed on that reference to transform it to the query sequence.  To represent an alignment we use a series of \"anchors\" stored in the  AlignmentAnchor  type. Anchors are form of run-length encoding alignment operations, but rather than store an operation along with a length, we store the end-point of that operation in both reference and query coordinates.  immutable   AlignmentAnchor \n     seqpos :: Int \n     refpos :: Int \n     op :: Operation  end   Every alignment starts with a special  OP_START  operation which is used to give the position in the reference and query prior to the start of the alignment, or 0, if the alignment starts at position 1.  For example, consider the following alignment:                0   4        9  12 15     19\n              |   |        |  |  |      |\n    query:     TGGC----ATCATTTAACG---CAAG\nreference: AGGGTGGCATTTATCAG---ACGTTTCGAGAC\n              |   |   |    |     |  |   |\n              4   8   12   17    20 23  27  Using anchors we would represent this as the following series of anchors:  [ \n     AlignmentAnchor (   0 ,    4 ,   OP_START ), \n     AlignmentAnchor (   4 ,    8 ,   OP_MATCH ), \n     AlignmentAnchor (   4 ,   12 ,   OP_DELETE ), \n     AlignmentAnchor (   9 ,   17 ,   OP_MATCH ), \n     AlignmentAnchor ( 12 ,   17 ,   OP_INSERT ), \n     AlignmentAnchor ( 15 ,   20 ,   OP_MATCH ), \n     AlignmentAnchor ( 15 ,   23 ,   OP_DELETE ), \n     AlignmentAnchor ( 19 ,   27 ,   OP_MATCH )  ]   An  Alignment  object can be created from a series of anchors:  julia   Alignment ([ \n            AlignmentAnchor ( 0 ,   4 ,   OP_START ), \n            AlignmentAnchor ( 4 ,   8 ,   OP_MATCH ), \n            AlignmentAnchor ( 4 ,   12 ,   OP_DELETE ) \n        ])  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  \u00b7\u00b7\u00b7\u00b7 ----", 
            "title": "Representing alignments"
        }, 
        {
            "location": "/man/alignments/#operations", 
            "text": "Alignment operations follow closely from those used in the  SAM/BAM format  and are stored in the  Operation  bitstype.     Operation  Operation Type  Description      OP_MATCH  match  non-specific match    OP_INSERT  insert  insertion into reference sequence    OP_DELETE  delete  deletion from reference sequence    OP_SKIP  delete  (typically long) deletion from the reference, e.g. due to RNA splicing    OP_SOFT_CLIP  insert  sequence removed from the beginning or end of the query sequence but stored    OP_HARD_CLIP  insert  sequence removed from the beginning or end of the query sequence and not stored    OP_PAD  special  not currently supported, but present for SAM/BAM compatibility    OP_SEQ_MATCH  match  match operation with matching sequence positions    OP_SEQ_MISMATCH  match  match operation with mismatching sequence positions    OP_BACK  special  not currently supported, but present for SAM/BAM compatibility    OP_START  special  indicate the start of an alignment within the reference and query sequence", 
            "title": "Operations"
        }, 
        {
            "location": "/man/alignments/#aligned-sequence", 
            "text": "A sequence aligned to another sequence is represented by the  AlignedSequence  type, which is a pair of the aligned sequence and an  Alignment  object.  The following example creates an aligned sequence object from a sequence and an alignment:  julia   AlignedSequence (    # pass an Alignment object \n            dna ACGTAT , \n            Alignment ([ \n                AlignmentAnchor ( 0 ,   0 ,   OP_START ), \n                AlignmentAnchor ( 3 ,   3 ,   OP_MATCH ), \n                AlignmentAnchor ( 6 ,   3 ,   OP_INSERT ) \n            ]) \n        )  \u00b7\u00b7\u00b7 ---  ACGTAT  julia   AlignedSequence (    # or pass a vector of anchors \n            dna ACGTAT , \n            [ \n                AlignmentAnchor ( 0 ,   0 ,   OP_START ), \n                AlignmentAnchor ( 3 ,   3 ,   OP_MATCH ), \n                AlignmentAnchor ( 6 ,   3 ,   OP_INSERT ) \n            ] \n        )  \u00b7\u00b7\u00b7 ---  ACGTAT   If you already have an aligned sequence with gap symbols, it can be converted to an  AlignedSequence  object by passing a reference sequence with it:  julia   seq   =   dna ACGT--AAT--  11 nt   DNA   Sequence :  ACGT -- AAT --  julia   ref   =   dna ACGTTTAT-GG  11 nt   DNA   Sequence :  ACGTTTAT - GG  julia   AlignedSequence ( seq ,   ref )  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 - \u00b7\u00b7  ACGT -- AAT --", 
            "title": "Aligned sequence"
        }, 
        {
            "location": "/man/alignments/#operating-on-alignments", 
            "text": "#  Base.first     Function .  ..  first(coll) \n\nGet the first element of an iterable collection. Returns the start point of a  :obj: `Range` \neven if it is empty.  First position in the reference sequence.  #  Base.last     Function .  ..  last(coll) \n\nGet the last element of an ordered collection, if it can be computed in O(1) time.\nThis is accomplished by calling  :func: `endof`  to get the last index.\nReturns the end point of a  :obj: `Range`  even if it is empty.  Last position in the reference sequence.  #  Bio.Align.seq2ref     Function .  seq2ref(i, aln)  Map a position from sequence to reference.  #  Bio.Align.ref2seq     Function .  ref2seq(i, aln)  Map a position from reference to sequence.  #  Bio.Align.cigar     Function .  Output a CIGAR string encoding of an  Alignment . This is not entirely lossless as it discards the alignments start positions.", 
            "title": "Operating on alignments"
        }, 
        {
            "location": "/man/alignments/#pairwise-alignment", 
            "text": "Pairwise alignment is a sequence alignment between two sequences.  The  Bio.Align  module implements several pairwise alignment methods that maximize alignment score or minimize alignment cost.  A pair of optimization type and score (or cost) model determines the best alignments between two sequences. The next example uses a pair of  GlobalAlignment  and  AffineGapScoreModel  to obtain the best alignment:  julia   problem   =   GlobalAlignment ()  Bio . Align . GlobalAlignment ()  julia   scoremodel   =   AffineGapScoreModel ( \n                   match = 5 , \n                   mismatch =- 4 , \n                   gap_open =- 4 , \n                   gap_extend =- 1 \n               )  Bio . Align . AffineGapScoreModel { Int64 }: \n        match   =   5 \n     mismatch   =   - 4 \n     gap_open   =   - 4 \n   gap_extend   =   - 1  julia   pairalign ( problem ,   dna CGGATTA ,   dna GGTTTAC ,   scoremodel )  Bio . Align . PairwiseAlignmentResult { Int64 , Bio . Seq . BioSequence { Bio . Seq . DNAAlphabet { 4 }}, Bio . Seq . BioSequence { Bio . Seq . DNAAlphabet { 4 }}}: \n   score :   11 \n   seq :   1   CGGATTA -   7 \n           ||   ||| \n   ref :   0   - GGTTTAC   7   pairalign  takes an alignment type as its first argument, then two sequences to align, and score (or cost) model. Alignment type is one of the following four types:   GlobalAlignment : global-to-global alignment  SemiGlobalAlignment : local-to-global alignment  LocalAlignment : local-to-local alignment  OverlapAlignment : end-free alignment   For scoring model,  AffineGapScoreModel  is currently supported. It imposes an  affine gap penalty  for insertions and deletions:  gap_open + k * gap_extend  for a consecutive insertion/deletion of length  k . The affine gap penalty is flexible enough to create a constant and linear scoring model. Setting  gap_extend = 0  or  gap_open = 0 , they are equivalent to the constant or linear gap penalty, respectively. The first argument of  AffineGapScoreModel  can be a substitution matrix like  AffineGapScoreModel(BLOSUM62, gap_open=-10, gap_extend=-1) . For details on substitution matrices, see the  Substitution matrices  section.  Alignment type can also be a distance of two sequences:   EditDistance  LevenshteinDistance  HammingDistance   In this alignment,  CostModel  is used instead of  AffineGapScoreModel  to define cost of substitution, insertion, and deletion:  julia   costmodel   =   CostModel ( match = 0 ,   mismatch = 1 ,   insertion = 1 ,   deletion = 1 );  julia   pairalign ( EditDistance (),   abcd ,   adcde ,   costmodel )  Bio . Align . PairwiseAlignmentResult { Int64 , ASCIIString , ASCIIString }: \n   distance :   2 \n   seq :   1   abcd -   4 \n          |   || \n   ref :   1   adcde   5", 
            "title": "Pairwise alignment"
        }, 
        {
            "location": "/man/alignments/#operations-on-pairwise-alignment", 
            "text": "pairalign  returns a  PairwiseAlignmentResult  object and some accessors are provided for it.  #  Bio.Align.score     Function .  score(alignment_result)  Return score of alignment.  #  Bio.Align.distance     Function .  distance(alignment_result)  Retrun distance of alignment.  #  Bio.Align.hasalignment     Function .  hasalignment(alignment_result)  Check if alignment is stored or not.  #  Bio.Align.alignment     Function .  alignment(alignment_result)  Return alignment if any.  See also:  hasalignment  Pairwise alignment also implements some useful operations on it.  #  Bio.Align.count_matches     Function .  count_matches(aln)  Count the number of matching positions.  #  Bio.Align.count_mismatches     Function .  count_mismatches(aln)  Count the number of mismatching positions.  #  Bio.Align.count_insertions     Function .  count_insertions(aln)  Count the number of inserting positions.  #  Bio.Align.count_deletions     Function .  count_deletions(aln)  Count the number of deleting positions.  #  Bio.Align.count_aligned     Function .  count_aligned(aln)  Count the number of aligned positions.  The example below shows a use case of these operations:  julia   s1   =   dna CCTAGGAGGG ;  julia   s2   =   dna ACCTGGTATGATAGCG ;  julia   scoremodel   =   AffineGapScoreModel ( EDNAFULL ,   gap_open =- 5 ,   gap_extend =- 1 );  julia   res   =   pairalign ( GlobalAlignment (),   s1 ,   s2 ,   scoremodel )    # run pairwise alignment  Bio . Align . PairwiseAlignmentResult { Int64 , Bio . Seq . BioSequence { Bio . Seq . DNAAlphabet { 4 }}, Bio . Seq . BioSequence { Bio . Seq . DNAAlphabet { 4 }}}: \n   score :   13 \n   seq :    0   - CCTAGG ------ AGGG   10 \n            |||   ||        ||   | \n   ref :    1   ACCT - GGTATGATAGCG   16  julia   score ( res )    # get the achieved score of this alignment  13  julia   aln   =   alignment ( res )  PairwiseAlignment { Bio . Seq . BioSequence { Bio . Seq . DNAAlphabet { 4 }}, Bio . Seq . BioSequence { Bio . Seq . DNAAlphabet { 4 }}}: \n   seq :    0   - CCTAGG ------ AGGG   10 \n            |||   ||        ||   | \n   ref :    1   ACCT - GGTATGATAGCG   16  julia   count_matches ( aln )  8  julia   count_mismatches ( aln )  1  julia   count_insertions ( aln )  1  julia   count_deletions ( aln )  7  julia   count_aligned ( aln )  17  julia   collect ( aln )    # pairwise alignment is iterable  17 - element   Array { Tuple { Bio . Seq . DNANucleotide , Bio . Seq . DNANucleotide }, 1 }: \n  ( - , A ) \n  ( C , C ) \n  ( C , C ) \n  ( T , T ) \n  ( A , - ) \n  ( G , G ) \n  ( G , G ) \n  ( - , T ) \n  ( - , A ) \n  ( - , T ) \n  ( - , G ) \n  ( - , A ) \n  ( - , T ) \n  ( A , A ) \n  ( G , G ) \n  ( G , C ) \n  ( G , G )  julia   DNASequence ([ x   for   ( x ,   _ )   in   aln ])    # create aligned `s1` with gaps  17 nt   DNA   Sequence :  - CCTAGG ------ AGGG  julia   DNASequence ([ y   for   ( _ ,   y )   in   aln ])    # create aligned `s2` with gaps  17 nt   DNA   Sequence :  ACCT - GGTATGATAGCG", 
            "title": "Operations on pairwise alignment"
        }, 
        {
            "location": "/man/alignments/#substitution-matrices", 
            "text": "A substitution matrix is a function of substitution score (or cost) from one symbol to other. Substitution value of  submat  from  x  to  y  can be obtained by writing  submat[x,y] . In  Bio.Align ,  SubstitutionMatrix  and  DichotomousSubstitutionMatrix  are two distinct types representing substitution matrices.  SubstitutionMatrix  is a general substitution matrix type that is a thin wrapper of regular matrix.  Some common substitution matrices are provided. For DNA and RNA,  EDNAFULL  is defined:  julia   EDNAFULL  Bio . Align . SubstitutionMatrix { Bio . Seq . DNANucleotide , Int64 }: \n      A    C    G    T    M    R    W    S    Y    K    V    H    D    B    N \n   A    5   - 4   - 4   - 4    1    1    1   - 4   - 4   - 4   - 1   - 1   - 1   - 4   - 2 \n   C   - 4    5   - 4   - 4    1   - 4   - 4    1    1   - 4   - 1   - 1   - 4   - 1   - 2 \n   G   - 4   - 4    5   - 4   - 4    1   - 4    1   - 4    1   - 1   - 4   - 1   - 1   - 2 \n   T   - 4   - 4   - 4    5   - 4   - 4    1   - 4    1    1   - 4   - 1   - 1   - 1   - 2 \n   M    1    1   - 4   - 4   - 1   - 2   - 2   - 2   - 2   - 4   - 1   - 1   - 3   - 3   - 1 \n   R    1   - 4    1   - 4   - 2   - 1   - 2   - 2   - 4   - 2   - 1   - 3   - 1   - 3   - 1 \n   W    1   - 4   - 4    1   - 2   - 2   - 1   - 4   - 2   - 2   - 3   - 1   - 1   - 3   - 1 \n   S   - 4    1    1   - 4   - 2   - 2   - 4   - 1   - 2   - 2   - 1   - 3   - 3   - 1   - 1 \n   Y   - 4    1   - 4    1   - 2   - 4   - 2   - 2   - 1   - 2   - 3   - 1   - 3   - 1   - 1 \n   K   - 4   - 4    1    1   - 4   - 2   - 2   - 2   - 2   - 1   - 3   - 3   - 1   - 1   - 1 \n   V   - 1   - 1   - 1   - 4   - 1   - 1   - 3   - 1   - 3   - 3   - 1   - 2   - 2   - 2   - 1 \n   H   - 1   - 1   - 4   - 1   - 1   - 3   - 1   - 3   - 1   - 3   - 2   - 1   - 2   - 2   - 1 \n   D   - 1   - 4   - 1   - 1   - 3   - 1   - 1   - 3   - 3   - 1   - 2   - 2   - 1   - 2   - 1 \n   B   - 4   - 1   - 1   - 1   - 3   - 3   - 3   - 1   - 1   - 1   - 2   - 2   - 2   - 1   - 1 \n   N   - 2   - 2   - 2   - 2   - 1   - 1   - 1   - 1   - 1   - 1   - 1   - 1   - 1   - 1   - 1  ( underlined   values   are   default   ones )   For amino acids, PAM (Point Accepted Mutation) and BLOSUM (BLOcks SUbstitution Matrix) matrices are defined:  julia   BLOSUM62  Bio . Align . SubstitutionMatrix { Bio . Seq . AminoAcid , Int64 }: \n      A    R    N    D    C    Q    E    G    H    I    L    K    M    F    P    S    T    W    Y    V    O    U    B    J    Z    X    * \n   A    4   - 1   - 2   - 2    0   - 1   - 1    0   - 2   - 1   - 1   - 1   - 1   - 2   - 1    1    0   - 3   - 2    0    0 \u0332    0 \u0332   - 2    0 \u0332   - 1    0   - 4 \n   R   - 1    5    0   - 2   - 3    1    0   - 2    0   - 3   - 2    2   - 1   - 3   - 2   - 1   - 1   - 3   - 2   - 3    0 \u0332    0 \u0332   - 1    0 \u0332    0   - 1   - 4 \n   N   - 2    0    6    1   - 3    0    0    0    1   - 3   - 3    0   - 2   - 3   - 2    1    0   - 4   - 2   - 3    0 \u0332    0 \u0332    3    0 \u0332    0   - 1   - 4 \n   D   - 2   - 2    1    6   - 3    0    2   - 1   - 1   - 3   - 4   - 1   - 3   - 3   - 1    0   - 1   - 4   - 3   - 3    0 \u0332    0 \u0332    4    0 \u0332    1   - 1   - 4 \n   C    0   - 3   - 3   - 3    9   - 3   - 4   - 3   - 3   - 1   - 1   - 3   - 1   - 2   - 3   - 1   - 1   - 2   - 2   - 1    0 \u0332    0 \u0332   - 3    0 \u0332   - 3   - 2   - 4 \n   Q   - 1    1    0    0   - 3    5    2   - 2    0   - 3   - 2    1    0   - 3   - 1    0   - 1   - 2   - 1   - 2    0 \u0332    0 \u0332    0    0 \u0332    3   - 1   - 4 \n   E   - 1    0    0    2   - 4    2    5   - 2    0   - 3   - 3    1   - 2   - 3   - 1    0   - 1   - 3   - 2   - 2    0 \u0332    0 \u0332    1    0 \u0332    4   - 1   - 4 \n   G    0   - 2    0   - 1   - 3   - 2   - 2    6   - 2   - 4   - 4   - 2   - 3   - 3   - 2    0   - 2   - 2   - 3   - 3    0 \u0332    0 \u0332   - 1    0 \u0332   - 2   - 1   - 4 \n   H   - 2    0    1   - 1   - 3    0    0   - 2    8   - 3   - 3   - 1   - 2   - 1   - 2   - 1   - 2   - 2    2   - 3    0 \u0332    0 \u0332    0    0 \u0332    0   - 1   - 4 \n   I   - 1   - 3   - 3   - 3   - 1   - 3   - 3   - 4   - 3    4    2   - 3    1    0   - 3   - 2   - 1   - 3   - 1    3    0 \u0332    0 \u0332   - 3    0 \u0332   - 3   - 1   - 4 \n   L   - 1   - 2   - 3   - 4   - 1   - 2   - 3   - 4   - 3    2    4   - 2    2    0   - 3   - 2   - 1   - 2   - 1    1    0 \u0332    0 \u0332   - 4    0 \u0332   - 3   - 1   - 4 \n   K   - 1    2    0   - 1   - 3    1    1   - 2   - 1   - 3   - 2    5   - 1   - 3   - 1    0   - 1   - 3   - 2   - 2    0 \u0332    0 \u0332    0    0 \u0332    1   - 1   - 4 \n   M   - 1   - 1   - 2   - 3   - 1    0   - 2   - 3   - 2    1    2   - 1    5    0   - 2   - 1   - 1   - 1   - 1    1    0 \u0332    0 \u0332   - 3    0 \u0332   - 1   - 1   - 4 \n   F   - 2   - 3   - 3   - 3   - 2   - 3   - 3   - 3   - 1    0    0   - 3    0    6   - 4   - 2   - 2    1    3   - 1    0 \u0332    0 \u0332   - 3    0 \u0332   - 3   - 1   - 4 \n   P   - 1   - 2   - 2   - 1   - 3   - 1   - 1   - 2   - 2   - 3   - 3   - 1   - 2   - 4    7   - 1   - 1   - 4   - 3   - 2    0 \u0332    0 \u0332   - 2    0 \u0332   - 1   - 2   - 4 \n   S    1   - 1    1    0   - 1    0    0    0   - 1   - 2   - 2    0   - 1   - 2   - 1    4    1   - 3   - 2   - 2    0 \u0332    0 \u0332    0    0 \u0332    0    0   - 4 \n   T    0   - 1    0   - 1   - 1   - 1   - 1   - 2   - 2   - 1   - 1   - 1   - 1   - 2   - 1    1    5   - 2   - 2    0    0 \u0332    0 \u0332   - 1    0 \u0332   - 1    0   - 4 \n   W   - 3   - 3   - 4   - 4   - 2   - 2   - 3   - 2   - 2   - 3   - 2   - 3   - 1    1   - 4   - 3   - 2   11    2   - 3    0 \u0332    0 \u0332   - 4    0 \u0332   - 3   - 2   - 4 \n   Y   - 2   - 2   - 2   - 3   - 2   - 1   - 2   - 3    2   - 1   - 1   - 2   - 1    3   - 3   - 2   - 2    2    7   - 1    0 \u0332    0 \u0332   - 3    0 \u0332   - 2   - 1   - 4 \n   V    0   - 3   - 3   - 3   - 1   - 2   - 2   - 3   - 3    3    1   - 2    1   - 1   - 2   - 2    0   - 3   - 1    4    0 \u0332    0 \u0332   - 3    0 \u0332   - 2   - 1   - 4 \n   O    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332 \n   U    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332 \n   B   - 2   - 1    3    4   - 3    0    1   - 1    0   - 3   - 4    0   - 3   - 3   - 2    0   - 1   - 4   - 3   - 3    0 \u0332    0 \u0332    4    0 \u0332    1   - 1   - 4 \n   J    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332    0 \u0332 \n   Z   - 1    0    0    1   - 3    3    4   - 2    0   - 3   - 3    1   - 1   - 3   - 1    0   - 1   - 3   - 2   - 2    0 \u0332    0 \u0332    1    0 \u0332    4   - 1   - 4 \n   X    0   - 1   - 1   - 1   - 2   - 1   - 1   - 1   - 1   - 1   - 1   - 1   - 1   - 1   - 2    0    0   - 2   - 1   - 1    0 \u0332    0 \u0332   - 1    0 \u0332   - 1   - 1   - 4 \n   *   - 4   - 4   - 4   - 4   - 4   - 4   - 4   - 4   - 4   - 4   - 4   - 4   - 4   - 4   - 4   - 4   - 4   - 4   - 4   - 4    0 \u0332    0 \u0332   - 4    0 \u0332   - 4   - 4    1  ( underlined   values   are   default   ones )      Matrix  Constants      PAM  PAM30 ,  PAM70 ,  PAM250    BLOSUM  BLOSUM45 ,  BLOSUM50 ,  BLOSUM62 ,  BLOSUM80 ,  BLOSUM90     These matrices are downloaded from:  ftp://ftp.ncbi.nih.gov/blast/matrices/ .  SubstitutionMatrix  can be modified like a regular matrix:  julia   mysubmat   =   copy ( BLOSUM62 );    # create a copy  julia   mysubmat [ AA_A , AA_R ]    # score of AA_A =  AA_R substitution is -1  - 1  julia   mysubmat [ AA_A , AA_R ]   =   - 3    # set the score to -3  - 3  julia   mysubmat [ AA_A , AA_R ]    # the score is modified  - 3   Make sure to create a copy of the original matrix when you create a matrix from a predefined matrix. In the above case,  BLOSUM62  is shared in the whole program and modification on it will affect any result that uses  BLOSUM62 .  DichotomousSubstitutionMatrix  is a specialized matrix for matching or mismatching substitution.  This is a preferable choice when performance is more important than flexibility because looking up score is faster than  SubstitutionMatrix .  julia   submat   =   DichotomousSubstitutionMatrix ( 1 ,   - 1 )  Bio . Align . DichotomousSubstitutionMatrix { Int64 }: \n      match   =    1 \n   mismatch   =   - 1  julia   submat [ A , A ]    # match  1  julia   submat [ A , B ]    # mismatch  - 1", 
            "title": "Substitution matrices"
        }, 
        {
            "location": "/man/intervals/", 
            "text": "Intervals: Genomic Interval Manipulation\n\n\nThe \nIntervals\n module consists of tools for working efficiently with genomic intervals.\n\n\n\n\nInterval types\n\n\nIntervals in Bio.jl are consistent with ranges in Julia: \n1-based and end-inclusive\n. When data is read from formats with different representations (i.e. 0-based and/or end-exclusive) they are always converted automatically. Similarly when writing data. You should not have to reason about off-by-one errors due to format differences while using functionality provided in Bio.jl.\n\n\nThe \nInterval\n type is defined as\n\n\ntype\n Interval\n{\nT\n}\n \n:\n \nAbstractInterval\n{\nInt64\n}\n\n    \nseqname\n::\nASCIIString\n\n    \nfirst\n::\nInt64\n\n    \nlast\n::\nInt64\n\n    \nstrand\n::\nStrand\n\n    \nmetadata\n::\nT\n\n\nend\n\n\n\n\n\n\nSimilarly to the \nReqRecord\n type in the \nSeq\n module, \nInterval\n is parameterized on metadata type, which lets it efficiently and precisely be specialized to represent intervals from a variety of formats.\n\n\nStrand is represented by the \nStrand\n type which can take four possible values:\n\n\nSTRAND_NA\n   \n# strand is unknown or inapplicable\n\n\nSTRAND_POS\n  \n# positive strand\n\n\nSTRAND_NEG\n  \n# negative strand\n\n\nSTRAND_BOTH\n \n# non-strand-specific feature\n\n\n\n\n\n\n\n\nCollections of intervals\n\n\nCollections of intervals are represented using the \nIntervalCollection\n type, which is a general purpose indexed container for intervals. It supports fast intersection operations as well as insertion, deletion, and sorted iteration.\n\n\nInterval collections can be initialized by inserting elements one by one using \npush!\n.\n\n\n# The type parameter (Nothing here) indicates the interval metadata type.\n\n\nincol\n \n=\n \nIntervalCollection\n{\nNothing\n}()\n\n\n\nfor\n \ni\n \nin\n \n1\n:\n100\n:\n10000\n\n    \npush!\n(\nincol\n,\n \nInterval\n(\nchr1\n,\n \ni\n,\n \ni\n \n+\n \n99\n,\n \nSTRAND_POS\n,\n \nnothing\n))\n\n\nend\n\n\n\n\n\n\nIncrementally building an interval collection like this works, but \nIntervalCollection\n also has a bulk insertion constructor that is able to build the indexed data structure extremely efficiently from an array of intervals.\n\n\nincol\n \n=\n \nIntervalCollection\n([\nInterval\n(\nchr1\n,\n \ni\n,\n \ni\n \n+\n \n99\n,\n \nSTRAND_POS\n,\n \nnothing\n)\n \nfor\n \ni\n \nin\n \n1\n:\n100\n:\n10000\n])\n\n\n\n\n\n\nBulding \nIntervalCollections\n in one shot like this should be preferred when it's convenient or speed in an issue.\n\n\n\n\nIntersection\n\n\nThere are number of \nintersect\n function in the Intervals module. They follow two patterns: interval versus collection queries which return an iterator over intervals in the collection that intersect the query, and collection versus collection queries which iterate over all pairs of intersecting intervals.\n\n\n#\n\n\nBase.intersect\n \n \nFunction\n.\n\n\nintersect(s1,s2...)\n\u2229(s1,s2)\n\n\n\n\n\nConstruct the intersection of two or more sets. Maintains order and multiplicity of the first argument for arrays and ranges.\n\n\nIntersect two \nIntervalStreams\n returning an iterator over all pairs of intersecting intervals.\n\n\nIterate over pairs of intersections in an IntervalCollection versus an IntervalStream.\n\n\nIterate over pairs of intersecting intervals in two IntervalCollections\n\n\nReturn an iterator over all intervals in the collection that overlap the query interval.\n\n\n\n\nInterval streams\n\n\nIntervals need not necessarily stored in an indexed data structure for efficient intersection to be practical. Two collections of intervals need only be both sorted to compute all intersecting pairs. This is particularly useful in genomics where datasets are sometimes so large that loading them entirely into memory is not practical.\n\n\nThe Intervals module is able to intersect any two iterators that yield intervals in sorted order, which we refer to as \"interval streams\". An \nIntervalCollection\n is also a interval stream, but so is a sorted array of intervals, and parsers over interval file formats. This allows for a very general notion of intersection.\n\n\nfor\n \n(\nx\n,\n \ny\n)\n \nin\n \nintersect\n(\nopen\n(\nx_features.bed\n,\n \nBED\n),\n \nopen\n(\ny_features.bed\n,\n \nBED\n))\n\n    \nprintln\n(\nIntersection found between \n,\n \nx\n,\n \n and \n,\n \ny\n)\n\n\nend\n\n\n\n\n\n\nAn exception will be thrown if an interval in encountered out of order while processing an interval stream. Ordering of intervals has one complication: there is not necessarily a standardized way to order sequence names. By default in Bio.jl intervals are sorted using a special \nalphanum_isless\n comparison function that compares numbers numerically if they exist in string, so that names like \nchr1, chr2, chr10\n end up in their natural order.\n\n\nThe \nintersect\n function takes as an optional parameter an \nisless\n function to use to compare sequence names to account for arbitrary sequence name orderings.\n\n\n# assume lexigraphic ordering for sequence names\n\n\nfor\n \n(\nx\n,\n \ny\n)\n \nin\n \nintersect\n(\nxs\n,\n \nys\n,\n \nisless\n)\n\n    \nprintln\n(\nIntersection found between \n,\n \na\n,\n \n and \n,\n \nb\n)\n\n\nend\n\n\n\n\n\n\nA special sort of intersection can also be performed on a \nIntervalStreams\n against itself to produce \"coverage intervals\".\n\n\n#\n\n\nBio.Intervals.coverage\n \n \nFunction\n.\n\n\nCompute the coverage of a collection of intervals.\n\n\nArguments\n\n\n\n\nintervals\n: any IntervalStream\n\n\n\n\nReturns\n\n\nAn IntervalCollection that contains run-length encoded coverage data.\n\n\nE.g. for intervals like\n\n\n```{execute=\"false\"}\n    [------]     [------------]\n       [---------------]\n\n\nthis function would return a new set of disjoint intervals with annotated coverage like:\n\n```{execute=\nfalse\n}\n    [1][-2-][-1-][--2--][--1--]", 
            "title": "Intervals"
        }, 
        {
            "location": "/man/intervals/#intervals-genomic-interval-manipulation", 
            "text": "The  Intervals  module consists of tools for working efficiently with genomic intervals.", 
            "title": "Intervals: Genomic Interval Manipulation"
        }, 
        {
            "location": "/man/intervals/#interval-types", 
            "text": "Intervals in Bio.jl are consistent with ranges in Julia:  1-based and end-inclusive . When data is read from formats with different representations (i.e. 0-based and/or end-exclusive) they are always converted automatically. Similarly when writing data. You should not have to reason about off-by-one errors due to format differences while using functionality provided in Bio.jl.  The  Interval  type is defined as  type  Interval { T }   :   AbstractInterval { Int64 } \n     seqname :: ASCIIString \n     first :: Int64 \n     last :: Int64 \n     strand :: Strand \n     metadata :: T  end   Similarly to the  ReqRecord  type in the  Seq  module,  Interval  is parameterized on metadata type, which lets it efficiently and precisely be specialized to represent intervals from a variety of formats.  Strand is represented by the  Strand  type which can take four possible values:  STRAND_NA     # strand is unknown or inapplicable  STRAND_POS    # positive strand  STRAND_NEG    # negative strand  STRAND_BOTH   # non-strand-specific feature", 
            "title": "Interval types"
        }, 
        {
            "location": "/man/intervals/#collections-of-intervals", 
            "text": "Collections of intervals are represented using the  IntervalCollection  type, which is a general purpose indexed container for intervals. It supports fast intersection operations as well as insertion, deletion, and sorted iteration.  Interval collections can be initialized by inserting elements one by one using  push! .  # The type parameter (Nothing here) indicates the interval metadata type.  incol   =   IntervalCollection { Nothing }()  for   i   in   1 : 100 : 10000 \n     push! ( incol ,   Interval ( chr1 ,   i ,   i   +   99 ,   STRAND_POS ,   nothing ))  end   Incrementally building an interval collection like this works, but  IntervalCollection  also has a bulk insertion constructor that is able to build the indexed data structure extremely efficiently from an array of intervals.  incol   =   IntervalCollection ([ Interval ( chr1 ,   i ,   i   +   99 ,   STRAND_POS ,   nothing )   for   i   in   1 : 100 : 10000 ])   Bulding  IntervalCollections  in one shot like this should be preferred when it's convenient or speed in an issue.", 
            "title": "Collections of intervals"
        }, 
        {
            "location": "/man/intervals/#intersection", 
            "text": "There are number of  intersect  function in the Intervals module. They follow two patterns: interval versus collection queries which return an iterator over intervals in the collection that intersect the query, and collection versus collection queries which iterate over all pairs of intersecting intervals.  #  Base.intersect     Function .  intersect(s1,s2...)\n\u2229(s1,s2)  Construct the intersection of two or more sets. Maintains order and multiplicity of the first argument for arrays and ranges.  Intersect two  IntervalStreams  returning an iterator over all pairs of intersecting intervals.  Iterate over pairs of intersections in an IntervalCollection versus an IntervalStream.  Iterate over pairs of intersecting intervals in two IntervalCollections  Return an iterator over all intervals in the collection that overlap the query interval.", 
            "title": "Intersection"
        }, 
        {
            "location": "/man/intervals/#interval-streams", 
            "text": "Intervals need not necessarily stored in an indexed data structure for efficient intersection to be practical. Two collections of intervals need only be both sorted to compute all intersecting pairs. This is particularly useful in genomics where datasets are sometimes so large that loading them entirely into memory is not practical.  The Intervals module is able to intersect any two iterators that yield intervals in sorted order, which we refer to as \"interval streams\". An  IntervalCollection  is also a interval stream, but so is a sorted array of intervals, and parsers over interval file formats. This allows for a very general notion of intersection.  for   ( x ,   y )   in   intersect ( open ( x_features.bed ,   BED ),   open ( y_features.bed ,   BED )) \n     println ( Intersection found between  ,   x ,    and  ,   y )  end   An exception will be thrown if an interval in encountered out of order while processing an interval stream. Ordering of intervals has one complication: there is not necessarily a standardized way to order sequence names. By default in Bio.jl intervals are sorted using a special  alphanum_isless  comparison function that compares numbers numerically if they exist in string, so that names like  chr1, chr2, chr10  end up in their natural order.  The  intersect  function takes as an optional parameter an  isless  function to use to compare sequence names to account for arbitrary sequence name orderings.  # assume lexigraphic ordering for sequence names  for   ( x ,   y )   in   intersect ( xs ,   ys ,   isless ) \n     println ( Intersection found between  ,   a ,    and  ,   b )  end   A special sort of intersection can also be performed on a  IntervalStreams  against itself to produce \"coverage intervals\".  #  Bio.Intervals.coverage     Function .  Compute the coverage of a collection of intervals.", 
            "title": "Interval streams"
        }, 
        {
            "location": "/man/intervals/#arguments", 
            "text": "intervals : any IntervalStream", 
            "title": "Arguments"
        }, 
        {
            "location": "/man/intervals/#returns", 
            "text": "An IntervalCollection that contains run-length encoded coverage data.  E.g. for intervals like  ```{execute=\"false\"}\n    [------]     [------------]\n       [---------------]  this function would return a new set of disjoint intervals with annotated coverage like:\n\n```{execute= false }\n    [1][-2-][-1-][--2--][--1--]", 
            "title": "Returns"
        }, 
        {
            "location": "/man/structure/", 
            "text": "Bio.Structure: Macromolecular Structures\n\n\nThe \nBio.Structure\n module provides functionality to read Protein Data Bank (PDB) files and manipulate macromolecular structures.\n\n\n\n\nParsing PDB files\n\n\nTo download a PDB file:\n\n\ndownloadpdb\n(\n1EN2\n)\n\n\n\n\n\n\nTo parse a PDB file into a Structure-Model-Chain-Residue-Atom framework:\n\n\njulia\n \nstruc\n \n=\n \nread\n(\nfilepath_1EN2\n,\n \nPDB\n)\n\n\nName\n                        \n-\n  \n1\nEN2\n.\npdb\n\n\nNumber\n \nof\n \nmodels\n            \n-\n  \n1\n\n\nChain\n(\ns\n)\n                    \n-\n  \nA\n\n\nNumber\n \nof\n \nresidues\n          \n-\n  \n85\n\n\nNumber\n \nof\n \npoint\n \nmutations\n   \n-\n  \n5\n\n\nNumber\n \nof\n \nother\n \nmolecules\n   \n-\n  \n5\n\n\nNumber\n \nof\n \nwater\n \nmolecules\n   \n-\n  \n76\n\n\nNumber\n \nof\n \natoms\n             \n-\n  \n614\n\n\nNumber\n \nof\n \nhydrogens\n         \n-\n  \n0\n\n\nNumber\n \nof\n \ndisordered\n \natoms\n  \n-\n  \n27\n\n\n\n\n\n\nThe elements of \nstruc\n can be accessed as follows:\n\n\n\n\n\n\n\n\nCommand\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nstruc[1]\n\n\nModel 1\n\n\n\n\n\n\nstruc[1]['A']\n\n\nModel 1, chain A\n\n\n\n\n\n\nstruc['A']\n\n\nThe lowest model (model 1), chain A\n\n\n\n\n\n\nstruc['A'][\"50\"]\n\n\nModel 1, chain A, residue 50\n\n\n\n\n\n\nstruc['A'][50]\n\n\nShortcut to above if it is not a hetero residue and the insertion code is blank\n\n\n\n\n\n\nstruc['A'][\"H_90\"]\n\n\nModel 1, chain A, hetero residue 90\n\n\n\n\n\n\nstruc['A'][50][\"CA\"]\n\n\nModel 1, chain A, residue 50, atom name CA\n\n\n\n\n\n\nstruc['A'][15][\"CG\"]['A']\n\n\nFor disordered atoms, access a specific location\n\n\n\n\n\n\nstruc['A'][15][\"CG\"]\n\n\nFor disordered atoms, access the default location\n\n\n\n\n\n\n\n\nDisordered atoms are stored in a \nDisorderedAtom\n container but calls fall back to the default atom, so disorder can be ignored if you are not interested in it.\n\n\nDisordered residues (i.e. point mutations with different residue names) are stored in a \nDisorderedResidue\n container.\n\n\nThe idea is that disorder will only bother you if you want it to. See the \nBiopython discussion\n for more.\n\n\nProperties can be retrieved as follows:\n\n\n\n\n\n\n\n\nCommand\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nstructurename(struc)\n\n\nName of a structure\n\n\n\n\n\n\nmodelnumbers(struc)\n\n\nModel numbers in a structure\n\n\n\n\n\n\nchainids(struc)\n\n\nChain IDs in a structure\n\n\n\n\n\n\nmodelnumber(model)\n\n\nNumber of a model\n\n\n\n\n\n\nchainids(model)\n\n\nChain IDs in a model\n\n\n\n\n\n\nchainid(chain)\n\n\nChain ID of a chain\n\n\n\n\n\n\nresids(chain)\n\n\nResidue IDs in a chain\n\n\n\n\n\n\nresname(res)\n\n\nName of a residue\n\n\n\n\n\n\nchainid(res)\n\n\nChain ID of a residue\n\n\n\n\n\n\nresnumber(res)\n\n\nResidue number of a residue\n\n\n\n\n\n\ninscode(res)\n\n\nInsertion code of a residue\n\n\n\n\n\n\nishetres(res)\n\n\ntrue\n if the residue consists of hetero atoms\n\n\n\n\n\n\natomnames(res)\n\n\nAtom names in a residue\n\n\n\n\n\n\nisdisorderedres(res)\n\n\ntrue\n if the residue has multiple residue names\n\n\n\n\n\n\nresid(res)\n\n\nResidue ID of a residue\n\n\n\n\n\n\nishetatom(atom)\n\n\ntrue\n if the atom is a hetero atom\n\n\n\n\n\n\nserial(atom)\n\n\nSerial number of an atom\n\n\n\n\n\n\natomname(atom)\n\n\nName of an atom\n\n\n\n\n\n\naltlocid(atom)\n\n\nAlternative location ID of an atom\n\n\n\n\n\n\nresname(atom)\n\n\nResidue name of an atom\n\n\n\n\n\n\nchainid(atom)\n\n\nChain ID of an atom\n\n\n\n\n\n\nresnumber(atom)\n\n\nResidue number of an atom\n\n\n\n\n\n\ninscode(atom)\n\n\nInsertion code of an atom\n\n\n\n\n\n\nx(atom)\n\n\nx coordinate of an atom\n\n\n\n\n\n\ny(atom)\n\n\ny coordinate of an atom\n\n\n\n\n\n\nz(atom)\n\n\nz coordinate of an atom\n\n\n\n\n\n\ncoords(atom)\n\n\ncoordinates of an atom as a \nVector{Float64}\n\n\n\n\n\n\noccupancy(atom)\n\n\nOccupancy of an atom (default is \n1.0\n)\n\n\n\n\n\n\ntempfac(atom)\n\n\nTemperature factor of an atom (default is \n0.0\n)\n\n\n\n\n\n\nelement(atom)\n\n\nElement of an atom (default is \n\"\"\n)\n\n\n\n\n\n\ncharge(atom)\n\n\nCharge of an atom (default is \n\"\"\n)\n\n\n\n\n\n\nisdisorderedatom(atom)\n\n\ntrue\n if the atom is disordered\n\n\n\n\n\n\nresid(atom)\n\n\nResidue ID of an atom\n\n\n\n\n\n\n\n\nThe coordinates of an atom can be set using \nx!\n, \ny!\n, \nz!\n and \ncoords!\n.\n\n\n\n\nManipulating Structures\n\n\nElements can be looped over to reveal the sub-elements in the correct order:\n\n\nfor\n \nmodel\n \nin\n \nstruc\n\n    \nfor\n \nchain\n \nin\n \nmodel\n\n        \nfor\n \nres\n \nin\n \nchain\n\n            \nfor\n \natom\n \nin\n \nres\n\n                \n# Do something\n\n            \nend\n\n        \nend\n\n    \nend\n\n\nend\n\n\n\n\n\n\ncollect\n, \ncollectresidues\n and \ncollectatoms\n can be used to get lists of sub-elements.\n\n\nSelectors are functions passed as additional arguments to \ncollectresidues\n and \ncollectatoms\n. Only residues/atoms that return \ntrue\n when passed to the selector are retained.\n\n\n\n\n\n\n\n\nCommand\n\n\nAction\n\n\n\n\n\n\n\n\n\n\ncollect(struc['A'][50])\n\n\nCollect the sub-elements of an element, e.g. atoms from a residue\n\n\n\n\n\n\ncollectresidues(struc)\n\n\nCollect the residues of an element\n\n\n\n\n\n\ncollectatoms(struc)\n\n\nCollect the atoms of an element\n\n\n\n\n\n\ncollectatoms(struc, calphaselector)\n\n\nCollect the C-alpha atoms of an element\n\n\n\n\n\n\ncollectatoms(struc, calphaselector, disorderselector)\n\n\nCollect the disordered C-alpha atoms of an element\n\n\n\n\n\n\n\n\nIt is easy to define your own selector. The below will collect all atoms with x coordinate less than 0:\n\n\nxselector\n(\natom\n::\nAbstractAtom\n)\n \n=\n \nx\n(\natom\n)\n \n \n0\n\n\ncollectatoms\n(\nstruc\n,\n \nxselector\n)\n\n\n\n\n\n\ncountmodels\n, \ncountchains\n, \ncountresidues\n and \ncountatoms\n can be used to count elements. For example:\n\n\njulia\n \ncountatoms\n(\nstruc\n)\n\n\n754\n\n\n\njulia\n \ncountatoms\n(\nstruc\n,\n \ncalphaselector\n)\n\n\n85\n\n\n\njulia\n \ncountresidues\n(\nstruc\n,\n \nstdresselector\n)\n\n\n85\n\n\n\n\n\n\norganise\n, \norganisemodel\n and \norganisestruc\n can be used to organise sub-elements into elements:\n\n\n\n\n\n\n\n\nCommand\n\n\nAction\n\n\n\n\n\n\n\n\n\n\norganise(collectatoms(struc))\n\n\nOrganise an atom list into a residue list\n\n\n\n\n\n\norganise(collectresidues(struc))\n\n\nOrganise a residue list into a chain list\n\n\n\n\n\n\norganise(struc['A'])\n\n\nOrganise chain(s) into a model\n\n\n\n\n\n\norganise(struc[1])\n\n\nOrganise model(s) into a structure\n\n\n\n\n\n\norganisemodel(collectatoms(struc))\n\n\nOrganise elements into a model\n\n\n\n\n\n\norganisestructure(collectatoms(struc))\n\n\nOrganise elements into a structure\n\n\n\n\n\n\n\n\nDistances can be calculated. The minimum distance between residue 10 and 20 is:\n\n\njulia\n \ndistance\n(\nstruc\n[\nA\n][\n10\n],\n \nstruc\n[\nA\n][\n20\n])\n\n\n10.782158874733762\n\n\n\n\n\n\nRMSDs/displacements between elements of the same size can also be calculated with \nrmsd\n and \ndisplacements\n.\n\n\n\n\nWriting PDB files\n\n\nPDB format files can be written:\n\n\nwritepdb\n(\n1EN2_out.pdb\n,\n \nstruc\n)\n\n\n\n\n\n\nAny element type can be given as input. Selectors can also be given as additional arguments:\n\n\nwritepdb\n(\n1EN2_out.pdb\n,\n \nstruc\n,\n \nbackboneselector\n)\n\n\n\n\n\n\n\n\nExamples\n\n\nA few examples of \nBio.Structure\n usage are given below.\n\n\nA)\n To plot the temperature factors of a protein, if you have Gadfly installed:\n\n\nusing\n \nGadfly\n\n\natoms\n \n=\n \ncollectatoms\n(\nstruc\n,\n \ncalphaselector\n)\n\n\nres_numbers\n \n=\n \nmap\n(\nresnumber\n,\n \natoms\n)\n\n\ntemp_facs\n \n=\n \nmap\n(\ntempfac\n,\n \natoms\n)\n\n\nplot\n(\nx\n=\nres_numbers\n,\n \ny\n=\ntemp_facs\n,\n \nGeom\n.\nline\n)\n\n\n\n\n\n\nB)\n To find all C-alpha atoms within 5 Angstroms of residue 38:\n\n\nfor\n \natom\n \nin\n \natoms\n\n    \nif\n \ndistance\n(\nstruc\n[\nA\n][\n38\n],\n \natom\n)\n \n \n5.0\n \n \nresnumber\n(\natom\n)\n \n!=\n \n38\n\n        \nshow\n(\natom\n)\n\n    \nend\n\n\nend\n\n\n\n\n\n\nC)\n To calculate the RMSD and displacements between the heavy (non-hydrogen) atoms of two models in an NMR structure:\n\n\ndownloadpdb\n(\n1SSU\n)\n\n\nstruc_nmr\n \n=\n \nread\n(\n1SSU.pdb\n,\n \nPDB\n)\n\n\nrmsd\n(\nstruc_nmr\n[\n5\n],\n \nstruc_nmr\n[\n10\n],\n \nheavyatomselector\n)\n\n\ndisplacements\n(\nstruc_nmr\n[\n5\n],\n \nstruc_nmr\n[\n10\n],\n \nheavyatomselector\n)", 
            "title": "Structure"
        }, 
        {
            "location": "/man/structure/#biostructure-macromolecular-structures", 
            "text": "The  Bio.Structure  module provides functionality to read Protein Data Bank (PDB) files and manipulate macromolecular structures.", 
            "title": "Bio.Structure: Macromolecular Structures"
        }, 
        {
            "location": "/man/structure/#parsing-pdb-files", 
            "text": "To download a PDB file:  downloadpdb ( 1EN2 )   To parse a PDB file into a Structure-Model-Chain-Residue-Atom framework:  julia   struc   =   read ( filepath_1EN2 ,   PDB )  Name                          -    1 EN2 . pdb  Number   of   models              -    1  Chain ( s )                      -    A  Number   of   residues            -    85  Number   of   point   mutations     -    5  Number   of   other   molecules     -    5  Number   of   water   molecules     -    76  Number   of   atoms               -    614  Number   of   hydrogens           -    0  Number   of   disordered   atoms    -    27   The elements of  struc  can be accessed as follows:     Command  Returns      struc[1]  Model 1    struc[1]['A']  Model 1, chain A    struc['A']  The lowest model (model 1), chain A    struc['A'][\"50\"]  Model 1, chain A, residue 50    struc['A'][50]  Shortcut to above if it is not a hetero residue and the insertion code is blank    struc['A'][\"H_90\"]  Model 1, chain A, hetero residue 90    struc['A'][50][\"CA\"]  Model 1, chain A, residue 50, atom name CA    struc['A'][15][\"CG\"]['A']  For disordered atoms, access a specific location    struc['A'][15][\"CG\"]  For disordered atoms, access the default location     Disordered atoms are stored in a  DisorderedAtom  container but calls fall back to the default atom, so disorder can be ignored if you are not interested in it.  Disordered residues (i.e. point mutations with different residue names) are stored in a  DisorderedResidue  container.  The idea is that disorder will only bother you if you want it to. See the  Biopython discussion  for more.  Properties can be retrieved as follows:     Command  Returns      structurename(struc)  Name of a structure    modelnumbers(struc)  Model numbers in a structure    chainids(struc)  Chain IDs in a structure    modelnumber(model)  Number of a model    chainids(model)  Chain IDs in a model    chainid(chain)  Chain ID of a chain    resids(chain)  Residue IDs in a chain    resname(res)  Name of a residue    chainid(res)  Chain ID of a residue    resnumber(res)  Residue number of a residue    inscode(res)  Insertion code of a residue    ishetres(res)  true  if the residue consists of hetero atoms    atomnames(res)  Atom names in a residue    isdisorderedres(res)  true  if the residue has multiple residue names    resid(res)  Residue ID of a residue    ishetatom(atom)  true  if the atom is a hetero atom    serial(atom)  Serial number of an atom    atomname(atom)  Name of an atom    altlocid(atom)  Alternative location ID of an atom    resname(atom)  Residue name of an atom    chainid(atom)  Chain ID of an atom    resnumber(atom)  Residue number of an atom    inscode(atom)  Insertion code of an atom    x(atom)  x coordinate of an atom    y(atom)  y coordinate of an atom    z(atom)  z coordinate of an atom    coords(atom)  coordinates of an atom as a  Vector{Float64}    occupancy(atom)  Occupancy of an atom (default is  1.0 )    tempfac(atom)  Temperature factor of an atom (default is  0.0 )    element(atom)  Element of an atom (default is  \"\" )    charge(atom)  Charge of an atom (default is  \"\" )    isdisorderedatom(atom)  true  if the atom is disordered    resid(atom)  Residue ID of an atom     The coordinates of an atom can be set using  x! ,  y! ,  z!  and  coords! .", 
            "title": "Parsing PDB files"
        }, 
        {
            "location": "/man/structure/#manipulating-structures", 
            "text": "Elements can be looped over to reveal the sub-elements in the correct order:  for   model   in   struc \n     for   chain   in   model \n         for   res   in   chain \n             for   atom   in   res \n                 # Do something \n             end \n         end \n     end  end   collect ,  collectresidues  and  collectatoms  can be used to get lists of sub-elements.  Selectors are functions passed as additional arguments to  collectresidues  and  collectatoms . Only residues/atoms that return  true  when passed to the selector are retained.     Command  Action      collect(struc['A'][50])  Collect the sub-elements of an element, e.g. atoms from a residue    collectresidues(struc)  Collect the residues of an element    collectatoms(struc)  Collect the atoms of an element    collectatoms(struc, calphaselector)  Collect the C-alpha atoms of an element    collectatoms(struc, calphaselector, disorderselector)  Collect the disordered C-alpha atoms of an element     It is easy to define your own selector. The below will collect all atoms with x coordinate less than 0:  xselector ( atom :: AbstractAtom )   =   x ( atom )     0  collectatoms ( struc ,   xselector )   countmodels ,  countchains ,  countresidues  and  countatoms  can be used to count elements. For example:  julia   countatoms ( struc )  754  julia   countatoms ( struc ,   calphaselector )  85  julia   countresidues ( struc ,   stdresselector )  85   organise ,  organisemodel  and  organisestruc  can be used to organise sub-elements into elements:     Command  Action      organise(collectatoms(struc))  Organise an atom list into a residue list    organise(collectresidues(struc))  Organise a residue list into a chain list    organise(struc['A'])  Organise chain(s) into a model    organise(struc[1])  Organise model(s) into a structure    organisemodel(collectatoms(struc))  Organise elements into a model    organisestructure(collectatoms(struc))  Organise elements into a structure     Distances can be calculated. The minimum distance between residue 10 and 20 is:  julia   distance ( struc [ A ][ 10 ],   struc [ A ][ 20 ])  10.782158874733762   RMSDs/displacements between elements of the same size can also be calculated with  rmsd  and  displacements .", 
            "title": "Manipulating Structures"
        }, 
        {
            "location": "/man/structure/#writing-pdb-files", 
            "text": "PDB format files can be written:  writepdb ( 1EN2_out.pdb ,   struc )   Any element type can be given as input. Selectors can also be given as additional arguments:  writepdb ( 1EN2_out.pdb ,   struc ,   backboneselector )", 
            "title": "Writing PDB files"
        }, 
        {
            "location": "/man/structure/#examples", 
            "text": "A few examples of  Bio.Structure  usage are given below.  A)  To plot the temperature factors of a protein, if you have Gadfly installed:  using   Gadfly  atoms   =   collectatoms ( struc ,   calphaselector )  res_numbers   =   map ( resnumber ,   atoms )  temp_facs   =   map ( tempfac ,   atoms )  plot ( x = res_numbers ,   y = temp_facs ,   Geom . line )   B)  To find all C-alpha atoms within 5 Angstroms of residue 38:  for   atom   in   atoms \n     if   distance ( struc [ A ][ 38 ],   atom )     5.0     resnumber ( atom )   !=   38 \n         show ( atom ) \n     end  end   C)  To calculate the RMSD and displacements between the heavy (non-hydrogen) atoms of two models in an NMR structure:  downloadpdb ( 1SSU )  struc_nmr   =   read ( 1SSU.pdb ,   PDB )  rmsd ( struc_nmr [ 5 ],   struc_nmr [ 10 ],   heavyatomselector )  displacements ( struc_nmr [ 5 ],   struc_nmr [ 10 ],   heavyatomselector )", 
            "title": "Examples"
        }, 
        {
            "location": "/man/tools/", 
            "text": "Tools: Misc tools and function wrappers\n\n\n\n\nBlast wrapper\n\n\nThe \nBlast\n module is a wrapper for the command line interface of \nBLAST+\n from NCBI. It requires that you have Blast+ \ninstalled\n and accessible in your PATH (eg. you should be able to execute \n$ blastn -h\n from the command line).\n\n\n\n\nThe Basics\n\n\nThis module allows you to run protein and nucleotide BLAST (\nblastp\n and \nblastn\n respectively) within julia and to parse BLAST results into Bio.jl types.\n\n\nusing\n \nBio\n.\nSeq\n,\n\n      \nBio\n.\nBlast\n\n\n\nseq1\n \n=\n \ndna\nCGGACCAGACGGACACAGGGAGAAGCTAGTTTCTTTCATGTGATTGANATNATGACTCTACTCCTAAAAGGGAAAAANCAATATCCTTGTTTACAGAAGAGAAACAAACAAGCCCCACTCAGCTCAGTCACAGGAGAGAN\n\n\nseq2\n \n=\n \ndna\nCGGAGCCAGCGAGCATATGCTGCATGAGGACCTTTCTATCTTACATTATGGCTGGGAATCTTACTCTTTCATCTGATACCTTGTTCAGATTTCAAAATAGTTGTAGCCTTATCCTGGTTTTACAGATGTGAAACTTTCAA\n\n\n\nblastn\n(\nseq1\n,\n \nseq2\n)\n\n\n\n\n\n\nThese functions return a \nVector{BlastResult}\n. Each element is a hit which includes the sequence of the hit, an \nAlignedSequence\n using the original query as a reference and some additional information (expect vaue, bitscore) for the hit.\n\n\nimmutable\n \nBlastResult\n\n    \nbitscore\n::\nFloat64\n\n    \nexpect\n::\nFloat64\n\n    \nqueryname\n::\nASCIIString\n\n    \nhitname\n::\nASCIIString\n\n    \nhit\n::\nBioSequence\n\n    \nalignment\n::\nAlignedSequence\n\n\nend\n\n\n\n\n\n\nIf you've already run a blast analysis or have downloaded blast results in XML format from NCBI you can also pass an XML string to \nreadblastXML()\n in order to obtain an array of \nBlastResult\ns.\n\n\nresults\n \n=\n \nreadall\n(\nopen\n(\nblast_results.xml\n))\n \n# need to use `readstring` instead of `readall` for v0.5\n\n\nreadblastXML\n(\nresults\n)\n\n\n\n\n\n\nWhen parsing protein blast results, you must include the argument \nseqtype=\"prot\"\n, eg. \nreadblastXML(\"results, seqtype=\"prot\")\n\n\n\n\nOptions for \nblastn\n and \nblastp\n\n\nBoth of the basic BLAST+ commands can accept a single \nBioSequence\n, a \nVector{BioSequence}\n or a sting representing a file path to a fasta formatted file as arguments for both \nquery\n and \nsubject\n.\n\n\nblastn\n([\nseq1\n,\n \nseq2\n],\n \n[\nseq2\n,\n \nseq3\n])\n\n\n\nblastp\n(\naaseq\n,\n \npath/to/sequences.fasta\n)\n\n\n\n\n\n\nIf you have a local blast database (eg through the use of \n$ makeblastdb\n), you can use this database as the \nsubject\n\n\nblastn\n(\nseq1\n,\n \npath/to/blast_db\n,\n \ndb\n=\ntrue\n)\n\n\n\n\n\n\nIf you want to modify the search using additional options (eg. return only results with greater than 90% identity), you may pass a \nVector\n of flags (see \nhere\n for valid arguments - do not use flags that will alter file handling such as \n-outfmt\n)\n\n\nblastn\n(\nseq1\n,\n \nseq2\n,\n \n[\n-perc_identity\n,\n \n90\n,\n \n-evalue\n,\n \n9.0\n])", 
            "title": "Tools"
        }, 
        {
            "location": "/man/tools/#tools-misc-tools-and-function-wrappers", 
            "text": "", 
            "title": "Tools: Misc tools and function wrappers"
        }, 
        {
            "location": "/man/tools/#blast-wrapper", 
            "text": "The  Blast  module is a wrapper for the command line interface of  BLAST+  from NCBI. It requires that you have Blast+  installed  and accessible in your PATH (eg. you should be able to execute  $ blastn -h  from the command line).", 
            "title": "Blast wrapper"
        }, 
        {
            "location": "/man/tools/#the-basics", 
            "text": "This module allows you to run protein and nucleotide BLAST ( blastp  and  blastn  respectively) within julia and to parse BLAST results into Bio.jl types.  using   Bio . Seq , \n       Bio . Blast  seq1   =   dna CGGACCAGACGGACACAGGGAGAAGCTAGTTTCTTTCATGTGATTGANATNATGACTCTACTCCTAAAAGGGAAAAANCAATATCCTTGTTTACAGAAGAGAAACAAACAAGCCCCACTCAGCTCAGTCACAGGAGAGAN  seq2   =   dna CGGAGCCAGCGAGCATATGCTGCATGAGGACCTTTCTATCTTACATTATGGCTGGGAATCTTACTCTTTCATCTGATACCTTGTTCAGATTTCAAAATAGTTGTAGCCTTATCCTGGTTTTACAGATGTGAAACTTTCAA  blastn ( seq1 ,   seq2 )   These functions return a  Vector{BlastResult} . Each element is a hit which includes the sequence of the hit, an  AlignedSequence  using the original query as a reference and some additional information (expect vaue, bitscore) for the hit.  immutable   BlastResult \n     bitscore :: Float64 \n     expect :: Float64 \n     queryname :: ASCIIString \n     hitname :: ASCIIString \n     hit :: BioSequence \n     alignment :: AlignedSequence  end   If you've already run a blast analysis or have downloaded blast results in XML format from NCBI you can also pass an XML string to  readblastXML()  in order to obtain an array of  BlastResult s.  results   =   readall ( open ( blast_results.xml ))   # need to use `readstring` instead of `readall` for v0.5  readblastXML ( results )   When parsing protein blast results, you must include the argument  seqtype=\"prot\" , eg.  readblastXML(\"results, seqtype=\"prot\")", 
            "title": "The Basics"
        }, 
        {
            "location": "/man/tools/#options-for-blastn-and-blastp", 
            "text": "Both of the basic BLAST+ commands can accept a single  BioSequence , a  Vector{BioSequence}  or a sting representing a file path to a fasta formatted file as arguments for both  query  and  subject .  blastn ([ seq1 ,   seq2 ],   [ seq2 ,   seq3 ])  blastp ( aaseq ,   path/to/sequences.fasta )   If you have a local blast database (eg through the use of  $ makeblastdb ), you can use this database as the  subject  blastn ( seq1 ,   path/to/blast_db ,   db = true )   If you want to modify the search using additional options (eg. return only results with greater than 90% identity), you may pass a  Vector  of flags (see  here  for valid arguments - do not use flags that will alter file handling such as  -outfmt )  blastn ( seq1 ,   seq2 ,   [ -perc_identity ,   90 ,   -evalue ,   9.0 ])", 
            "title": "Options for blastn and blastp"
        }, 
        {
            "location": "/lib/seq/", 
            "text": "Reference: Bio.Seq - Biological Sequences\n\n\nUnder_Construction\n\n\n\n\nTypes\n\n\n\n\nMethods", 
            "title": "Seq"
        }, 
        {
            "location": "/lib/seq/#reference-bioseq-biological-sequences", 
            "text": "Under_Construction", 
            "title": "Reference: Bio.Seq - Biological Sequences"
        }, 
        {
            "location": "/lib/seq/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lib/seq/#methods", 
            "text": "", 
            "title": "Methods"
        }, 
        {
            "location": "/man/contributing/", 
            "text": "Contributing\n\n\nWe welcome contributions in the form of pull requests. For your code to be considered it must meet the following guidelines.\n\n\n\n\n\n\nBy making a pull request, you're agreeing to license your code under an MIT     license. See LICENSE.md.\n\n\n\n\n\n\nTypes and functions must be documented using Julia's \ndocstrings\n.     Documentation regarding specific implementation details that aren't relevant     to users should be in the form of comments.\n\n\n\n\n\n\nDocumentation may be omitted if the function is not exported (i.e. only used\ninternally) and is short and obvious. E.g. `cube(x) = x^3`.\n\n\n\n\n\n\n\n\n\nIn addition to documenting code in the source files through docstrings,     we encourage contributers to create documentation which is more akin to      a manual, with user guides, tutorials, or R-like vignettes. We use Documenter.jl      and mkdocs, to generate such documentation and host it on our website.     The source markdown files for such documentation, guides, and vignettes     are located in the \ndocs/src/man\n folder of the Bio.jl git repo.\n\n\n\n\n\n\nAll significant code must be tested. Tests should be organized into     contexts, and into separate files based on module.     Files for tests for a module go into an appropriately named     folder, within the \ntest\n folder in the Bio.jl git repo. E.g. tests     for the Seq module go in \ntest/seq\n.\n\n\n\n\n\n\nContributions are included if the code has been reviewed by at least two     team members who are \nnot\n the author of the proposed contribution,     and there is general consensus (or general lack of objections) that it's useful     and fits with the intended scope of Bio.jl.\n\n\n\n\n\n\nCode must be consistent with the prevailing style in Bio.jl, which includes,     but is not necessarily limited to the following style guide.\n\n\n\n\n\n\nCode contributed should be compatible with Julia v0.4.\n\n\n\n\n\n\n\n\nStyle\n\n\n\n\n\n\nIndent with 4 spaces.\n\n\n\n\n\n\nType names are camel case, with the first letter capitalized. E.g.     \nSomeVeryUsefulType\n.\n\n\n\n\n\n\nModule names are also camel case.\n\n\n\n\n\n\nFunction names, apart from constructors, are all lowercase. Include     underscores between words only if the name would be hard to read without.     E.g.  \nstart\n, \nstop\n, \nfindletter\n \nfind_last_digit\n.\n\n\n\n\n\n\nGenerally try to keep lines below 80-columns, unless splitting a long line     onto multiple lines makes it harder to read.\n\n\n\n\n\n\nFiles that declare modules should only declare the module, and import any     modules that it requires. Any code should     be included from separate files. E.g.\n\n\n\n\n\n\n```julia\nmodule AwesomeFeatures\n\nusing IntervalTrees, JSON\n\ninclude(\nfeature1.jl\n)\ninclude(\nfeature2.jl\n)\n\nend\n```\n\n\n\n\n\n\n\n\n\nFiles that declare modules should have the same name name of the module, e.g     the module \nSomeModule\n is declared under the file \nSomeModule.jl\n.\n\n\n\n\n\n\nSeparate logical blocks of code with one blank line, or two blank lines for     function/type definitions.\n\n\n\n\n\n\nWhen extending method definitions, explicitly import the method.\n\n\n\n\n\n\n``\n`\njulia\n\n\nimport\n \nBase\n:\n \nstart\n,\n \nnext\n,\n \ndone\n\n\n``\n`\n\n\n\n\n\n\n\n\nDocument functions using bare docstrings before a definition:\n\n\n\n\njulia   \"This function foo's something\"   foo(x) = 2*x\n\n\n\n\nFunctions that get or set variables in a type should not be prefixed with 'get' or 'set'. The getter should be named for the variable it sets, and the setter should have the same name as the getter, with the suffix \n!\n. For exmaple, for the variable \nnames\n:\n\n\n\n\njulia   name(node) # get node name   name!(node, \"somename\") # set node name\n\n\n\n\nConduct\n\n\nWe adhere to the Julia \ncommunity standards\n.", 
            "title": "Contributing"
        }, 
        {
            "location": "/man/contributing/#contributing", 
            "text": "We welcome contributions in the form of pull requests. For your code to be considered it must meet the following guidelines.    By making a pull request, you're agreeing to license your code under an MIT     license. See LICENSE.md.    Types and functions must be documented using Julia's  docstrings .     Documentation regarding specific implementation details that aren't relevant     to users should be in the form of comments.    Documentation may be omitted if the function is not exported (i.e. only used\ninternally) and is short and obvious. E.g. `cube(x) = x^3`.    In addition to documenting code in the source files through docstrings,     we encourage contributers to create documentation which is more akin to      a manual, with user guides, tutorials, or R-like vignettes. We use Documenter.jl      and mkdocs, to generate such documentation and host it on our website.     The source markdown files for such documentation, guides, and vignettes     are located in the  docs/src/man  folder of the Bio.jl git repo.    All significant code must be tested. Tests should be organized into     contexts, and into separate files based on module.     Files for tests for a module go into an appropriately named     folder, within the  test  folder in the Bio.jl git repo. E.g. tests     for the Seq module go in  test/seq .    Contributions are included if the code has been reviewed by at least two     team members who are  not  the author of the proposed contribution,     and there is general consensus (or general lack of objections) that it's useful     and fits with the intended scope of Bio.jl.    Code must be consistent with the prevailing style in Bio.jl, which includes,     but is not necessarily limited to the following style guide.    Code contributed should be compatible with Julia v0.4.", 
            "title": "Contributing"
        }, 
        {
            "location": "/man/contributing/#style", 
            "text": "Indent with 4 spaces.    Type names are camel case, with the first letter capitalized. E.g.      SomeVeryUsefulType .    Module names are also camel case.    Function names, apart from constructors, are all lowercase. Include     underscores between words only if the name would be hard to read without.     E.g.   start ,  stop ,  findletter   find_last_digit .    Generally try to keep lines below 80-columns, unless splitting a long line     onto multiple lines makes it harder to read.    Files that declare modules should only declare the module, and import any     modules that it requires. Any code should     be included from separate files. E.g.    ```julia\nmodule AwesomeFeatures\n\nusing IntervalTrees, JSON\n\ninclude( feature1.jl )\ninclude( feature2.jl )\n\nend\n```    Files that declare modules should have the same name name of the module, e.g     the module  SomeModule  is declared under the file  SomeModule.jl .    Separate logical blocks of code with one blank line, or two blank lines for     function/type definitions.    When extending method definitions, explicitly import the method.    `` ` julia  import   Base :   start ,   next ,   done  `` `    Document functions using bare docstrings before a definition:   julia   \"This function foo's something\"   foo(x) = 2*x   Functions that get or set variables in a type should not be prefixed with 'get' or 'set'. The getter should be named for the variable it sets, and the setter should have the same name as the getter, with the suffix  ! . For exmaple, for the variable  names :   julia   name(node) # get node name   name!(node, \"somename\") # set node name", 
            "title": "Style"
        }, 
        {
            "location": "/man/contributing/#conduct", 
            "text": "We adhere to the Julia  community standards .", 
            "title": "Conduct"
        }
    ]
}