{
    "docs": [
        {
            "location": "/", 
            "text": "Bio.jl Documentation\n\n\n\n\nInstallation\n\n\nBio.Seq: Biological Sequences\n\n\nBiological symbols\n\n\nOverview of sequences types\n\n\nGeneral-purpose sequences\n\n\nNucleotide k-mers\n\n\nReference sequences\n\n\nSequence search\n\n\nSequence composition\n\n\nSequence records\n\n\nSequence demultiplexing\n\n\n\n\n\n\nAlign: Sequence Alignments\n\n\nRepresenting alignments\n\n\nAligned sequence\n\n\nOperating on alignments\n\n\nPairwise alignment\n\n\nSubstitution matrices\n\n\n\n\n\n\nIntervals: Genomic Interval Manipulation\n\n\nInterval types\n\n\nCollections of intervals\n\n\nIntersection\n\n\nInterval streams\n\n\n\n\n\n\nBio.Var: Biological Variation.\n\n\nCounting mutations\n\n\nComputing evolutionary and genetic distances\n\n\n\n\n\n\nBio.Structure: Macromolecular Structures\n\n\nParsing PDB files\n\n\nManipulating Structures\n\n\nWriting PDB files\n\n\nExamples\n\n\n\n\n\n\nBio.Util: Utility Functions\n\n\nLabelled square matrix parsers\n\n\n\n\n\n\nBio.Tools: Misc tools and function wrappers\n\n\nBLAST wrapper", 
            "title": "Home"
        }, 
        {
            "location": "/#biojl-documentation", 
            "text": "Installation  Bio.Seq: Biological Sequences  Biological symbols  Overview of sequences types  General-purpose sequences  Nucleotide k-mers  Reference sequences  Sequence search  Sequence composition  Sequence records  Sequence demultiplexing    Align: Sequence Alignments  Representing alignments  Aligned sequence  Operating on alignments  Pairwise alignment  Substitution matrices    Intervals: Genomic Interval Manipulation  Interval types  Collections of intervals  Intersection  Interval streams    Bio.Var: Biological Variation.  Counting mutations  Computing evolutionary and genetic distances    Bio.Structure: Macromolecular Structures  Parsing PDB files  Manipulating Structures  Writing PDB files  Examples    Bio.Util: Utility Functions  Labelled square matrix parsers    Bio.Tools: Misc tools and function wrappers  BLAST wrapper", 
            "title": "Bio.jl Documentation"
        }, 
        {
            "location": "/man/install/", 
            "text": "Installation\n\n\nInstall Bio.jl using the package manager.\n\n\nPkg\n.\nadd\n(\nBio\n)\n\n\n\n\n\n\nAlternatively, clone the latest version or a specific branch using Pkg.clone.", 
            "title": "Installation"
        }, 
        {
            "location": "/man/install/#installation", 
            "text": "Install Bio.jl using the package manager.  Pkg . add ( Bio )   Alternatively, clone the latest version or a specific branch using Pkg.clone.", 
            "title": "Installation"
        }, 
        {
            "location": "/man/reading/", 
            "text": "Reading and writing data\n\n\nBio.jl has a unified interface for reading and writing files in a variety of formats. To initialize a parser for a particular format, the \nopen\n method is extended with a file format type parameter \nT\n:\n\n\nopen\n{\nT\n:\nFileFormat\n}(\nfilename\n::\nAbstractString\n,\n \n::\nType\n{\nT\n})\n\n\nopen\n{\nT\n:\nFileFormat\n}(\nsource\n::\nIO\n,\n \n::\nType\n{\nT\n})\n\n\nopen\n{\nT\n:\nFileFormat\n}(\ndata\n::\nVector\n{\nUInt8\n},\n \n::\nType\n{\nT\n})\n\n\n\n\n\n\nFor example, when reading a FASTA file, a parser for the FASTA file format can be initialized as:\n\n\nusing\n \nBio\n.\nSeq\n  \n# import FASTA\n\n\nparser\n \n=\n \nopen\n(\nhg38.fa\n,\n \nFASTA\n)\n\n\n\n\n\n\n\n\nParsing by iteration\n\n\nParsers in Bio.jl all read and return entries one at a time. The most convenient way to do this by iteration.\n\n\nstream\n \n=\n \nopen\n(\ninput.bed\n,\n \nBED\n)\n\n\nfor\n \nentry\n \nin\n \nstream\n\n    \n# perform some operation on entry\n\n\nend\n\n\n\n\n\n\n\n\nIn-place parsing\n\n\nIterating through entries in a file is convenient, but for each entry in the file, the parser must allocate, and ultimately the garbage collector must spend time to deallocate it. For performance critical applications, a separate lower level parsing interface can be used that avoid unnecessary allocation by overwriting one entry. For files with a large number of small entries, this can greatly speed up reading.\n\n\nInstead of looping over a parser stream \nread!\n is called with a preallocated entry.\n\n\nstream\n \n=\n \nopen\n(\ninput.bed\n,\n \nBED\n)\n\n\nentry\n \n=\n \nBEDInterval\n()\n\n\nwhile\n \n!\neof\n(\nstream\n)\n\n    \nread!\n(\ninput\n,\n \nentry\n)\n\n    \n# perform some operation on `entry`\n\n\nend\n\n\n\n\n\n\nSome care is necessary when using this interface. Because \nentry\n is completely overwritten on each iteration, one must manually copy any field from \nentry\n that should be preserved. For example, if we wish to save the \nseqname\n field from \nentry\n when parsing BED, we must call \ncopy(entry.seqname)\n.\n\n\nEmpty entry types that correspond to the file format be found using \neltype\n, making it easy to allocate an empty entry for any parser stream.\n\n\nentry\n \n=\n \neltype\n(\nstream\n)()\n\n\n\n\n\n\n\n\nWriting data\n\n\nWriting data into a stream has a uniform interface consistent with parsers. The following code is a template of formatted serialization into a file:\n\n\n# open a file of a particular file format in writing mode\n\n\nout\n \n=\n \nopen\n(\nfilepath\n,\n \nw\n,\n \nformat\n)\n\n\n# write a record into it\n\n\nwrite\n(\nout\n,\n \nrecord\n)\n\n\n# finally close it\n\n\nclose\n(\nout\n)\n\n\n\n\n\n\nFor example, a FASTA file will be created as follows:\n\n\nout\n \n=\n \nopen\n(\nout.fasta\n,\n \nw\n,\n \nFASTA\n)\n\n\nwrite\n(\nout\n,\n \nFASTASeqRecord\n(\nseq1\n,\n \ndna\nACGTN\n))\n\n\nwrite\n(\nout\n,\n \nFASTASeqRecord\n(\nseq2\n,\n \ndna\nTTATATTATTGTAAA\n,\n \nAT rich\n))\n\n\n# and more records\n\n\nclose\n(\nout\n)\n\n\n\n\n\n\n\n\nSupported file formats\n\n\nThe following table summarizes supported file formats.\n\n\n\n\n\n\n\n\nFile format\n\n\nType parameter\n\n\nModule\n\n\nSpecification\n\n\n\n\n\n\n\n\n\n\nFASTA\n\n\nFASTA\n\n\nBio.Seq\n\n\nhttps://en.wikipedia.org/wiki/FASTA_format\n\n\n\n\n\n\nFASTQ\n\n\nFASTQ\n\n\nBio.Seq\n\n\nhttps://en.wikipedia.org/wiki/FASTQ_format\n\n\n\n\n\n\n.2bit\n\n\nTwoBit\n\n\nBio.Seq\n\n\nhttp://genome.ucsc.edu/FAQ/FAQformat.html#format7\n\n\n\n\n\n\nBED\n\n\nBED\n\n\nBio.Intervals\n\n\nhttps://genome.ucsc.edu/FAQ/FAQformat.html#format1\n\n\n\n\n\n\nbigBed\n\n\nBigBed\n\n\nBio.Intervals\n\n\nhttps://doi.org/10.1093/bioinformatics/btq351\n\n\n\n\n\n\nPDB\n\n\nPDB\n\n\nBio.Structure\n\n\nhttp://www.wwpdb.org/documentation/file-format-content/format33/v3.3.html\n\n\n\n\n\n\n\n\n\n\nFASTA\n\n\n\n\nParser type: \nFASTAParser{S\n:Sequence}\n\n\nWriter type: \nFASTAWriter{T\n:IO}\n\n\nElement type: \nSeqRecord{S,FASTAMetadata}\n (alias: \nFASTASeqRecord{S}\n)\n\n\n\n\nFASTA is a text-based file format for representing biological sequences. A FASTA file stores a list of sequence records with name, description, and sequence. The template of a sequence record is:\n\n\n{name} {description}?\n{sequence}\n\n\n\n\n\nHere is an example of a chromosomal sequence:\n\n\nchrI chromosome 1\nCCACACCACACCCACACACCCACACACCACACCACACACCACACCACACC\nCACACACACACATCCTAACACTACCCTAACACAGCCCTAATCTAACCCTG\n\n\n\n\n\nUsually sequence records will be read sequentially from a file by iteration. But if the FASTA file has an auxiliary index file formatted in \nfai\n, the parser supports random access to FASTA records, which would be useful when accessing specific parts of a huge genome sequence:\n\n\nparser\n \n=\n \nopen\n(\nsacCer.fa\n,\n \nFASTA\n)\n  \n# find and read \nsacCer.fa.fai\n file\n\n\nchrIV\n \n=\n \nparser\n[\nchrIV\n]\n  \n# directly read chromosome 4\n\n\n\n\n\n\n\n\nFASTQ\n\n\n\n\nParser type: \nFASTQParser{S\n:Sequence}\n\n\nWriter type: \nFASTQWriter{T\n:IO}\n\n\nElement type: \nSeqRecord{S,FASTQMetadata}\n (alias: \nFASTQSeqRecord{S}\n)\n\n\n\n\nFASTQ is a text-based file format for representing DNA sequences along with qualities for each base. A FASTQ file stores a list of sequence records in the following format:\n\n\n@{name} {description}?\n{sequence}\n+\n{qualities}\n\n\n\n\n\nHere is an example of one record from a FASTQ file:\n\n\n@FSRRS4401BE7HA\ntcagTTAAGATGGGAT\n+\n###EEEEEEEEE##E#\n\n\n\n\n\nTo parse a file containing such records, one could use:\n\n\nparser\n \n=\n \nopen\n(\nreads.fastq\n,\n \nFASTQ\n,\n \nSeq\n.\nSANGER_QUAL_ENCODING\n)\n\n\nseqrec\n \n=\n \neltype\n(\nparser\n)()\n\n\nwhile\n \n!\neof\n(\nparser\n)\n\n    \nread!\n(\nparser\n,\n \nseqrec\n)\n\n    \n# ... process sequence\n\n\nend\n\n\n\n\n\n\nThis assumes that the quality scores are in \nSanger encoding\n.\n\n\n\n\n.2bit\n\n\n\n\nParser type: \nTwoBitParser{T\n:IO}\n\n\nWriter type: \nTwoBitWriter{T\n:IO}\n\n\nElement type: \nSeqRecord{ReferenceSequence,Vector{UnitRange{Int}}}\n\n\n\n\n.2bit is a binary file format designed for storing a genome consists of multiple chromosomal sequences. The reading speed is often an order of magnitude faster than that of FASTA and the file size is smaller. However, since the .2bit file format is specialized for genomic sequences, it cannot store either RNA or amino acid sequences.\n\n\nLike FASTA, the .2bit parser supports random access using an index included in the header section of a .2bit file:\n\n\nparser\n \n=\n \nopen\n(\nsacCer.2bit\n,\n \nTwoBit\n)\n  \n# parse the header and load a random access index\n\n\nchrIV\n \n=\n \nparser\n[\nchrIV\n]\n  \n# directly read chromosome 4\n\n\n\n\n\n\n\n\nBED\n\n\n\n\nParser type: \nBEDParser\n\n\nWriter type: \nBEDWriter{T\n:IO}\n\n\nElement type: \nInterval{BEDMetadata}\n (alias: \nBEDInterval\n)\n\n\n\n\nBED is a text-based file format for representing genomic annotations like genes, transcripts, and so on. A BED file has tab-delimited and variable-length fields; the first three fields denoting a genomic interval are mandatory.\n\n\nThis is an example of RNA transcripts:\n\n\nchr9    68331023    68424451    NM_015110   0   +\nchr9    68456943    68486659    NM_001206   0   -\n\n\n\n\n\n\n\nbigBed\n\n\nBigBed is a binary file format for representing genomic annotations and often created from BED files. The bigBed files are indexed to quickly fetch specific regions.\n\n\n\n\nPDB\n\n\nPDB is a text-based file format for representing 3D macromolecular structures. This has different parser interfaces from other file formats. Please consult the \nBio.Structure\n chapter for details.", 
            "title": "IO API"
        }, 
        {
            "location": "/man/reading/#reading-and-writing-data", 
            "text": "Bio.jl has a unified interface for reading and writing files in a variety of formats. To initialize a parser for a particular format, the  open  method is extended with a file format type parameter  T :  open { T : FileFormat }( filename :: AbstractString ,   :: Type { T })  open { T : FileFormat }( source :: IO ,   :: Type { T })  open { T : FileFormat }( data :: Vector { UInt8 },   :: Type { T })   For example, when reading a FASTA file, a parser for the FASTA file format can be initialized as:  using   Bio . Seq    # import FASTA  parser   =   open ( hg38.fa ,   FASTA )", 
            "title": "Reading and writing data"
        }, 
        {
            "location": "/man/reading/#parsing-by-iteration", 
            "text": "Parsers in Bio.jl all read and return entries one at a time. The most convenient way to do this by iteration.  stream   =   open ( input.bed ,   BED )  for   entry   in   stream \n     # perform some operation on entry  end", 
            "title": "Parsing by iteration"
        }, 
        {
            "location": "/man/reading/#in-place-parsing", 
            "text": "Iterating through entries in a file is convenient, but for each entry in the file, the parser must allocate, and ultimately the garbage collector must spend time to deallocate it. For performance critical applications, a separate lower level parsing interface can be used that avoid unnecessary allocation by overwriting one entry. For files with a large number of small entries, this can greatly speed up reading.  Instead of looping over a parser stream  read!  is called with a preallocated entry.  stream   =   open ( input.bed ,   BED )  entry   =   BEDInterval ()  while   ! eof ( stream ) \n     read! ( input ,   entry ) \n     # perform some operation on `entry`  end   Some care is necessary when using this interface. Because  entry  is completely overwritten on each iteration, one must manually copy any field from  entry  that should be preserved. For example, if we wish to save the  seqname  field from  entry  when parsing BED, we must call  copy(entry.seqname) .  Empty entry types that correspond to the file format be found using  eltype , making it easy to allocate an empty entry for any parser stream.  entry   =   eltype ( stream )()", 
            "title": "In-place parsing"
        }, 
        {
            "location": "/man/reading/#writing-data", 
            "text": "Writing data into a stream has a uniform interface consistent with parsers. The following code is a template of formatted serialization into a file:  # open a file of a particular file format in writing mode  out   =   open ( filepath ,   w ,   format )  # write a record into it  write ( out ,   record )  # finally close it  close ( out )   For example, a FASTA file will be created as follows:  out   =   open ( out.fasta ,   w ,   FASTA )  write ( out ,   FASTASeqRecord ( seq1 ,   dna ACGTN ))  write ( out ,   FASTASeqRecord ( seq2 ,   dna TTATATTATTGTAAA ,   AT rich ))  # and more records  close ( out )", 
            "title": "Writing data"
        }, 
        {
            "location": "/man/reading/#supported-file-formats", 
            "text": "The following table summarizes supported file formats.     File format  Type parameter  Module  Specification      FASTA  FASTA  Bio.Seq  https://en.wikipedia.org/wiki/FASTA_format    FASTQ  FASTQ  Bio.Seq  https://en.wikipedia.org/wiki/FASTQ_format    .2bit  TwoBit  Bio.Seq  http://genome.ucsc.edu/FAQ/FAQformat.html#format7    BED  BED  Bio.Intervals  https://genome.ucsc.edu/FAQ/FAQformat.html#format1    bigBed  BigBed  Bio.Intervals  https://doi.org/10.1093/bioinformatics/btq351    PDB  PDB  Bio.Structure  http://www.wwpdb.org/documentation/file-format-content/format33/v3.3.html", 
            "title": "Supported file formats"
        }, 
        {
            "location": "/man/reading/#fasta", 
            "text": "Parser type:  FASTAParser{S :Sequence}  Writer type:  FASTAWriter{T :IO}  Element type:  SeqRecord{S,FASTAMetadata}  (alias:  FASTASeqRecord{S} )   FASTA is a text-based file format for representing biological sequences. A FASTA file stores a list of sequence records with name, description, and sequence. The template of a sequence record is:  {name} {description}?\n{sequence}  Here is an example of a chromosomal sequence:  chrI chromosome 1\nCCACACCACACCCACACACCCACACACCACACCACACACCACACCACACC\nCACACACACACATCCTAACACTACCCTAACACAGCCCTAATCTAACCCTG  Usually sequence records will be read sequentially from a file by iteration. But if the FASTA file has an auxiliary index file formatted in  fai , the parser supports random access to FASTA records, which would be useful when accessing specific parts of a huge genome sequence:  parser   =   open ( sacCer.fa ,   FASTA )    # find and read  sacCer.fa.fai  file  chrIV   =   parser [ chrIV ]    # directly read chromosome 4", 
            "title": "FASTA"
        }, 
        {
            "location": "/man/reading/#fastq", 
            "text": "Parser type:  FASTQParser{S :Sequence}  Writer type:  FASTQWriter{T :IO}  Element type:  SeqRecord{S,FASTQMetadata}  (alias:  FASTQSeqRecord{S} )   FASTQ is a text-based file format for representing DNA sequences along with qualities for each base. A FASTQ file stores a list of sequence records in the following format:  @{name} {description}?\n{sequence}\n+\n{qualities}  Here is an example of one record from a FASTQ file:  @FSRRS4401BE7HA\ntcagTTAAGATGGGAT\n+\n###EEEEEEEEE##E#  To parse a file containing such records, one could use:  parser   =   open ( reads.fastq ,   FASTQ ,   Seq . SANGER_QUAL_ENCODING )  seqrec   =   eltype ( parser )()  while   ! eof ( parser ) \n     read! ( parser ,   seqrec ) \n     # ... process sequence  end   This assumes that the quality scores are in  Sanger encoding .", 
            "title": "FASTQ"
        }, 
        {
            "location": "/man/reading/#2bit", 
            "text": "Parser type:  TwoBitParser{T :IO}  Writer type:  TwoBitWriter{T :IO}  Element type:  SeqRecord{ReferenceSequence,Vector{UnitRange{Int}}}   .2bit is a binary file format designed for storing a genome consists of multiple chromosomal sequences. The reading speed is often an order of magnitude faster than that of FASTA and the file size is smaller. However, since the .2bit file format is specialized for genomic sequences, it cannot store either RNA or amino acid sequences.  Like FASTA, the .2bit parser supports random access using an index included in the header section of a .2bit file:  parser   =   open ( sacCer.2bit ,   TwoBit )    # parse the header and load a random access index  chrIV   =   parser [ chrIV ]    # directly read chromosome 4", 
            "title": ".2bit"
        }, 
        {
            "location": "/man/reading/#bed", 
            "text": "Parser type:  BEDParser  Writer type:  BEDWriter{T :IO}  Element type:  Interval{BEDMetadata}  (alias:  BEDInterval )   BED is a text-based file format for representing genomic annotations like genes, transcripts, and so on. A BED file has tab-delimited and variable-length fields; the first three fields denoting a genomic interval are mandatory.  This is an example of RNA transcripts:  chr9    68331023    68424451    NM_015110   0   +\nchr9    68456943    68486659    NM_001206   0   -", 
            "title": "BED"
        }, 
        {
            "location": "/man/reading/#bigbed", 
            "text": "BigBed is a binary file format for representing genomic annotations and often created from BED files. The bigBed files are indexed to quickly fetch specific regions.", 
            "title": "bigBed"
        }, 
        {
            "location": "/man/reading/#pdb", 
            "text": "PDB is a text-based file format for representing 3D macromolecular structures. This has different parser interfaces from other file formats. Please consult the  Bio.Structure  chapter for details.", 
            "title": "PDB"
        }, 
        {
            "location": "/man/seq/", 
            "text": "Bio.Seq: Biological Sequences\n\n\nThe \nBio.Seq\n module provides several data types for handling biological symbols and sequences.\n\n\n\n\nBiological symbols\n\n\nThe \nBio.Seq\n module provides three biological symbol (character) types:\n\n\n\n\n\n\n\n\nType\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nDNANucleotide\n\n\nDNA nucleotide\n\n\n\n\n\n\nRNANucleotide\n\n\nRNA nucleotide\n\n\n\n\n\n\nAminoAcid\n\n\nAmino acid\n\n\n\n\n\n\n\n\nThese symbols can be elements of sequences like characters can be elements of strings.  See sections beginning from \nOverview of sequences types\n section for details.\n\n\n\n\nDNA and RNA nucleotides\n\n\nSet of nucleotide symbols in Bio.jl covers IUPAC nucleotide base plus a gap symbol:\n\n\n\n\n\n\n\n\nSymbol\n\n\nConstant\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n'A'\n\n\nDNA_A\n / \nRNA_A\n\n\nA; Adenine\n\n\n\n\n\n\n'C'\n\n\nDNA_C\n / \nRNA_C\n\n\nC; Cytosine\n\n\n\n\n\n\n'G'\n\n\nDNA_G\n / \nRNA_G\n\n\nG; Guanine\n\n\n\n\n\n\n'T'\n\n\nDNA_T\n\n\nT; Thymine (DNA only)\n\n\n\n\n\n\n'U'\n\n\nRNA_U\n\n\nU; Uracil (RNA only)\n\n\n\n\n\n\n'M'\n\n\nDNA_M\n / \nRNA_M\n\n\nA or C\n\n\n\n\n\n\n'R'\n\n\nDNA_R\n / \nRNA_R\n\n\nA or G\n\n\n\n\n\n\n'W'\n\n\nDNA_W\n / \nRNA_W\n\n\nA or T/U\n\n\n\n\n\n\n'S'\n\n\nDNA_S\n / \nRNA_S\n\n\nC or G\n\n\n\n\n\n\n'Y'\n\n\nDNA_Y\n / \nRNA_Y\n\n\nC or T/U\n\n\n\n\n\n\n'K'\n\n\nDNA_K\n / \nRNA_K\n\n\nG or T/U\n\n\n\n\n\n\n'V'\n\n\nDNA_V\n / \nRNA_V\n\n\nA or C or G; not T/U\n\n\n\n\n\n\n'H'\n\n\nDNA_H\n / \nRNA_H\n\n\nA or C or T; not G\n\n\n\n\n\n\n'D'\n\n\nDNA_D\n / \nRNA_D\n\n\nA or G or T/U; not C\n\n\n\n\n\n\n'B'\n\n\nDNA_B\n / \nRNA_B\n\n\nC or G or T/U; not A\n\n\n\n\n\n\n'N'\n\n\nDNA_N\n / \nRNA_N\n\n\nA or C or G or T/U\n\n\n\n\n\n\n'-'\n\n\nDNA_Gap\n / \nRNA_Gap\n\n\nGap (none of the above)\n\n\n\n\n\n\n\n\nhttp://www.insdc.org/documents/feature_table.html#7.4.1\n\n\nSymbols are accessible as constants with \nDNA_\n or \nRNA_\n prefix:\n\n\njulia\n \nDNA_A\n\n\nDNA_A\n\n\n\njulia\n \nDNA_T\n\n\nDNA_T\n\n\n\njulia\n \nRNA_U\n\n\nRNA_U\n\n\n\njulia\n \nDNA_Gap\n\n\nDNA_Gap\n\n\n\njulia\n \ntypeof\n(\nDNA_A\n)\n\n\nBio.Seq.DNANucleotide\n\n\n\njulia\n \ntypeof\n(\nRNA_A\n)\n\n\nBio.Seq.RNANucleotide\n\n\n\n\n\n\nSymbols can be constructed by converting regular characters:\n\n\njulia\n \nconvert\n(\nDNANucleotide\n,\n \nC\n)\n\n\nDNA_C\n\n\n\njulia\n \nconvert\n(\nDNANucleotide\n,\n \nC\n)\n \n===\n \nDNA_C\n\n\ntrue\n\n\n\n\n\n\n\n\nAmino acids\n\n\nSet of amino acid symbols also covers IUPAC amino acid symbols plus a gap symbol:\n\n\n\n\n\n\n\n\nSymbol\n\n\nConstant\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n'A'\n\n\nAA_A\n\n\nAlanine\n\n\n\n\n\n\n'R'\n\n\nAA_R\n\n\nArginine\n\n\n\n\n\n\n'N'\n\n\nAA_N\n\n\nAsparagine\n\n\n\n\n\n\n'D'\n\n\nAA_D\n\n\nAspartic acid (Aspartate)\n\n\n\n\n\n\n'C'\n\n\nAA_C\n\n\nCysteine\n\n\n\n\n\n\n'Q'\n\n\nAA_Q\n\n\nGlutamine\n\n\n\n\n\n\n'E'\n\n\nAA_E\n\n\nGlutamic acid (Glutamate)\n\n\n\n\n\n\n'G'\n\n\nAA_G\n\n\nGlycine\n\n\n\n\n\n\n'H'\n\n\nAA_H\n\n\nHistidine\n\n\n\n\n\n\n'I'\n\n\nAA_I\n\n\nIsoleucine\n\n\n\n\n\n\n'L'\n\n\nAA_L\n\n\nLeucine\n\n\n\n\n\n\n'K'\n\n\nAA_K\n\n\nLysine\n\n\n\n\n\n\n'M'\n\n\nAA_M\n\n\nMethionine\n\n\n\n\n\n\n'F'\n\n\nAA_F\n\n\nPhenylalanine\n\n\n\n\n\n\n'P'\n\n\nAA_P\n\n\nProline\n\n\n\n\n\n\n'S'\n\n\nAA_S\n\n\nSerine\n\n\n\n\n\n\n'T'\n\n\nAA_T\n\n\nThreonine\n\n\n\n\n\n\n'W'\n\n\nAA_W\n\n\nTryptophan\n\n\n\n\n\n\n'Y'\n\n\nAA_Y\n\n\nTyrosine\n\n\n\n\n\n\n'V'\n\n\nAA_V\n\n\nValine\n\n\n\n\n\n\n'O'\n\n\nAA_O\n\n\nPyrrolysine\n\n\n\n\n\n\n'U'\n\n\nAA_U\n\n\nSelenocysteine\n\n\n\n\n\n\n'B'\n\n\nAA_B\n\n\nAspartic acid or Asparagine\n\n\n\n\n\n\n'J'\n\n\nAA_J\n\n\nLeucine or Isoleucine\n\n\n\n\n\n\n'Z'\n\n\nAA_Z\n\n\nGlutamine or Glutamic acid\n\n\n\n\n\n\n'X'\n\n\nAA_X\n\n\nAny amino acid\n\n\n\n\n\n\n'*'\n\n\nAA_Term\n\n\nTermination codon\n\n\n\n\n\n\n'-'\n\n\nAA_Gap\n\n\nGap (none of the above)\n\n\n\n\n\n\n\n\nhttp://www.insdc.org/documents/feature_table.html#7.4.3\n\n\nSymbols are accessible as constants with \nAA_\n prefix:\n\n\njulia\n \nAA_A\n\n\nAA_A\n\n\n\njulia\n \nAA_Q\n\n\nAA_Q\n\n\n\njulia\n \nAA_Term\n\n\nAA_Term\n\n\n\njulia\n \ntypeof\n(\nAA_A\n)\n\n\nBio.Seq.AminoAcid\n\n\n\n\n\n\nSymbols can be constructed by converting regular characters:\n\n\njulia\n \nconvert\n(\nAminoAcid\n,\n \nA\n)\n\n\nAA_A\n\n\n\njulia\n \nconvert\n(\nAminoAcid\n,\n \nP\n)\n \n===\n \nAA_P\n\n\ntrue\n\n\n\n\n\n\n\n\nOther functions\n\n\n#\n\n\nBio.Seq.alphabet\n \n \nFunction\n.\n\n\nalphabet(typ)\n\n\n\n\n\nReturn an iterator of symbols of \ntyp\n.\n\n\ntyp\n is one of \nDNANucleotide\n, \nRNANucleotide\n, or \nAminoAcid\n.\n\n\nsource\n\n\n#\n\n\nBio.Seq.gap\n \n \nFunction\n.\n\n\ngap(typ)\n\n\n\n\n\nReturn the gap symbol of \ntyp\n.\n\n\ntyp\n is one of \nDNANucleotide\n, \nRNANucleotide\n, \nAminoAcid\n, or \nChar\n.\n\n\nsource\n\n\n#\n\n\nBio.Seq.iscompatible\n \n \nFunction\n.\n\n\niscompatible(x, y)\n\n\n\n\n\nReturn \ntrue\n if and only if \nx\n and \ny\n are compatible with each other (i.e. \nx\n and \ny\n can be the same symbol).\n\n\nx\n and \ny\n must be the same type (\nDNANucleotide\n, \nRNANucleotide\n or \nAminoAcid\n).\n\n\nExamples\n\n\njulia\n \niscompatible\n(\nDNA_A\n,\n \nDNA_A\n)\n\n\ntrue\n\n\n\njulia\n \niscompatible\n(\nDNA_C\n,\n \nDNA_N\n)\n  \n# DNA_N can be DNA_C\n\n\ntrue\n\n\n\njulia\n \niscompatible\n(\nDNA_C\n,\n \nDNA_R\n)\n  \n# DNA_R (A or G) cannot be DNA_C\n\n\nfalse\n\n\n\njulia\n \niscompatible\n(\nAA_A\n,\n \nAA_X\n)\n    \n# AA_X can be AA_A\n\n\ntrue\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBio.Seq.isambiguous\n \n \nFunction\n.\n\n\nisambiguous(nt::Nucleotide)\n\n\n\n\n\nTest if \nnt\n is ambiguous nucleotide.\n\n\nsource\n\n\n\n\nOverview of sequences types\n\n\nThe \nBio.Seq\n module provides representations and tools for manipulating nucleotide and amino acid sequences. Sequences in Bio.jl are more strictly typed than in many other libraries; elements in a sequence are typed as biological symbol instead of character or byte.  They are special purpose types rather than simply strings and hence offer additional functionality that naive string types don't have. Though this strictness sacrifices some convenience, it also means you can always rely on a DNA sequence type to store DNA and nothing but DNA, without having to check, or deal with lowercase versus uppercase and so on. Strict separation of sequence types also means we are free to choose the most efficient representation. DNA and RNA sequences are encoded using four bits per base by default making them memory efficient, and also allowing us to speed up many common operations like nucleotide composition, reverse complement, and \nk\n-mer enumeration.\n\n\nThe \nBio.Seq\n provides three different sequence types: \nBioSequence\n, \nKmer\n and \nReferenceSequence\n. Each of these types is a subtype of an abstract type called \nSequence\n and supports various string-like operations such as random access and iteration. Different sequence types have different features. In most situations, \nBioSequence\n type will do and is used as the default representation. But sometimes other types are much more preferable in terms of memory efficiency and computation performance.  Here is the summary table of these three types:\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nElement type\n\n\nMutability\n\n\nAllocation\n\n\n\n\n\n\n\n\n\n\nBioSequence{A\n:Alphabet}\n\n\ngeneral-purpose biological sequences\n\n\nDNA, RNA, Amino acids\n\n\nmutable\n\n\nheap\n\n\n\n\n\n\nKmer{T\n:Nucleotide,k}\n\n\nspecialized for short nucleotide sequences\n\n\nDNA, RNA\n\n\nimmutable\n\n\nstack / register\n\n\n\n\n\n\nReferenceSequence\n\n\nspecialized for long reference genomes\n\n\nDNA\n\n\nimmutable\n\n\nheap\n\n\n\n\n\n\n\n\nDetails of these different representations are explained in the following sections:\n\n\n\n\nBioSequence\n: \nGeneral-purpose sequences\n\n\nKmer\n: \nNucleotide k-mers\n\n\nReferenceSequence\n: \nReference sequences\n\n\n\n\n\n\nGeneral-purpose sequences\n\n\nBioSequence{A}\n is a generic sequence type parameterized by an alphabet type \nA\n that defines the domain (or set) of biological symbols, and each alphabet has an associated symbol type. For example, \nAminoAcidAlphabet\n is associated with \nAminoAcid\n and hence an object of the \nBioSequence{AminoAcidAlphabet}\n type represents a sequence of amino acids.  Symbols from multiple alphabets can't be intermixed in one sequence type.\n\n\nThe following table summarizes common sequence types that are defined in the \nBio.Seq\n module:\n\n\n\n\n\n\n\n\nType\n\n\nSymbol type\n\n\nType alias\n\n\n\n\n\n\n\n\n\n\nBioSequence{DNAAlphabet{4}}\n\n\nDNANucleotide\n\n\nDNASequence\n\n\n\n\n\n\nBioSequence{RNAAlphabet{4}}\n\n\nRNANucleotide\n\n\nRNASequence\n\n\n\n\n\n\nBioSequence{AminoAcidAlphabet}\n\n\nAminoAcid\n\n\nAminoAcidSequence\n\n\n\n\n\n\nBioSequence{CharAlphabet}\n\n\nChar\n\n\nCharSequence\n\n\n\n\n\n\n\n\nParameterized definition of the \nBioSequence{A}\n type is for the purpose of unifying the data structure and operations of any symbol type. In most cases, users don't have to care about it and can use type aliases listed above. However, the alphabet type fixes the internal memory encoding and plays an important role when optimizing performance of a program (see \nCompact representation\n section for low-memory encodings).  It also enables a user to define their own alphabet only by defining few numbers of methods. This is described in \nDefining a new alphabet\n section.\n\n\n\n\nConstructing sequences\n\n\nSequence types corresponding to these alphabets can be constructed a number of different ways. Most immediately, sequence literals can be constructed using the string macros \ndna\n, \nrna\n, \naa\n, and \nchar\n:\n\n\n# String decorators are provided for common sequence types\n\n\njulia\n \ndna\nTACGTANNATC\n\n\n11nt DNA Sequence:\n\n\nTACGTANNATC\n\n\n\njulia\n \nrna\nAUUUGNCCANU\n\n\n11nt RNA Sequence:\n\n\nAUUUGNCCANU\n\n\n\njulia\n \naa\nARNDCQEGHILKMFPSTWYVX\n\n\n21aa Amino Acid Sequence:\n\n\nARNDCQEGHILKMFPSTWYVX\n\n\n\njulia\n \nchar\n\u03b1\u03b2\u03b3\u03b4\u03f5\n\n\n5char Char Sequence:\n\n\n\u03b1\u03b2\u03b3\u03b4\u03f5\n\n\n\n\n\n\nSequence can also be constructed from strings or arrays of nucleotide or amino acid symbols using constructors or the \nconvert\n function:\n\n\njulia\n \nDNASequence\n(\nTTANC\n)\n\n\n5nt DNA Sequence:\n\n\nTTANC\n\n\n\njulia\n \nDNASequence\n([\nDNA_T\n,\n \nDNA_T\n,\n \nDNA_A\n,\n \nDNA_N\n,\n \nDNA_C\n])\n\n\n5nt DNA Sequence:\n\n\nTTANC\n\n\n\njulia\n \nconvert\n(\nDNASequence\n,\n \n[\nDNA_T\n,\n \nDNA_T\n,\n \nDNA_A\n,\n \nDNA_N\n,\n \nDNA_C\n])\n\n\n5nt DNA Sequence:\n\n\nTTANC\n\n\n\n\n\n\nUsing \nconvert\n, these operations are reversible: sequences can be converted to strings or arrays:\n\n\njulia\n \nconvert\n(\nASCIIString\n,\n \ndna\nTTANGTA\n)\n\n\nTTANGTA\n\n\n\njulia\n \nconvert\n(\nVector\n{\nDNANucleotide\n},\n \ndna\nTTANGTA\n)\n\n\n7-element Array{Bio.Seq.DNANucleotide,1}:\n\n\n DNA_T\n\n\n DNA_T\n\n\n DNA_A\n\n\n DNA_N\n\n\n DNA_G\n\n\n DNA_T\n\n\n DNA_A\n\n\n\n\n\n\nSequences can also be concatenated into longer sequences:\n\n\njulia\n \nDNASequence\n(\ndna\nACGT\n,\n \ndna\nNNNN\n,\n \ndna\nTGCA\n)\n\n\n12nt DNA Sequence:\n\n\nACGTNNNNTGCA\n\n\n\njulia\n \ndna\nACGT\n \n*\n \ndna\nTGCA\n\n\n8nt DNA Sequence:\n\n\nACGTTGCA\n\n\n\njulia\n \nrepeat\n(\ndna\nTA\n,\n \n10\n)\n\n\n20nt DNA Sequence:\n\n\nTATATATATATATATATATA\n\n\n\njulia\n \ndna\nTA\n \n^\n \n10\n\n\n20nt DNA Sequence:\n\n\nTATATATATATATATATATA\n\n\n\n\n\n\nDespite being separate types, \nDNASequence\n and \nRNASequence\n can freely be converted between efficiently without copying the underlying data:\n\n\njulia\n \ndna\n \n=\n \ndna\nTTANGTAGACCG\n\n\n12nt DNA Sequence:\n\n\nTTANGTAGACCG\n\n\n\njulia\n \nrna\n \n=\n \nconvert\n(\nRNASequence\n,\n \ndna\n)\n\n\n12nt RNA Sequence:\n\n\nUUANGUAGACCG\n\n\n\njulia\n \ndna\n.\ndata\n \n===\n \nrna\n.\ndata\n  \n# underlying data are same\n\n\ntrue\n\n\n\n\n\n\nA random sequence can be obtained by the \nranddnaseq\n, \nrandrnaseq\n and \nrandaaseq\n functions, which generate \nDNASequence\n, \nRNASequence\n and \nAminoAcidSequence\n, respectively. Generated sequences are composed of the standard symbols without ambiguity and gap. For example, \nranddnaseq(6)\n may generate \ndna\"TCATAG\"\n but never generates \ndna\"TNANAG\"\n or \ndna\"T-ATAG\"\n.\n\n\nA translatable \nRNASequence\n can also be converted to an \nAminoAcidSequence\n using the \ntranslate\n function described below.\n\n\n\n\nIndexing and modifying\n\n\nSequences for the most part behave like other vector or string types. They can be indexed using integers or ranges:\n\n\njulia\n \nseq\n \n=\n \ndna\nACGTTTANAGTNNAGTACC\n\n\n19nt DNA Sequence:\n\n\nACGTTTANAGTNNAGTACC\n\n\n\njulia\n \nseq\n[\n5\n]\n\n\nDNA_T\n\n\n\njulia\n \nseq\n[\n6\n:\nend\n]\n\n\n14nt DNA Sequence:\n\n\nTANAGTNNAGTACC\n\n\n\n\n\n\nIndexing by range creates a subsequence of the original sequence. Unlike \nVector\n in the standard library, creating a subsequences is copy-free: a subsequence is just a reference to the original sequence with its range.  You may think that this is unsafe because modifying subsequences propagates to the original sequence, but this doesn't happen actually:\n\n\njulia\n \nseq\n \n=\n \ndna\nAAAA\n    \n# create a sequence\n\n\n4nt DNA Sequence:\n\n\nAAAA\n\n\n\njulia\n \nsubseq\n \n=\n \nseq\n[\n1\n:\n2\n]\n  \n# create a subsequence from `seq`\n\n\n2nt DNA Sequence:\n\n\nAA\n\n\n\njulia\n \nsubseq\n[\n2\n]\n \n=\n \nDNA_T\n  \n# modify the second element of it\n\n\nDNA_T\n\n\n\njulia\n \nsubseq\n             \n# the subsequence is modified\n\n\n2nt DNA Sequence:\n\n\nAT\n\n\n\njulia\n \nseq\n                \n# but the original sequence is not\n\n\n4nt DNA Sequence:\n\n\nAAAA\n\n\n\n\n\n\nThis is because modifying a sequence checks whether its underlying data are shared with other sequences under the hood. If and only if the data are shared, the subsequence creates a copy of itself. Any modifying operation does this check. This is called \ncopy-on-write\n strategy and users don't need to care about it because it is transparent from outward.\n\n\nThe following modifying operations are currently supported:\n\n\nsetindex!\n(\nseq\n,\n \nitem\n,\n \nindex\n)\n\n\npush!\n(\nseq\n,\n \nitem\n)\n\n\npop!\n(\nseq\n)\n\n\nshift!\n(\nseq\n)\n\n\nunshift!\n(\nseq\n,\n \nitem\n)\n\n\ninsert!\n(\nseq\n,\n \nindex\n,\n \nitem\n)\n\n\ndeleteat!\n(\nseq\n,\n \nindex\n)\n\n\nappend!\n(\nseq\n,\n \nother_seq\n)\n\n\ncopy!\n(\ndst_seq\n,\n \ndest_offset\n,\n \nsrc_seq\n,\n \nsrc_offset\n,\n \nlen\n)\n\n\nreverse!\n(\nseq\n)\n\n\n\n\n\n\ncomplement!(seq)\nreverse_complement!(seq)\n\n\n\n\n\njulia\n \nseq\n \n=\n \ndna\nACG\n\n\n3nt DNA Sequence:\n\n\nACG\n\n\n\njulia\n \npush!\n(\nseq\n,\n \nDNA_T\n)\n\n\n4nt DNA Sequence:\n\n\nACGT\n\n\n\njulia\n \nappend!\n(\nseq\n,\n \ndna\nAT\n)\n\n\n6nt DNA Sequence:\n\n\nACGTAT\n\n\n\njulia\n \nreverse!\n(\nseq\n)\n\n\n6nt DNA Sequence:\n\n\nTATGCA\n\n\n\njulia\n \nSeq\n.\ncomplement!\n(\nseq\n)\n  \n# semantically differs from Base.complement!\n\n\n6nt DNA Sequence:\n\n\nATACGT\n\n\n\njulia\n \nreverse_complement!\n(\nseq\n)\n\n\n6nt DNA Sequence:\n\n\nACGTAT\n\n\n\n\n\n\nSequences also work as iterators over symbols:\n\n\njulia\n \nn\n \n=\n \n0\n\n\n0\n\n\n\njulia\n \nfor\n \nnt\n \nin\n \ndna\nATNGNNT\n\n\n\n           if nt == DNA_N\n\n\n\n               n += 1\n\n\n\n           end\n\n\n\n       end\n\n\n\njulia\n \nn\n\n\n3\n\n\n\n\n\n\n\n\nOther operations on sequences\n\n\nA number of common sequence operations are provided in the \nBio.Seq\n module:\n\n\n#\n\n\nBio.Seq.complement\n \n \nFunction\n.\n\n\ncomplement(nt::Nucleotide)\n\n\n\n\n\nReturn the complementary nucleotide of \nnt\n.\n\n\nsource\n\n\ncomplement(seq)\n\n\n\n\n\nMake a complement sequence of \nseq\n.\n\n\nAmbiguous nucleotides are left as-is.\n\n\nsource\n\n\ncomplement(kmer::Kmer)\n\n\n\n\n\nReturn the complement of \nkmer\n.\n\n\nsource\n\n\n#\n\n\nBio.Seq.reverse_complement\n \n \nFunction\n.\n\n\nreverse_complement(seq)\n\n\n\n\n\nMake a reversed complement sequence of \nseq\n.\n\n\nAmbiguous nucleotides are left as-is.\n\n\nsource\n\n\nreverse_complement(kmer::Kmer)\n\n\n\n\n\nReturn the reverse complement of \nkmer\n\n\nsource\n\n\n#\n\n\nBio.Seq.mismatches\n \n \nFunction\n.\n\n\nmismatches(seq1::BioSequence, seq2::BioSequence[, compatible=false])\n\n\n\n\n\nReturn the number of mismatches between \nseq1\n and \nseq2\n.\n\n\nIf \nseq1\n and \nseq2\n are of differing lengths, only the first \nmin(length(seq1), length(seq2))\n nucleotides are compared.  When \ncompatible\n is \ntrue\n, sequence symbols are comapred using \niscompatible\n; otherwise using \n==\n.\n\n\nsource\n\n\nmismatches(a::Kmer, b::Kmer)\n\n\n\n\n\nReturn the number of mismatches between \na\n and \nb\n.\n\n\nsource\n\n\n#\n\n\nBio.Seq.composition\n \n \nFunction\n.\n\n\ncomposition(seq | kmer_iter)\n\n\n\n\n\nCalculate composition of biological symbols in \nseq\n or k-mers in \nkmer_iter\n.\n\n\nsource\n\n\n#\n\n\nBio.Seq.seqmatrix\n \n \nFunction\n.\n\n\nseqmatrix{A\n:Alphabet}(vseq::Vector{BioSequence{A}}, major::Symbol)\n\n\n\n\n\nConstruct a matrix of nucleotides or amino acids from a vector of \nBioSequence\ns.\n\n\nIf parameter major is set to \n:site\n, the matrix is created such that one nucleotide from each sequence is placed in each column i.e. the matrix is laid out in site-major order. This means that iteration over one position of many sequences is efficient, as julia arrays are laid out in column major order.\n\n\nIf the parameter major is set to \n:seq\n, the matrix is created such that each sequence is placed in one column i.e. the matrix is laid out in sequence-major order. This means that iteration over each sequence is efficient, as julia arrays are laid out in column major order.\n\n\nExamples\n\n\njulia\n \nseqs\n \n=\n \n[\ndna\nAAA\n,\n \ndna\nTTT\n,\n \ndna\nCCC\n,\n \ndna\nGGG\n]\n\n\n4\n-\nelement\n \nArray\n{\nBio\n.\nSeq\n.\nBioSequence\n{\nBio\n.\nSeq\n.\nDNAAlphabet\n{\n4\n}},\n1\n}:\n\n \n3\nnt\n \nDNA\n \nSequence\n:\n\n\nAAA\n\n \n3\nnt\n \nDNA\n \nSequence\n:\n\n\nTTT\n\n \n3\nnt\n \nDNA\n \nSequence\n:\n\n\nCCC\n\n \n3\nnt\n \nDNA\n \nSequence\n:\n\n\nGGG\n\n\n\njulia\n \nseqmatrix\n(\nseqs\n,\n \n:\nsite\n)\n\n\n4\nx3\n \nArray\n{\nBio\n.\nSeq\n.\nDNANucleotide\n,\n2\n}:\n\n \nDNA_A\n  \nDNA_A\n  \nDNA_A\n\n \nDNA_T\n  \nDNA_T\n  \nDNA_T\n\n \nDNA_C\n  \nDNA_C\n  \nDNA_C\n\n \nDNA_G\n  \nDNA_G\n  \nDNA_G\n\n\n \njulia\n \nseqmatrix\n(\nseqs\n,\n \n:\nseq\n)\n\n \n3\nx4\n \nArray\n{\nBio\n.\nSeq\n.\nDNANucleotide\n,\n2\n}:\n\n  \nDNA_A\n  \nDNA_T\n  \nDNA_C\n  \nDNA_G\n\n  \nDNA_A\n  \nDNA_T\n  \nDNA_C\n  \nDNA_G\n\n  \nDNA_A\n  \nDNA_T\n  \nDNA_C\n  \nDNA_G\n\n\n\n\n\n\nsource\n\n\n\n\nTranslation\n\n\nThe \ntranslate\n funtion translates a sequence of codons in a RNA sequence to a amino acid sequence besed on a genetic code mapping.  The \nBio.Seq\n module contains all NCBI defined genetic codes and they are registered in \nncbi_trans_table\n.\n\n\n#\n\n\nBio.Seq.translate\n \n \nFunction\n.\n\n\ntranslate(rna_seq, code=standard_genetic_code, allow_ambiguous_codons=true)\n\n\n\n\n\nTranslate an \nRNASequence\n to an \nAminoAcidSequence\n.\n\n\nTranslation uses genetic code \ncode\n to map codons to amino acids. See \nncbi_trans_table\n for available genetic codes. If codons in the given RNA sequence cannot determine a unique amino acid, they will be translated to \nAA_X\n if \nallow_ambiguous_codons\n is \ntrue\n and otherwise result in an error.\n\n\nsource\n\n\n#\n\n\nBio.Seq.ncbi_trans_table\n \n \nConstant\n.\n\n\nGenetic code list of NCBI.\n\n\nThe standard genetic code is \nncbi_trans_table[1]\n and others can be shown by \nshow(ncbi_trans_table)\n. For more details, consult the next link: http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes.\n\n\nsource\n\n\njulia\n \nncbi_trans_table\n\n\nTranslation Tables:\n\n\n  1. The Standard Code (standard_genetic_code)\n\n\n  2. The Vertebrate Mitochondrial Code (vertebrate_mitochondrial_genetic_code)\n\n\n  3. The Yeast Mitochondrial Code (yeast_mitochondrial_genetic_code)\n\n\n  4. The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code (mold_mitochondrial_genetic_code)\n\n\n  5. The Invertebrate Mitochondrial Code (invertebrate_mitochondrial_genetic_code)\n\n\n  6. The Ciliate, Dasycladacean and Hexamita Nuclear Code (ciliate_nuclear_genetic_code)\n\n\n  9. The Echinoderm and Flatworm Mitochondrial Code (echinoderm_mitochondrial_genetic_code)\n\n\n 10. The Euplotid Nuclear Code (euplotid_nuclear_genetic_code)\n\n\n 11. The Bacterial, Archaeal and Plant Plastid Code (bacterial_plastid_genetic_code)\n\n\n 12. The Alternative Yeast Nuclear Code (alternative_yeast_nuclear_genetic_code)\n\n\n 13. The Ascidian Mitochondrial Code (ascidian_mitochondrial_genetic_code)\n\n\n 14. The Alternative Flatworm Mitochondrial Code (alternative_flatworm_mitochondrial_genetic_code)\n\n\n 16. Chlorophycean Mitochondrial Code (chlorophycean_mitochondrial_genetic_code)\n\n\n 21. Trematode Mitochondrial Code (trematode_mitochondrial_genetic_code)\n\n\n 22. Scenedesmus obliquus Mitochondrial Code (scenedesmus_obliquus_mitochondrial_genetic_code)\n\n\n 23. Thraustochytrium Mitochondrial Code (thraustochytrium_mitochondrial_genetic_code)\n\n\n 24. Pterobranchia Mitochondrial Code (pterobrachia_mitochondrial_genetic_code)\n\n\n 25. Candidate Division SR1 and Gracilibacteria Code (candidate_division_sr1_genetic_code)\n\n\n\n\n\n\nhttp://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes\n\n\n\n\nCompact representation\n\n\nAs we saw above, DNA and RNA sequences can store any ambiguous nucleotides like 'N'.  If you are sure that nucleotide sequences store unambiguous nucleotides only, you can save the memory space of sequences. \nDNAAlphabet{2}\n is an alphabet that uses two bits per base and limits to only unambiguous nucleotide symbols (ACGT in DNA and ACGU in RNA). To create a sequence of this alphabet, you need to explicitly pass \nDNAAlphabet{2}\n to \nBioSequence\n as its parametric type:\n\n\njulia\n \nseq\n \n=\n \nBioSequence\n{\nDNAAlphabet\n{\n2\n}}(\nACGT\n)\n\n\n4nt DNA Sequence:\n\n\nACGT\n\n\n\n\n\n\nRecall that \nDNASequence\n is a type alias of \nBioSequence{DNAAlphabet{4}}\n, which uses four bits per base. That is, \nBioSequence{DNAAlphabet{2}}\n saves half of memory footprint compared to \nBioSequence{DNAAlphabet{4}}\n. If you need to handle reference genomes that are composed of five nucleotides, ACGTN, consider to use the \nReferenceSequence\n type described in the \nReference sequences\n section.\n\n\n\n\nDefining a new alphabet\n\n\nThe alphabet type parameter \nA\n of \nBioSequence{A}\n enables a user to extend functionality of \nBioSequence\n with mimimum effort. As an example, definition of a new alphabet type representing a sequence of boolean values is shown below:\n\n\nusing\n \nBio\n.\nSeq\n\n\n\nimmutable\n \nBoolAlphabet\n \n:\n \nAlphabet\n \nend\n\n\n\nSeq\n.\nbitsof\n(::\nType\n{\nBoolAlphabet\n})\n \n=\n \n1\n\n\nSeq\n.\neltype\n(::\nType\n{\nBoolAlphabet\n})\n \n=\n \nBool\n\n\nSeq\n.\nalphabet\n(::\nType\n{\nBoolAlphabet\n})\n \n=\n \nfalse\n:\ntrue\n\n\n\nfunction\n Seq\n.\nencode\n(::\nType\n{\nBoolAlphabet\n},\n \nx\n::\nBool\n)\n\n    \nreturn\n \nUInt64\n(\nifelse\n(\nx\n,\n \n0x01\n,\n \n0x00\n))\n\n\nend\n\n\n\nfunction\n Seq\n.\ndecode\n(::\nType\n{\nBoolAlphabet\n},\n \nx\n::\nUInt64\n)\n\n    \nif\n \nx\n \n \n0x01\n\n        \nthrow\n(\nSeq\n.\nDecodeError\n(\nBoolAlphabet\n,\n \nx\n))\n\n    \nend\n\n    \nreturn\n \nifelse\n(\nx\n \n==\n \n0x00\n,\n \nfalse\n,\n \ntrue\n)\n\n\nend\n\n\n\n\n\n\n\n\nNucleotide k-mers\n\n\nA common strategy to simplify the analysis of sequence data is to operate or short k-mers, for size fixed size \nk\n. These can be packed into machine integers allowing extremely efficient code. The \nBio.Seq\n module has built in support for representing short sequences in 64-bit integers. Besides being fixed length, \nKmer\n types, unlike other sequence types cannot contain ambiguous symbols like 'N'.\n\n\nThe \nKmer{T,k}\n type parameterized on symbol type (\nT\n, either \nDNANucleotide\n, or \nRNANucleotide\n) and size \nk\n. For ease of writing code, two type aliases for each nucleotide type are defined and named as \nDNAKmer{k}\n and \nRNAKmer{k}\n:\n\n\njulia\n \nDNAKmer\n(\nACGT\n)\n  \n# create a DNA 4-mer from a string\n\n\nDNA 4-mer:\n\n\nACGT\n\n\n\njulia\n \nRNAKmer\n(\nACGU\n)\n  \n# create an RNA 4-mer from a string\n\n\nRNA 4-mer:\n\n\nACGU\n\n\n\njulia\n \ntypeof\n(\nDNAKmer\n(\nACGT\n))\n\n\nBio.Seq.Kmer{Bio.Seq.DNANucleotide,4}\n\n\n\n\n\n\n#\n\n\nBio.Seq.each\n \n \nFunction\n.\n\n\neach(::Type{Kmer{T,k}}, seq::Sequence[, step=1])\n\n\n\n\n\nInitialize an iterator over all k-mers in a sequence \nseq\n skipping ambiguous nucleotides without changing the reading frame.\n\n\nArguments\n\n\n\n\nKmer{T,k}\n: k-mer type to enumerate.\n\n\nseq\n: a nucleotide sequence.\n\n\nstep=1\n: the number of positions between iterated k-mers\n\n\n\n\nExamples\n\n\n# iterate over DNA codons\nfor (pos, codon) in each(DNAKmer{3}, dna\nATCCTANAGNTACT\n, 3)\n    @show pos, codon\nend\n\n\n\n\n\nsource\n\n\n#\n\n\nBio.Seq.canonical\n \n \nFunction\n.\n\n\ncanonical(kmer::Kmer)\n\n\n\n\n\nReturn the canonical k-mer of \nx\n.\n\n\nA canonical k-mer is the numerical lesser of a k-mer and its reverse complement. This is useful in hashing/counting k-mers in data that is not strand specific, and thus observing k-mer is equivalent to observing its reverse complement.\n\n\nsource\n\n\n#\n\n\nBio.Seq.neighbors\n \n \nFunction\n.\n\n\nneighbors(kmer::Kmer)\n\n\n\n\n\nReturn an iterator through k-mers neighboring \nkmer\n on a de Bruijn graph.\n\n\nsource\n\n\n\n\nReference sequences\n\n\nDNASequence\n (alias of \nBioSequence{DNAAlphabet{4}}\n) is a flexible data sturcture but always consumes 4 bits per base, which will waste a large part of the memory space when storing reference genome sequences.  In such a case, \nReferenceSequence\n is helpful because it compresses positions of 'N' symbols so that long DNA sequences are stored with almost 2 bits per base. An important limitation is that the \nReferenceSequence\n type is immutable due to the compression. Other sequence-like operations are supported:\n\n\njulia\n \nseq\n \n=\n \nReferenceSequence\n(\ndna\nNNCGTATTTTCN\n)\n\n\n12nt Reference Sequence:\n\n\nNNCGTATTTTCN\n\n\n\njulia\n \nseq\n[\n1\n]\n\n\nDNA_N\n\n\n\njulia\n \nseq\n[\n5\n]\n\n\nDNA_T\n\n\n\njulia\n \nseq\n[\n2\n:\n6\n]\n\n\n5nt Reference Sequence:\n\n\nNCGTA\n\n\n\njulia\n \nReferenceSequence\n(\ndna\nATGM\n)\n  \n# DNA_M is not accepted\n\n\nERROR: ArgumentError: invalid symbol M \u2209 {A,C,G,T,N} at 4\n\n\n in convert at /Users/kenta/.julia/v0.4/Bio/src/seq/refseq.jl:58\n\n\n in call at essentials.jl:56\n\n\n\n\n\n\nWhen reading reference sequences from a FASTA file, the following snippet will avoid allocating temporary sequences and conversion:\n\n\nfor\n \nrecord\n \nin\n \nopen\n(\nhg38.fa\n,\n \nFASTA\n,\n \nReferenceSequence\n)\n\n    \n# do something\n\n\nend\n\n\n\n\n\n\n\n\nSequence search\n\n\nThree kinds of on-line search functions are provided:\n\n\n\n\nExact search\n\n\nApproximate search\n\n\nRegular expression search\n\n\n\n\nThese are all specialized for biological sequences and ambiguities of symbols are considered.\n\n\n\n\nExact search\n\n\nExact search functions search for an occurrence of the query symbol or sequence. Four functions, \nsearch\n, \nsearchindex\n, \nrsearch\n, and \nrsearchindex\n are available:\n\n\njulia\n \nseq\n \n=\n \ndna\nACAGCGTAGCT\n;\n\n\n\njulia\n \nsearch\n(\nseq\n,\n \nDNA_G\n)\n  \n# search a query symbol\n\n\n4:4\n\n\n\njulia\n \nquery\n \n=\n \ndna\nAGC\n;\n\n\n\njulia\n \nsearch\n(\nseq\n,\n \nquery\n)\n  \n# search a query sequence\n\n\n3:5\n\n\n\njulia\n \nsearchindex\n(\nseq\n,\n \nquery\n)\n\n\n3\n\n\n\njulia\n \nrsearch\n(\nseq\n,\n \nquery\n)\n  \n# similar to `search` but in the reverse direction\n\n\n8:10\n\n\n\njulia\n \nrsearchindex\n(\nseq\n,\n \nquery\n)\n  \n# similar to `searchindex` but in the reverse direction\n\n\n8\n\n\n\n\n\n\nThese search functions take ambiguous symbols into account. That is, if two symbols are compatible (e.g. \nDNA_A\n and \nDNA_N\n), they match when searching an occurrence. In the following example, 'N' is a wild card that matches any symbols:\n\n\njulia\n \nsearch\n(\ndna\nACNT\n,\n \nDNA_N\n)\n  \n# \nA\n matches \nN\n\n\n1:1\n\n\n\njulia\n \nsearch\n(\ndna\nACNT\n,\n \ndna\nCGT\n)\n  \n# \nN\n matches \nG\n\n\n2:4\n\n\n\njulia\n \nsearch\n(\ndna\nACGT\n,\n \ndna\nCNT\n)\n  \n# \nG\n matches \nN\n\n\n2:4\n\n\n\n\n\n\nThe exact sequence search needs preprocessing phase of query sequence before searching phase. This would be enough fast for most search applications. But when searching a query sequence to large amounts of target sequences, caching the result of preprocessing may save time. The \nExactSearchQuery\n creates such a preprocessed query object and is applicable to the search functions:\n\n\njulia\n \nquery\n \n=\n \nExactSearchQuery\n(\ndna\nATT\n);\n\n\n\njulia\n \nsearch\n(\ndna\nATTTATT\n,\n \nquery\n)\n\n\n1:3\n\n\n\njulia\n \nrsearch\n(\ndna\nATTTATT\n,\n \nquery\n)\n\n\n5:7\n\n\n\n\n\n\n\n\nApproximate search\n\n\nThe approximate search is similar to the exact search but allows a specific number of errors. That is, it tries to find a subsequence of the target sequence within a specific \nLevenshtein distance\n of the query sequence:\n\n\njulia\n \nseq\n \n=\n \ndna\nACAGCGTAGCT\n;\n\n\n\njulia\n \napproxsearch\n(\nseq\n,\n \ndna\nAGGG\n,\n \n0\n)\n  \n# nothing matches with no errors\n\n\n0:-1\n\n\n\njulia\n \napproxsearch\n(\nseq\n,\n \ndna\nAGGG\n,\n \n1\n)\n  \n# seq[3:5] matches with one error\n\n\n3:6\n\n\n\njulia\n \napproxsearch\n(\nseq\n,\n \ndna\nAGGG\n,\n \n2\n)\n  \n# seq[1:4] matches with two errors\n\n\n1:4\n\n\n\n\n\n\nLike the exact search functions, four kinds of functions (\napproxsearch\n, \napproxsearchindex\n, \napproxrsearch\n, and \napproxrsearchindex\n) are available:\n\n\njulia\n \nseq\n \n=\n \ndna\nACAGCGTAGCT\n;\n \npat\n \n=\n \ndna\nAGGG\n;\n\n\n\njulia\n \napproxsearch\n(\nseq\n,\n \npat\n,\n \n2\n)\n        \n# return the range (forward)\n\n\n1:4\n\n\n\njulia\n \napproxsearchindex\n(\nseq\n,\n \npat\n,\n \n2\n)\n   \n# return the starting index (forward)\n\n\n1\n\n\n\njulia\n \napproxrsearch\n(\nseq\n,\n \npat\n,\n \n2\n)\n       \n# return the range (backward)\n\n\n8:11\n\n\n\njulia\n \napproxrsearchindex\n(\nseq\n,\n \npat\n,\n \n2\n)\n  \n# return the starting index (backward)\n\n\n8\n\n\n\n\n\n\nPreprocessing can be cached in an \nApproximateSearchQuery\n object:\n\n\njulia\n \nquery\n \n=\n \nApproximateSearchQuery\n(\ndna\nAGGG\n);\n\n\n\njulia\n \napproxsearch\n(\ndna\nAAGAGG\n,\n \nquery\n,\n \n1\n)\n\n\n2:5\n\n\n\njulia\n \napproxsearch\n(\ndna\nACTACGT\n,\n \nquery\n,\n \n2\n)\n\n\n4:6\n\n\n\n\n\n\n\n\nRegular expression search\n\n\nQuery patterns can be described in regular expressions. The syntax supports a subset of Perl and PROSITE's notation.\n\n\nThe Perl-like syntax starts with \nbiore\n (\nbio\nlogical \nre\ngular expression) and ends with a symbol option: \"dna\", \"rna\" or \"aa\". For example, \nbiore\"A+\"dna\n is a regular expression for DNA sequences and \nbiore\"A+\"aa\n is for amino acid sequences. The symbol options can be abbreviated to its first character: \"d\", \"r\" or \"a\", respectively.\n\n\nHere are examples of using the regular expression for \nBioSequence\ns:\n\n\njulia\n \nmatch\n(\nbiore\nA+C*\ndna\n,\n \ndna\nAAAACC\n)\n\n\nNullable(RegexMatch(\nAAAACC\n))\n\n\n\njulia\n \nmatch\n(\nbiore\nA+C*\nd\n,\n \ndna\nAAAACC\n)\n\n\nNullable(RegexMatch(\nAAAACC\n))\n\n\n\njulia\n \nismatch\n(\nbiore\nA+C*\ndna\n,\n \ndna\nAAC\n)\n\n\ntrue\n\n\n\njulia\n \nismatch\n(\nbiore\nA+C*\ndna\n,\n \ndna\nC\n)\n\n\nfalse\n\n\n\n\n\n\nmatch\n always returns a \nNullable\n object and it should be null if no match is found.\n\n\nThe table below summarizes available syntax elements.\n\n\n\n\n\n\n\n\nSyntax\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n\\|\n\n\nalternation\n\n\n\"A\\|T\"\n matches \n\"A\"\n and \n\"T\"\n\n\n\n\n\n\n*\n\n\nzero or more times repeat\n\n\n\"TA*\"\n matches \n\"T\"\n, \n\"TA\"\n and \n\"TAA\"\n\n\n\n\n\n\n+\n\n\none or more times repeat\n\n\n\"TA+\"\n matches \n\"TA\"\n and \n\"TAA\"\n\n\n\n\n\n\n?\n\n\nzero or one time\n\n\n\"TA?\"\n matches \n\"T\"\n and \n\"TA\"\n\n\n\n\n\n\n{n,}\n\n\nn\n or more times repeat\n\n\n\"A{3,}\"\n matches \n\"AAA\"\n and \n\"AAAA\"\n\n\n\n\n\n\n{n,m}\n\n\nn\n-\nm\n times repeat\n\n\n\"A{3,5}\"\n matches \n\"AAA\"\n, \n\"AAAA\"\n and \n\"AAAAA\"\n\n\n\n\n\n\n^\n\n\nthe start of the sequence\n\n\n\"^TAN*\"\n matches \n\"TATGT\"\n\n\n\n\n\n\n$\n\n\nthe end of the sequence\n\n\n\"N*TA$\"\n matches \n\"GCTA\"\n\n\n\n\n\n\n(...)\n\n\npattern grouping\n\n\n\"(TA)+\"\n matches \n\"TA\"\n and \n\"TATA\"\n\n\n\n\n\n\n[...]\n\n\none of symbols\n\n\n\"[ACG]+\"\n matches \n\"AGGC\"\n\n\n\n\n\n\n\n\neachmatch\n, \nmatchall\n, and \nsearch\n are also defined like usual strings:\n\n\njulia\n \nmatchall\n(\nbiore\nTATA*?\nd\n,\n \ndna\nTATTATAATTA\n)\n  \n# overlap (default)\n\n\n4-element Array{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},1}:\n\n\n 3nt DNA Sequence:\n\n\nTAT\n\n\n 3nt DNA Sequence:\n\n\nTAT\n\n\n 4nt DNA Sequence:\n\n\nTATA\n\n\n 5nt DNA Sequence:\n\n\nTATAA\n\n\n\njulia\n \nmatchall\n(\nbiore\nTATA*\nd\n,\n \ndna\nTATTATAATTA\n,\n \nfalse\n)\n  \n# no overlap\n\n\n2-element Array{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},1}:\n\n\n 3nt DNA Sequence:\n\n\nTAT\n\n\n 5nt DNA Sequence:\n\n\nTATAA\n\n\n\njulia\n \nsearch\n(\ndna\nTATTATAATTA\n,\n \nbiore\nTATA*\nd\n)\n\n\n1:3\n\n\n\njulia\n \nsearch\n(\ndna\nTATTATAATTA\n,\n \nbiore\nTATA*\nd\n,\n \n2\n)\n\n\n4:8\n\n\n\n\n\n\nNotewothy differences from strings are:\n\n\n\n\nAmbiguous characters match any compatible characters (e.g. \nbiore\"N\"d\n is equivalent to \nbiore\"[ACGT]\"d\n).\n\n\nWhitespaces are ignored (e.g. \nbiore\"A C G\"d\n is equivalent to \nbiore\"ACG\"d\n).\n\n\n\n\nThe PROSITE notation is described in \nScanProsite - user manual\n. The syntax supports almost all notations including the extended syntax. The PROSITE notation starts with \nprosite\n prefix and no symbol option is needed because it always descirbe patterns of amino acid sequences:\n\n\njulia\n \nmatch\n(\nprosite\n[AC]-x-V-x(4)-{ED}\n,\n \naa\nCPVPQARG\n)\n\n\nNullable(RegexMatch(\nCPVPQARG\n))\n\n\n\njulia\n \nmatch\n(\nprosite\n[AC]xVx(4){ED}\n,\n \naa\nCPVPQARG\n)\n\n\nNullable(RegexMatch(\nCPVPQARG\n))\n\n\n\n\n\n\n\n\nSequence composition\n\n\nSequence composition can be easily calculated using the \ncomposition\n function:\n\n\njulia\n \ncomp\n \n=\n \ncomposition\n(\ndna\nACGAG\n)\n\n\nDNA Nucleotide Composition:\n\n\n  DNA_A   =\n 2\n\n\n  DNA_C   =\n 1\n\n\n  DNA_G   =\n 2\n\n\n  DNA_T   =\n 0\n\n\n  DNA_M   =\n 0\n\n\n  DNA_R   =\n 0\n\n\n  DNA_W   =\n 0\n\n\n  DNA_S   =\n 0\n\n\n  DNA_Y   =\n 0\n\n\n  DNA_K   =\n 0\n\n\n  DNA_V   =\n 0\n\n\n  DNA_H   =\n 0\n\n\n  DNA_D   =\n 0\n\n\n  DNA_B   =\n 0\n\n\n  DNA_N   =\n 0\n\n\n  DNA_Gap =\n 0\n\n\n\njulia\n \ncomp\n[\nDNA_A\n]\n\n\n2\n\n\n\njulia\n \ncomp\n[\nDNA_T\n]\n\n\n0\n\n\n\n\n\n\nTo accumulate composition statistics of multiple sequences, \nmerge!\n can be used as follows:\n\n\n# initiaize an empty composition counter\n\n\ncomp\n \n=\n \ncomposition\n(\ndna\n)\n\n\n\n# iterate over sequences and accumulate composition statistics into `comp`\n\n\nfor\n \nseq\n \nin\n \nseqs\n\n    \nmerge!\n(\ncomp\n,\n \ncomposition\n(\nseq\n))\n\n\nend\n\n\n\n# or functional programming style in one line\n\n\nfoldl\n((\nx\n,\n \ny\n)\n \n-\n \nmerge\n(\nx\n,\n \ncomposition\n(\ny\n)),\n \ncomposition\n(\ndna\n),\n \nseqs\n)\n\n\n\n\n\n\ncomposition\n is also applicable to a \nk\n-mer iterator:\n\n\njulia\n \ncomp\n \n=\n \ncomposition\n(\neach\n(\nDNAKmer\n{\n4\n},\n \ndna\nACGT\n^\n100\n));\n\n\n\njulia\n \ncomp\n[\nDNAKmer\n(\nACGT\n)]\n\n\n100\n\n\n\njulia\n \ncomp\n[\nDNAKmer\n(\nCGTA\n)]\n\n\n99\n\n\n\n\n\n\n\n\nSequence records\n\n\nThe \nSeqRecord\n type is used to represent a named sequence, optionally with accompanying metadata. It is defined as: sequence. It is as:\n\n\ntype\n SeqRecord\n{\nS\n,\n \nT\n}\n\n    \nname\n::\nString\n\n    \nseq\n::\nS\n\n    \nmetadata\n::\nT\n\n\nend\n\n\n\n\n\n\nThe type of the \nmetadata\n field depends on the source of the sequence record. For example, if a record is read from a FASTA file, metadata contains the description field. If from a FASTQ file, a quality scores assigned to base calls during sequencing.\n\n\n\n\nSequence demultiplexing\n\n\nMultiplex sequencing is a technology to sequence mutliple samples at the same time on a high-throughput DNA sequencer. Samples are distinguished by the short prefix of a DNA sequence called DNA barcode. The \nBio.Seq\n offers the \nDemultiplexer\n type and the \ndemultiplex\n function to identify the DNA barcode of a longer DNA sequence allowing small errors.\n\n\nIn the following example, four kinds of DNA sequences of length 4 are used as DNA barcodes. \nDemultiplexer\n takes these barcodes as its first argument with a few options:\n\n\njulia\n \nbarcodes\n \n=\n \nDNASequence\n[\nATGG\n,\n \nCAGA\n,\n \nGGAA\n,\n \nTACG\n];\n\n\n\njulia\n \ndplxr\n \n=\n \nDemultiplexer\n(\nbarcodes\n,\n \nn_max_errors\n=\n1\n,\n \ndistance\n=\n:\nhamming\n)\n\n\nBio.Seq.Demultiplexer{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:\n\n\n  distance: hamming\n\n\n  number of barcodes: 4\n\n\n  number of correctable errors: 1\n\n\n\n\n\n\nn_max_errors\n specifies the number of maximum correctable errors in a barcode. The type of correctable errors depends on the \ndistance\n parameter. When \ndistance = :hamming\n as shown above only substitutions are correctable. When \ndistance = :levenshtein\n substitutions, deletions, and insertions are correctable. The user is responsible for keeping enough distances among barcodes; \nDemultiplexer\n will throw an exception if two barcodes are within \nn_max_errors * 2\n.\n\n\nThe \ndemultiplex\n function takes a demultiplexer object and a DNA sequence, and returns a tuple of a barcode index and a distance between the original barcode sequence and the prefix sequence:\n\n\njulia\n \ndemultiplex\n(\ndplxr\n,\n \ndna\nATGGCGNT\n)\n  \n# 1st barcode with no errors\n\n\n(1,0)\n\n\n\njulia\n \ndemultiplex\n(\ndplxr\n,\n \ndna\nCAGGCGNT\n)\n  \n# 2nd barcode with one error\n\n\n(2,1)\n\n\n\njulia\n \ndemultiplex\n(\ndplxr\n,\n \ndna\nGGAACGNT\n)\n  \n# 3rd barcode with no errors\n\n\n(3,0)\n\n\n\njulia\n \ndemultiplex\n(\ndplxr\n,\n \ndna\nTGACCGNT\n)\n  \n# no matching barcode\n\n\n(0,-1)\n\n\n\n\n\n\nThe optional third argument controls the search strategy. \ndemultiplex\n uses an index to search the closest barcode within \nn_max_errors\n in the barcode set and returns it if any by default. If the third argument is \ntrue\n it falls back to a linear search after the index search and returns one of the closest barcodes at random. The next example shows the difference of these two strategies:\n\n\njulia\n \ndemultiplex\n(\ndplxr\n,\n \ndna\nTGACCGNT\n,\n \nfalse\n)\n  \n# linear search off (default)\n\n\n(0,-1)\n\n\n\njulia\n \ndemultiplex\n(\ndplxr\n,\n \ndna\nTGACCGNT\n,\n \ntrue\n)\n   \n# linear search on\n\n\n(3,2)", 
            "title": "Biological Sequences"
        }, 
        {
            "location": "/man/seq/#bioseq-biological-sequences", 
            "text": "The  Bio.Seq  module provides several data types for handling biological symbols and sequences.", 
            "title": "Bio.Seq: Biological Sequences"
        }, 
        {
            "location": "/man/seq/#biological-symbols", 
            "text": "The  Bio.Seq  module provides three biological symbol (character) types:     Type  Meaning      DNANucleotide  DNA nucleotide    RNANucleotide  RNA nucleotide    AminoAcid  Amino acid     These symbols can be elements of sequences like characters can be elements of strings.  See sections beginning from  Overview of sequences types  section for details.", 
            "title": "Biological symbols"
        }, 
        {
            "location": "/man/seq/#dna-and-rna-nucleotides", 
            "text": "Set of nucleotide symbols in Bio.jl covers IUPAC nucleotide base plus a gap symbol:     Symbol  Constant  Meaning      'A'  DNA_A  /  RNA_A  A; Adenine    'C'  DNA_C  /  RNA_C  C; Cytosine    'G'  DNA_G  /  RNA_G  G; Guanine    'T'  DNA_T  T; Thymine (DNA only)    'U'  RNA_U  U; Uracil (RNA only)    'M'  DNA_M  /  RNA_M  A or C    'R'  DNA_R  /  RNA_R  A or G    'W'  DNA_W  /  RNA_W  A or T/U    'S'  DNA_S  /  RNA_S  C or G    'Y'  DNA_Y  /  RNA_Y  C or T/U    'K'  DNA_K  /  RNA_K  G or T/U    'V'  DNA_V  /  RNA_V  A or C or G; not T/U    'H'  DNA_H  /  RNA_H  A or C or T; not G    'D'  DNA_D  /  RNA_D  A or G or T/U; not C    'B'  DNA_B  /  RNA_B  C or G or T/U; not A    'N'  DNA_N  /  RNA_N  A or C or G or T/U    '-'  DNA_Gap  /  RNA_Gap  Gap (none of the above)     http://www.insdc.org/documents/feature_table.html#7.4.1  Symbols are accessible as constants with  DNA_  or  RNA_  prefix:  julia   DNA_A  DNA_A  julia   DNA_T  DNA_T  julia   RNA_U  RNA_U  julia   DNA_Gap  DNA_Gap  julia   typeof ( DNA_A )  Bio.Seq.DNANucleotide  julia   typeof ( RNA_A )  Bio.Seq.RNANucleotide   Symbols can be constructed by converting regular characters:  julia   convert ( DNANucleotide ,   C )  DNA_C  julia   convert ( DNANucleotide ,   C )   ===   DNA_C  true", 
            "title": "DNA and RNA nucleotides"
        }, 
        {
            "location": "/man/seq/#amino-acids", 
            "text": "Set of amino acid symbols also covers IUPAC amino acid symbols plus a gap symbol:     Symbol  Constant  Meaning      'A'  AA_A  Alanine    'R'  AA_R  Arginine    'N'  AA_N  Asparagine    'D'  AA_D  Aspartic acid (Aspartate)    'C'  AA_C  Cysteine    'Q'  AA_Q  Glutamine    'E'  AA_E  Glutamic acid (Glutamate)    'G'  AA_G  Glycine    'H'  AA_H  Histidine    'I'  AA_I  Isoleucine    'L'  AA_L  Leucine    'K'  AA_K  Lysine    'M'  AA_M  Methionine    'F'  AA_F  Phenylalanine    'P'  AA_P  Proline    'S'  AA_S  Serine    'T'  AA_T  Threonine    'W'  AA_W  Tryptophan    'Y'  AA_Y  Tyrosine    'V'  AA_V  Valine    'O'  AA_O  Pyrrolysine    'U'  AA_U  Selenocysteine    'B'  AA_B  Aspartic acid or Asparagine    'J'  AA_J  Leucine or Isoleucine    'Z'  AA_Z  Glutamine or Glutamic acid    'X'  AA_X  Any amino acid    '*'  AA_Term  Termination codon    '-'  AA_Gap  Gap (none of the above)     http://www.insdc.org/documents/feature_table.html#7.4.3  Symbols are accessible as constants with  AA_  prefix:  julia   AA_A  AA_A  julia   AA_Q  AA_Q  julia   AA_Term  AA_Term  julia   typeof ( AA_A )  Bio.Seq.AminoAcid   Symbols can be constructed by converting regular characters:  julia   convert ( AminoAcid ,   A )  AA_A  julia   convert ( AminoAcid ,   P )   ===   AA_P  true", 
            "title": "Amino acids"
        }, 
        {
            "location": "/man/seq/#other-functions", 
            "text": "#  Bio.Seq.alphabet     Function .  alphabet(typ)  Return an iterator of symbols of  typ .  typ  is one of  DNANucleotide ,  RNANucleotide , or  AminoAcid .  source  #  Bio.Seq.gap     Function .  gap(typ)  Return the gap symbol of  typ .  typ  is one of  DNANucleotide ,  RNANucleotide ,  AminoAcid , or  Char .  source  #  Bio.Seq.iscompatible     Function .  iscompatible(x, y)  Return  true  if and only if  x  and  y  are compatible with each other (i.e.  x  and  y  can be the same symbol).  x  and  y  must be the same type ( DNANucleotide ,  RNANucleotide  or  AminoAcid ).  Examples  julia   iscompatible ( DNA_A ,   DNA_A )  true  julia   iscompatible ( DNA_C ,   DNA_N )    # DNA_N can be DNA_C  true  julia   iscompatible ( DNA_C ,   DNA_R )    # DNA_R (A or G) cannot be DNA_C  false  julia   iscompatible ( AA_A ,   AA_X )      # AA_X can be AA_A  true   source  #  Bio.Seq.isambiguous     Function .  isambiguous(nt::Nucleotide)  Test if  nt  is ambiguous nucleotide.  source", 
            "title": "Other functions"
        }, 
        {
            "location": "/man/seq/#overview-of-sequences-types", 
            "text": "The  Bio.Seq  module provides representations and tools for manipulating nucleotide and amino acid sequences. Sequences in Bio.jl are more strictly typed than in many other libraries; elements in a sequence are typed as biological symbol instead of character or byte.  They are special purpose types rather than simply strings and hence offer additional functionality that naive string types don't have. Though this strictness sacrifices some convenience, it also means you can always rely on a DNA sequence type to store DNA and nothing but DNA, without having to check, or deal with lowercase versus uppercase and so on. Strict separation of sequence types also means we are free to choose the most efficient representation. DNA and RNA sequences are encoded using four bits per base by default making them memory efficient, and also allowing us to speed up many common operations like nucleotide composition, reverse complement, and  k -mer enumeration.  The  Bio.Seq  provides three different sequence types:  BioSequence ,  Kmer  and  ReferenceSequence . Each of these types is a subtype of an abstract type called  Sequence  and supports various string-like operations such as random access and iteration. Different sequence types have different features. In most situations,  BioSequence  type will do and is used as the default representation. But sometimes other types are much more preferable in terms of memory efficiency and computation performance.  Here is the summary table of these three types:     Type  Description  Element type  Mutability  Allocation      BioSequence{A :Alphabet}  general-purpose biological sequences  DNA, RNA, Amino acids  mutable  heap    Kmer{T :Nucleotide,k}  specialized for short nucleotide sequences  DNA, RNA  immutable  stack / register    ReferenceSequence  specialized for long reference genomes  DNA  immutable  heap     Details of these different representations are explained in the following sections:   BioSequence :  General-purpose sequences  Kmer :  Nucleotide k-mers  ReferenceSequence :  Reference sequences", 
            "title": "Overview of sequences types"
        }, 
        {
            "location": "/man/seq/#general-purpose-sequences", 
            "text": "BioSequence{A}  is a generic sequence type parameterized by an alphabet type  A  that defines the domain (or set) of biological symbols, and each alphabet has an associated symbol type. For example,  AminoAcidAlphabet  is associated with  AminoAcid  and hence an object of the  BioSequence{AminoAcidAlphabet}  type represents a sequence of amino acids.  Symbols from multiple alphabets can't be intermixed in one sequence type.  The following table summarizes common sequence types that are defined in the  Bio.Seq  module:     Type  Symbol type  Type alias      BioSequence{DNAAlphabet{4}}  DNANucleotide  DNASequence    BioSequence{RNAAlphabet{4}}  RNANucleotide  RNASequence    BioSequence{AminoAcidAlphabet}  AminoAcid  AminoAcidSequence    BioSequence{CharAlphabet}  Char  CharSequence     Parameterized definition of the  BioSequence{A}  type is for the purpose of unifying the data structure and operations of any symbol type. In most cases, users don't have to care about it and can use type aliases listed above. However, the alphabet type fixes the internal memory encoding and plays an important role when optimizing performance of a program (see  Compact representation  section for low-memory encodings).  It also enables a user to define their own alphabet only by defining few numbers of methods. This is described in  Defining a new alphabet  section.", 
            "title": "General-purpose sequences"
        }, 
        {
            "location": "/man/seq/#constructing-sequences", 
            "text": "Sequence types corresponding to these alphabets can be constructed a number of different ways. Most immediately, sequence literals can be constructed using the string macros  dna ,  rna ,  aa , and  char :  # String decorators are provided for common sequence types  julia   dna TACGTANNATC  11nt DNA Sequence:  TACGTANNATC  julia   rna AUUUGNCCANU  11nt RNA Sequence:  AUUUGNCCANU  julia   aa ARNDCQEGHILKMFPSTWYVX  21aa Amino Acid Sequence:  ARNDCQEGHILKMFPSTWYVX  julia   char \u03b1\u03b2\u03b3\u03b4\u03f5  5char Char Sequence:  \u03b1\u03b2\u03b3\u03b4\u03f5   Sequence can also be constructed from strings or arrays of nucleotide or amino acid symbols using constructors or the  convert  function:  julia   DNASequence ( TTANC )  5nt DNA Sequence:  TTANC  julia   DNASequence ([ DNA_T ,   DNA_T ,   DNA_A ,   DNA_N ,   DNA_C ])  5nt DNA Sequence:  TTANC  julia   convert ( DNASequence ,   [ DNA_T ,   DNA_T ,   DNA_A ,   DNA_N ,   DNA_C ])  5nt DNA Sequence:  TTANC   Using  convert , these operations are reversible: sequences can be converted to strings or arrays:  julia   convert ( ASCIIString ,   dna TTANGTA )  TTANGTA  julia   convert ( Vector { DNANucleotide },   dna TTANGTA )  7-element Array{Bio.Seq.DNANucleotide,1}:   DNA_T   DNA_T   DNA_A   DNA_N   DNA_G   DNA_T   DNA_A   Sequences can also be concatenated into longer sequences:  julia   DNASequence ( dna ACGT ,   dna NNNN ,   dna TGCA )  12nt DNA Sequence:  ACGTNNNNTGCA  julia   dna ACGT   *   dna TGCA  8nt DNA Sequence:  ACGTTGCA  julia   repeat ( dna TA ,   10 )  20nt DNA Sequence:  TATATATATATATATATATA  julia   dna TA   ^   10  20nt DNA Sequence:  TATATATATATATATATATA   Despite being separate types,  DNASequence  and  RNASequence  can freely be converted between efficiently without copying the underlying data:  julia   dna   =   dna TTANGTAGACCG  12nt DNA Sequence:  TTANGTAGACCG  julia   rna   =   convert ( RNASequence ,   dna )  12nt RNA Sequence:  UUANGUAGACCG  julia   dna . data   ===   rna . data    # underlying data are same  true   A random sequence can be obtained by the  randdnaseq ,  randrnaseq  and  randaaseq  functions, which generate  DNASequence ,  RNASequence  and  AminoAcidSequence , respectively. Generated sequences are composed of the standard symbols without ambiguity and gap. For example,  randdnaseq(6)  may generate  dna\"TCATAG\"  but never generates  dna\"TNANAG\"  or  dna\"T-ATAG\" .  A translatable  RNASequence  can also be converted to an  AminoAcidSequence  using the  translate  function described below.", 
            "title": "Constructing sequences"
        }, 
        {
            "location": "/man/seq/#indexing-and-modifying", 
            "text": "Sequences for the most part behave like other vector or string types. They can be indexed using integers or ranges:  julia   seq   =   dna ACGTTTANAGTNNAGTACC  19nt DNA Sequence:  ACGTTTANAGTNNAGTACC  julia   seq [ 5 ]  DNA_T  julia   seq [ 6 : end ]  14nt DNA Sequence:  TANAGTNNAGTACC   Indexing by range creates a subsequence of the original sequence. Unlike  Vector  in the standard library, creating a subsequences is copy-free: a subsequence is just a reference to the original sequence with its range.  You may think that this is unsafe because modifying subsequences propagates to the original sequence, but this doesn't happen actually:  julia   seq   =   dna AAAA      # create a sequence  4nt DNA Sequence:  AAAA  julia   subseq   =   seq [ 1 : 2 ]    # create a subsequence from `seq`  2nt DNA Sequence:  AA  julia   subseq [ 2 ]   =   DNA_T    # modify the second element of it  DNA_T  julia   subseq               # the subsequence is modified  2nt DNA Sequence:  AT  julia   seq                  # but the original sequence is not  4nt DNA Sequence:  AAAA   This is because modifying a sequence checks whether its underlying data are shared with other sequences under the hood. If and only if the data are shared, the subsequence creates a copy of itself. Any modifying operation does this check. This is called  copy-on-write  strategy and users don't need to care about it because it is transparent from outward.  The following modifying operations are currently supported:  setindex! ( seq ,   item ,   index )  push! ( seq ,   item )  pop! ( seq )  shift! ( seq )  unshift! ( seq ,   item )  insert! ( seq ,   index ,   item )  deleteat! ( seq ,   index )  append! ( seq ,   other_seq )  copy! ( dst_seq ,   dest_offset ,   src_seq ,   src_offset ,   len )  reverse! ( seq )   complement!(seq)\nreverse_complement!(seq)  julia   seq   =   dna ACG  3nt DNA Sequence:  ACG  julia   push! ( seq ,   DNA_T )  4nt DNA Sequence:  ACGT  julia   append! ( seq ,   dna AT )  6nt DNA Sequence:  ACGTAT  julia   reverse! ( seq )  6nt DNA Sequence:  TATGCA  julia   Seq . complement! ( seq )    # semantically differs from Base.complement!  6nt DNA Sequence:  ATACGT  julia   reverse_complement! ( seq )  6nt DNA Sequence:  ACGTAT   Sequences also work as iterators over symbols:  julia   n   =   0  0  julia   for   nt   in   dna ATNGNNT             if nt == DNA_N                 n += 1             end         end  julia   n  3", 
            "title": "Indexing and modifying"
        }, 
        {
            "location": "/man/seq/#other-operations-on-sequences", 
            "text": "A number of common sequence operations are provided in the  Bio.Seq  module:  #  Bio.Seq.complement     Function .  complement(nt::Nucleotide)  Return the complementary nucleotide of  nt .  source  complement(seq)  Make a complement sequence of  seq .  Ambiguous nucleotides are left as-is.  source  complement(kmer::Kmer)  Return the complement of  kmer .  source  #  Bio.Seq.reverse_complement     Function .  reverse_complement(seq)  Make a reversed complement sequence of  seq .  Ambiguous nucleotides are left as-is.  source  reverse_complement(kmer::Kmer)  Return the reverse complement of  kmer  source  #  Bio.Seq.mismatches     Function .  mismatches(seq1::BioSequence, seq2::BioSequence[, compatible=false])  Return the number of mismatches between  seq1  and  seq2 .  If  seq1  and  seq2  are of differing lengths, only the first  min(length(seq1), length(seq2))  nucleotides are compared.  When  compatible  is  true , sequence symbols are comapred using  iscompatible ; otherwise using  == .  source  mismatches(a::Kmer, b::Kmer)  Return the number of mismatches between  a  and  b .  source  #  Bio.Seq.composition     Function .  composition(seq | kmer_iter)  Calculate composition of biological symbols in  seq  or k-mers in  kmer_iter .  source  #  Bio.Seq.seqmatrix     Function .  seqmatrix{A :Alphabet}(vseq::Vector{BioSequence{A}}, major::Symbol)  Construct a matrix of nucleotides or amino acids from a vector of  BioSequence s.  If parameter major is set to  :site , the matrix is created such that one nucleotide from each sequence is placed in each column i.e. the matrix is laid out in site-major order. This means that iteration over one position of many sequences is efficient, as julia arrays are laid out in column major order.  If the parameter major is set to  :seq , the matrix is created such that each sequence is placed in one column i.e. the matrix is laid out in sequence-major order. This means that iteration over each sequence is efficient, as julia arrays are laid out in column major order.  Examples  julia   seqs   =   [ dna AAA ,   dna TTT ,   dna CCC ,   dna GGG ]  4 - element   Array { Bio . Seq . BioSequence { Bio . Seq . DNAAlphabet { 4 }}, 1 }: \n  3 nt   DNA   Sequence :  AAA \n  3 nt   DNA   Sequence :  TTT \n  3 nt   DNA   Sequence :  CCC \n  3 nt   DNA   Sequence :  GGG  julia   seqmatrix ( seqs ,   : site )  4 x3   Array { Bio . Seq . DNANucleotide , 2 }: \n  DNA_A    DNA_A    DNA_A \n  DNA_T    DNA_T    DNA_T \n  DNA_C    DNA_C    DNA_C \n  DNA_G    DNA_G    DNA_G \n\n  julia   seqmatrix ( seqs ,   : seq ) \n  3 x4   Array { Bio . Seq . DNANucleotide , 2 }: \n   DNA_A    DNA_T    DNA_C    DNA_G \n   DNA_A    DNA_T    DNA_C    DNA_G \n   DNA_A    DNA_T    DNA_C    DNA_G   source", 
            "title": "Other operations on sequences"
        }, 
        {
            "location": "/man/seq/#translation", 
            "text": "The  translate  funtion translates a sequence of codons in a RNA sequence to a amino acid sequence besed on a genetic code mapping.  The  Bio.Seq  module contains all NCBI defined genetic codes and they are registered in  ncbi_trans_table .  #  Bio.Seq.translate     Function .  translate(rna_seq, code=standard_genetic_code, allow_ambiguous_codons=true)  Translate an  RNASequence  to an  AminoAcidSequence .  Translation uses genetic code  code  to map codons to amino acids. See  ncbi_trans_table  for available genetic codes. If codons in the given RNA sequence cannot determine a unique amino acid, they will be translated to  AA_X  if  allow_ambiguous_codons  is  true  and otherwise result in an error.  source  #  Bio.Seq.ncbi_trans_table     Constant .  Genetic code list of NCBI.  The standard genetic code is  ncbi_trans_table[1]  and others can be shown by  show(ncbi_trans_table) . For more details, consult the next link: http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes.  source  julia   ncbi_trans_table  Translation Tables:    1. The Standard Code (standard_genetic_code)    2. The Vertebrate Mitochondrial Code (vertebrate_mitochondrial_genetic_code)    3. The Yeast Mitochondrial Code (yeast_mitochondrial_genetic_code)    4. The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code (mold_mitochondrial_genetic_code)    5. The Invertebrate Mitochondrial Code (invertebrate_mitochondrial_genetic_code)    6. The Ciliate, Dasycladacean and Hexamita Nuclear Code (ciliate_nuclear_genetic_code)    9. The Echinoderm and Flatworm Mitochondrial Code (echinoderm_mitochondrial_genetic_code)   10. The Euplotid Nuclear Code (euplotid_nuclear_genetic_code)   11. The Bacterial, Archaeal and Plant Plastid Code (bacterial_plastid_genetic_code)   12. The Alternative Yeast Nuclear Code (alternative_yeast_nuclear_genetic_code)   13. The Ascidian Mitochondrial Code (ascidian_mitochondrial_genetic_code)   14. The Alternative Flatworm Mitochondrial Code (alternative_flatworm_mitochondrial_genetic_code)   16. Chlorophycean Mitochondrial Code (chlorophycean_mitochondrial_genetic_code)   21. Trematode Mitochondrial Code (trematode_mitochondrial_genetic_code)   22. Scenedesmus obliquus Mitochondrial Code (scenedesmus_obliquus_mitochondrial_genetic_code)   23. Thraustochytrium Mitochondrial Code (thraustochytrium_mitochondrial_genetic_code)   24. Pterobranchia Mitochondrial Code (pterobrachia_mitochondrial_genetic_code)   25. Candidate Division SR1 and Gracilibacteria Code (candidate_division_sr1_genetic_code)   http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes", 
            "title": "Translation"
        }, 
        {
            "location": "/man/seq/#compact-representation", 
            "text": "As we saw above, DNA and RNA sequences can store any ambiguous nucleotides like 'N'.  If you are sure that nucleotide sequences store unambiguous nucleotides only, you can save the memory space of sequences.  DNAAlphabet{2}  is an alphabet that uses two bits per base and limits to only unambiguous nucleotide symbols (ACGT in DNA and ACGU in RNA). To create a sequence of this alphabet, you need to explicitly pass  DNAAlphabet{2}  to  BioSequence  as its parametric type:  julia   seq   =   BioSequence { DNAAlphabet { 2 }}( ACGT )  4nt DNA Sequence:  ACGT   Recall that  DNASequence  is a type alias of  BioSequence{DNAAlphabet{4}} , which uses four bits per base. That is,  BioSequence{DNAAlphabet{2}}  saves half of memory footprint compared to  BioSequence{DNAAlphabet{4}} . If you need to handle reference genomes that are composed of five nucleotides, ACGTN, consider to use the  ReferenceSequence  type described in the  Reference sequences  section.", 
            "title": "Compact representation"
        }, 
        {
            "location": "/man/seq/#defining-a-new-alphabet", 
            "text": "The alphabet type parameter  A  of  BioSequence{A}  enables a user to extend functionality of  BioSequence  with mimimum effort. As an example, definition of a new alphabet type representing a sequence of boolean values is shown below:  using   Bio . Seq  immutable   BoolAlphabet   :   Alphabet   end  Seq . bitsof (:: Type { BoolAlphabet })   =   1  Seq . eltype (:: Type { BoolAlphabet })   =   Bool  Seq . alphabet (:: Type { BoolAlphabet })   =   false : true  function  Seq . encode (:: Type { BoolAlphabet },   x :: Bool ) \n     return   UInt64 ( ifelse ( x ,   0x01 ,   0x00 ))  end  function  Seq . decode (:: Type { BoolAlphabet },   x :: UInt64 ) \n     if   x     0x01 \n         throw ( Seq . DecodeError ( BoolAlphabet ,   x )) \n     end \n     return   ifelse ( x   ==   0x00 ,   false ,   true )  end", 
            "title": "Defining a new alphabet"
        }, 
        {
            "location": "/man/seq/#nucleotide-k-mers", 
            "text": "A common strategy to simplify the analysis of sequence data is to operate or short k-mers, for size fixed size  k . These can be packed into machine integers allowing extremely efficient code. The  Bio.Seq  module has built in support for representing short sequences in 64-bit integers. Besides being fixed length,  Kmer  types, unlike other sequence types cannot contain ambiguous symbols like 'N'.  The  Kmer{T,k}  type parameterized on symbol type ( T , either  DNANucleotide , or  RNANucleotide ) and size  k . For ease of writing code, two type aliases for each nucleotide type are defined and named as  DNAKmer{k}  and  RNAKmer{k} :  julia   DNAKmer ( ACGT )    # create a DNA 4-mer from a string  DNA 4-mer:  ACGT  julia   RNAKmer ( ACGU )    # create an RNA 4-mer from a string  RNA 4-mer:  ACGU  julia   typeof ( DNAKmer ( ACGT ))  Bio.Seq.Kmer{Bio.Seq.DNANucleotide,4}   #  Bio.Seq.each     Function .  each(::Type{Kmer{T,k}}, seq::Sequence[, step=1])  Initialize an iterator over all k-mers in a sequence  seq  skipping ambiguous nucleotides without changing the reading frame.  Arguments   Kmer{T,k} : k-mer type to enumerate.  seq : a nucleotide sequence.  step=1 : the number of positions between iterated k-mers   Examples  # iterate over DNA codons\nfor (pos, codon) in each(DNAKmer{3}, dna ATCCTANAGNTACT , 3)\n    @show pos, codon\nend  source  #  Bio.Seq.canonical     Function .  canonical(kmer::Kmer)  Return the canonical k-mer of  x .  A canonical k-mer is the numerical lesser of a k-mer and its reverse complement. This is useful in hashing/counting k-mers in data that is not strand specific, and thus observing k-mer is equivalent to observing its reverse complement.  source  #  Bio.Seq.neighbors     Function .  neighbors(kmer::Kmer)  Return an iterator through k-mers neighboring  kmer  on a de Bruijn graph.  source", 
            "title": "Nucleotide k-mers"
        }, 
        {
            "location": "/man/seq/#reference-sequences", 
            "text": "DNASequence  (alias of  BioSequence{DNAAlphabet{4}} ) is a flexible data sturcture but always consumes 4 bits per base, which will waste a large part of the memory space when storing reference genome sequences.  In such a case,  ReferenceSequence  is helpful because it compresses positions of 'N' symbols so that long DNA sequences are stored with almost 2 bits per base. An important limitation is that the  ReferenceSequence  type is immutable due to the compression. Other sequence-like operations are supported:  julia   seq   =   ReferenceSequence ( dna NNCGTATTTTCN )  12nt Reference Sequence:  NNCGTATTTTCN  julia   seq [ 1 ]  DNA_N  julia   seq [ 5 ]  DNA_T  julia   seq [ 2 : 6 ]  5nt Reference Sequence:  NCGTA  julia   ReferenceSequence ( dna ATGM )    # DNA_M is not accepted  ERROR: ArgumentError: invalid symbol M \u2209 {A,C,G,T,N} at 4   in convert at /Users/kenta/.julia/v0.4/Bio/src/seq/refseq.jl:58   in call at essentials.jl:56   When reading reference sequences from a FASTA file, the following snippet will avoid allocating temporary sequences and conversion:  for   record   in   open ( hg38.fa ,   FASTA ,   ReferenceSequence ) \n     # do something  end", 
            "title": "Reference sequences"
        }, 
        {
            "location": "/man/seq/#sequence-search", 
            "text": "Three kinds of on-line search functions are provided:   Exact search  Approximate search  Regular expression search   These are all specialized for biological sequences and ambiguities of symbols are considered.", 
            "title": "Sequence search"
        }, 
        {
            "location": "/man/seq/#exact-search", 
            "text": "Exact search functions search for an occurrence of the query symbol or sequence. Four functions,  search ,  searchindex ,  rsearch , and  rsearchindex  are available:  julia   seq   =   dna ACAGCGTAGCT ;  julia   search ( seq ,   DNA_G )    # search a query symbol  4:4  julia   query   =   dna AGC ;  julia   search ( seq ,   query )    # search a query sequence  3:5  julia   searchindex ( seq ,   query )  3  julia   rsearch ( seq ,   query )    # similar to `search` but in the reverse direction  8:10  julia   rsearchindex ( seq ,   query )    # similar to `searchindex` but in the reverse direction  8   These search functions take ambiguous symbols into account. That is, if two symbols are compatible (e.g.  DNA_A  and  DNA_N ), they match when searching an occurrence. In the following example, 'N' is a wild card that matches any symbols:  julia   search ( dna ACNT ,   DNA_N )    #  A  matches  N  1:1  julia   search ( dna ACNT ,   dna CGT )    #  N  matches  G  2:4  julia   search ( dna ACGT ,   dna CNT )    #  G  matches  N  2:4   The exact sequence search needs preprocessing phase of query sequence before searching phase. This would be enough fast for most search applications. But when searching a query sequence to large amounts of target sequences, caching the result of preprocessing may save time. The  ExactSearchQuery  creates such a preprocessed query object and is applicable to the search functions:  julia   query   =   ExactSearchQuery ( dna ATT );  julia   search ( dna ATTTATT ,   query )  1:3  julia   rsearch ( dna ATTTATT ,   query )  5:7", 
            "title": "Exact search"
        }, 
        {
            "location": "/man/seq/#approximate-search", 
            "text": "The approximate search is similar to the exact search but allows a specific number of errors. That is, it tries to find a subsequence of the target sequence within a specific  Levenshtein distance  of the query sequence:  julia   seq   =   dna ACAGCGTAGCT ;  julia   approxsearch ( seq ,   dna AGGG ,   0 )    # nothing matches with no errors  0:-1  julia   approxsearch ( seq ,   dna AGGG ,   1 )    # seq[3:5] matches with one error  3:6  julia   approxsearch ( seq ,   dna AGGG ,   2 )    # seq[1:4] matches with two errors  1:4   Like the exact search functions, four kinds of functions ( approxsearch ,  approxsearchindex ,  approxrsearch , and  approxrsearchindex ) are available:  julia   seq   =   dna ACAGCGTAGCT ;   pat   =   dna AGGG ;  julia   approxsearch ( seq ,   pat ,   2 )          # return the range (forward)  1:4  julia   approxsearchindex ( seq ,   pat ,   2 )     # return the starting index (forward)  1  julia   approxrsearch ( seq ,   pat ,   2 )         # return the range (backward)  8:11  julia   approxrsearchindex ( seq ,   pat ,   2 )    # return the starting index (backward)  8   Preprocessing can be cached in an  ApproximateSearchQuery  object:  julia   query   =   ApproximateSearchQuery ( dna AGGG );  julia   approxsearch ( dna AAGAGG ,   query ,   1 )  2:5  julia   approxsearch ( dna ACTACGT ,   query ,   2 )  4:6", 
            "title": "Approximate search"
        }, 
        {
            "location": "/man/seq/#regular-expression-search", 
            "text": "Query patterns can be described in regular expressions. The syntax supports a subset of Perl and PROSITE's notation.  The Perl-like syntax starts with  biore  ( bio logical  re gular expression) and ends with a symbol option: \"dna\", \"rna\" or \"aa\". For example,  biore\"A+\"dna  is a regular expression for DNA sequences and  biore\"A+\"aa  is for amino acid sequences. The symbol options can be abbreviated to its first character: \"d\", \"r\" or \"a\", respectively.  Here are examples of using the regular expression for  BioSequence s:  julia   match ( biore A+C* dna ,   dna AAAACC )  Nullable(RegexMatch( AAAACC ))  julia   match ( biore A+C* d ,   dna AAAACC )  Nullable(RegexMatch( AAAACC ))  julia   ismatch ( biore A+C* dna ,   dna AAC )  true  julia   ismatch ( biore A+C* dna ,   dna C )  false   match  always returns a  Nullable  object and it should be null if no match is found.  The table below summarizes available syntax elements.     Syntax  Description  Example      \\|  alternation  \"A\\|T\"  matches  \"A\"  and  \"T\"    *  zero or more times repeat  \"TA*\"  matches  \"T\" ,  \"TA\"  and  \"TAA\"    +  one or more times repeat  \"TA+\"  matches  \"TA\"  and  \"TAA\"    ?  zero or one time  \"TA?\"  matches  \"T\"  and  \"TA\"    {n,}  n  or more times repeat  \"A{3,}\"  matches  \"AAA\"  and  \"AAAA\"    {n,m}  n - m  times repeat  \"A{3,5}\"  matches  \"AAA\" ,  \"AAAA\"  and  \"AAAAA\"    ^  the start of the sequence  \"^TAN*\"  matches  \"TATGT\"    $  the end of the sequence  \"N*TA$\"  matches  \"GCTA\"    (...)  pattern grouping  \"(TA)+\"  matches  \"TA\"  and  \"TATA\"    [...]  one of symbols  \"[ACG]+\"  matches  \"AGGC\"     eachmatch ,  matchall , and  search  are also defined like usual strings:  julia   matchall ( biore TATA*? d ,   dna TATTATAATTA )    # overlap (default)  4-element Array{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},1}:   3nt DNA Sequence:  TAT   3nt DNA Sequence:  TAT   4nt DNA Sequence:  TATA   5nt DNA Sequence:  TATAA  julia   matchall ( biore TATA* d ,   dna TATTATAATTA ,   false )    # no overlap  2-element Array{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},1}:   3nt DNA Sequence:  TAT   5nt DNA Sequence:  TATAA  julia   search ( dna TATTATAATTA ,   biore TATA* d )  1:3  julia   search ( dna TATTATAATTA ,   biore TATA* d ,   2 )  4:8   Notewothy differences from strings are:   Ambiguous characters match any compatible characters (e.g.  biore\"N\"d  is equivalent to  biore\"[ACGT]\"d ).  Whitespaces are ignored (e.g.  biore\"A C G\"d  is equivalent to  biore\"ACG\"d ).   The PROSITE notation is described in  ScanProsite - user manual . The syntax supports almost all notations including the extended syntax. The PROSITE notation starts with  prosite  prefix and no symbol option is needed because it always descirbe patterns of amino acid sequences:  julia   match ( prosite [AC]-x-V-x(4)-{ED} ,   aa CPVPQARG )  Nullable(RegexMatch( CPVPQARG ))  julia   match ( prosite [AC]xVx(4){ED} ,   aa CPVPQARG )  Nullable(RegexMatch( CPVPQARG ))", 
            "title": "Regular expression search"
        }, 
        {
            "location": "/man/seq/#sequence-composition", 
            "text": "Sequence composition can be easily calculated using the  composition  function:  julia   comp   =   composition ( dna ACGAG )  DNA Nucleotide Composition:    DNA_A   =  2    DNA_C   =  1    DNA_G   =  2    DNA_T   =  0    DNA_M   =  0    DNA_R   =  0    DNA_W   =  0    DNA_S   =  0    DNA_Y   =  0    DNA_K   =  0    DNA_V   =  0    DNA_H   =  0    DNA_D   =  0    DNA_B   =  0    DNA_N   =  0    DNA_Gap =  0  julia   comp [ DNA_A ]  2  julia   comp [ DNA_T ]  0   To accumulate composition statistics of multiple sequences,  merge!  can be used as follows:  # initiaize an empty composition counter  comp   =   composition ( dna )  # iterate over sequences and accumulate composition statistics into `comp`  for   seq   in   seqs \n     merge! ( comp ,   composition ( seq ))  end  # or functional programming style in one line  foldl (( x ,   y )   -   merge ( x ,   composition ( y )),   composition ( dna ),   seqs )   composition  is also applicable to a  k -mer iterator:  julia   comp   =   composition ( each ( DNAKmer { 4 },   dna ACGT ^ 100 ));  julia   comp [ DNAKmer ( ACGT )]  100  julia   comp [ DNAKmer ( CGTA )]  99", 
            "title": "Sequence composition"
        }, 
        {
            "location": "/man/seq/#sequence-records", 
            "text": "The  SeqRecord  type is used to represent a named sequence, optionally with accompanying metadata. It is defined as: sequence. It is as:  type  SeqRecord { S ,   T } \n     name :: String \n     seq :: S \n     metadata :: T  end   The type of the  metadata  field depends on the source of the sequence record. For example, if a record is read from a FASTA file, metadata contains the description field. If from a FASTQ file, a quality scores assigned to base calls during sequencing.", 
            "title": "Sequence records"
        }, 
        {
            "location": "/man/seq/#sequence-demultiplexing", 
            "text": "Multiplex sequencing is a technology to sequence mutliple samples at the same time on a high-throughput DNA sequencer. Samples are distinguished by the short prefix of a DNA sequence called DNA barcode. The  Bio.Seq  offers the  Demultiplexer  type and the  demultiplex  function to identify the DNA barcode of a longer DNA sequence allowing small errors.  In the following example, four kinds of DNA sequences of length 4 are used as DNA barcodes.  Demultiplexer  takes these barcodes as its first argument with a few options:  julia   barcodes   =   DNASequence [ ATGG ,   CAGA ,   GGAA ,   TACG ];  julia   dplxr   =   Demultiplexer ( barcodes ,   n_max_errors = 1 ,   distance = : hamming )  Bio.Seq.Demultiplexer{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:    distance: hamming    number of barcodes: 4    number of correctable errors: 1   n_max_errors  specifies the number of maximum correctable errors in a barcode. The type of correctable errors depends on the  distance  parameter. When  distance = :hamming  as shown above only substitutions are correctable. When  distance = :levenshtein  substitutions, deletions, and insertions are correctable. The user is responsible for keeping enough distances among barcodes;  Demultiplexer  will throw an exception if two barcodes are within  n_max_errors * 2 .  The  demultiplex  function takes a demultiplexer object and a DNA sequence, and returns a tuple of a barcode index and a distance between the original barcode sequence and the prefix sequence:  julia   demultiplex ( dplxr ,   dna ATGGCGNT )    # 1st barcode with no errors  (1,0)  julia   demultiplex ( dplxr ,   dna CAGGCGNT )    # 2nd barcode with one error  (2,1)  julia   demultiplex ( dplxr ,   dna GGAACGNT )    # 3rd barcode with no errors  (3,0)  julia   demultiplex ( dplxr ,   dna TGACCGNT )    # no matching barcode  (0,-1)   The optional third argument controls the search strategy.  demultiplex  uses an index to search the closest barcode within  n_max_errors  in the barcode set and returns it if any by default. If the third argument is  true  it falls back to a linear search after the index search and returns one of the closest barcodes at random. The next example shows the difference of these two strategies:  julia   demultiplex ( dplxr ,   dna TGACCGNT ,   false )    # linear search off (default)  (0,-1)  julia   demultiplex ( dplxr ,   dna TGACCGNT ,   true )     # linear search on  (3,2)", 
            "title": "Sequence demultiplexing"
        }, 
        {
            "location": "/man/alignments/", 
            "text": "Align: Sequence Alignments\n\n\nThe \nAlign\n module contains tools for computing and working with sequence alignments.\n\n\n\n\nRepresenting alignments\n\n\nThe \nAlignment\n type can represent a wide variety of global or local sequence alignments while facilitating efficient coordinate transformation.  Alignment are always relative to a possibly unspecified reference sequence and represent a series of \nedit operations\n performed on that reference to transform it to the query sequence.\n\n\nTo represent an alignment we use a series of \"anchors\" stored in the \nAlignmentAnchor\n type. Anchors are form of run-length encoding alignment operations, but rather than store an operation along with a length, we store the end-point of that operation in both reference and query coordinates.\n\n\nimmutable\n \nAlignmentAnchor\n\n    \nseqpos\n::\nInt\n\n    \nrefpos\n::\nInt\n\n    \nop\n::\nOperation\n\n\nend\n\n\n\n\n\n\nEvery alignment starts with a special \nOP_START\n operation which is used to give the position in the reference and query prior to the start of the alignment, or 0, if the alignment starts at position 1.\n\n\nFor example, consider the following alignment:\n\n\n              0   4        9  12 15     19\n              |   |        |  |  |      |\n    query:     TGGC----ATCATTTAACG---CAAG\nreference: AGGGTGGCATTTATCAG---ACGTTTCGAGAC\n              |   |   |    |     |  |   |\n              4   8   12   17    20 23  27\n\n\n\n\n\nUsing anchors we would represent this as the following series of anchors:\n\n\n[\n\n    \nAlignmentAnchor\n(\n \n0\n,\n  \n4\n,\n \nOP_START\n),\n\n    \nAlignmentAnchor\n(\n \n4\n,\n  \n8\n,\n \nOP_MATCH\n),\n\n    \nAlignmentAnchor\n(\n \n4\n,\n \n12\n,\n \nOP_DELETE\n),\n\n    \nAlignmentAnchor\n(\n \n9\n,\n \n17\n,\n \nOP_MATCH\n),\n\n    \nAlignmentAnchor\n(\n12\n,\n \n17\n,\n \nOP_INSERT\n),\n\n    \nAlignmentAnchor\n(\n15\n,\n \n20\n,\n \nOP_MATCH\n),\n\n    \nAlignmentAnchor\n(\n15\n,\n \n23\n,\n \nOP_DELETE\n),\n\n    \nAlignmentAnchor\n(\n19\n,\n \n27\n,\n \nOP_MATCH\n)\n\n\n]\n\n\n\n\n\n\nAn \nAlignment\n object can be created from a series of anchors:\n\n\njulia\n \nAlignment\n([\n\n\n\n           AlignmentAnchor(0, 4, OP_START),\n\n\n\n           AlignmentAnchor(4, 8, OP_MATCH),\n\n\n\n           AlignmentAnchor(4, 12, OP_DELETE)\n\n\n\n       ])\n\n\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n\n\n\u00b7\u00b7\u00b7\u00b7----\n\n\n\n\n\n\n\n\nOperations\n\n\nAlignment operations follow closely from those used in the \nSAM/BAM format\n and are stored in the \nOperation\n bitstype.\n\n\n\n\n\n\n\n\nOperation\n\n\nOperation Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOP_MATCH\n\n\nmatch\n\n\nnon-specific match\n\n\n\n\n\n\nOP_INSERT\n\n\ninsert\n\n\ninsertion into reference sequence\n\n\n\n\n\n\nOP_DELETE\n\n\ndelete\n\n\ndeletion from reference sequence\n\n\n\n\n\n\nOP_SKIP\n\n\ndelete\n\n\n(typically long) deletion from the reference, e.g. due to RNA splicing\n\n\n\n\n\n\nOP_SOFT_CLIP\n\n\ninsert\n\n\nsequence removed from the beginning or end of the query sequence but stored\n\n\n\n\n\n\nOP_HARD_CLIP\n\n\ninsert\n\n\nsequence removed from the beginning or end of the query sequence and not stored\n\n\n\n\n\n\nOP_PAD\n\n\nspecial\n\n\nnot currently supported, but present for SAM/BAM compatibility\n\n\n\n\n\n\nOP_SEQ_MATCH\n\n\nmatch\n\n\nmatch operation with matching sequence positions\n\n\n\n\n\n\nOP_SEQ_MISMATCH\n\n\nmatch\n\n\nmatch operation with mismatching sequence positions\n\n\n\n\n\n\nOP_BACK\n\n\nspecial\n\n\nnot currently supported, but present for SAM/BAM compatibility\n\n\n\n\n\n\nOP_START\n\n\nspecial\n\n\nindicate the start of an alignment within the reference and query sequence\n\n\n\n\n\n\n\n\n\n\nAligned sequence\n\n\nA sequence aligned to another sequence is represented by the \nAlignedSequence\n type, which is a pair of the aligned sequence and an \nAlignment\n object.\n\n\nThe following example creates an aligned sequence object from a sequence and an alignment:\n\n\njulia\n \nAlignedSequence\n(\n  \n# pass an Alignment object\n\n\n\n           dna\nACGTAT\n,\n\n\n\n           Alignment([\n\n\n\n               AlignmentAnchor(0, 0, OP_START),\n\n\n\n               AlignmentAnchor(3, 3, OP_MATCH),\n\n\n\n               AlignmentAnchor(6, 3, OP_INSERT)\n\n\n\n           ])\n\n\n\n       )\n\n\n\u00b7\u00b7\u00b7---\n\n\nACGTAT\n\n\n\njulia\n \nAlignedSequence\n(\n  \n# or pass a vector of anchors\n\n\n\n           dna\nACGTAT\n,\n\n\n\n           [\n\n\n\n               AlignmentAnchor(0, 0, OP_START),\n\n\n\n               AlignmentAnchor(3, 3, OP_MATCH),\n\n\n\n               AlignmentAnchor(6, 3, OP_INSERT)\n\n\n\n           ]\n\n\n\n       )\n\n\n\u00b7\u00b7\u00b7---\n\n\nACGTAT\n\n\n\n\n\n\nIf you already have an aligned sequence with gap symbols, it can be converted to an \nAlignedSequence\n object by passing a reference sequence with it:\n\n\njulia\n \nseq\n \n=\n \ndna\nACGT--AAT--\n\n\n11nt DNA Sequence:\n\n\nACGT--AAT--\n\n\n\njulia\n \nref\n \n=\n \ndna\nACGTTTAT-GG\n\n\n11nt DNA Sequence:\n\n\nACGTTTAT-GG\n\n\n\njulia\n \nAlignedSequence\n(\nseq\n,\n \nref\n)\n\n\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7-\u00b7\u00b7\n\n\nACGT--AAT--\n\n\n\n\n\n\n\n\nOperating on alignments\n\n\n#\n\n\nBase.first\n \n \nFunction\n.\n\n\nfirst(coll)\n\n\n\n\n\nGet the first element of an iterable collection. Returns the start point of a \nRange\n even if it is empty.\n\n\nsource\n\n\n#\n\n\nBase.last\n \n \nFunction\n.\n\n\nlast(coll)\n\n\n\n\n\nGet the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling \nendof\n to get the last index. Returns the end point of a \nRange\n even if it is empty.\n\n\nsource\n\n\n#\n\n\nBio.Align.seq2ref\n \n \nFunction\n.\n\n\nseq2ref(i, aln)\n\n\n\n\n\nMap a position from sequence to reference.\n\n\nsource\n\n\n#\n\n\nBio.Align.ref2seq\n \n \nFunction\n.\n\n\nref2seq(i, aln)\n\n\n\n\n\nMap a position from reference to sequence.\n\n\nsource\n\n\n#\n\n\nBio.Align.cigar\n \n \nFunction\n.\n\n\nOutput a CIGAR string encoding of an \nAlignment\n. This is not entirely lossless as it discards the alignments start positions.\n\n\nsource\n\n\n\n\nPairwise alignment\n\n\nPairwise alignment is a sequence alignment between two sequences.  The \nBio.Align\n module implements several pairwise alignment methods that maximize alignment score or minimize alignment cost.\n\n\nA pair of optimization type and score (or cost) model determines the best alignments between two sequences. The next example uses a pair of \nGlobalAlignment\n and \nAffineGapScoreModel\n to obtain the best alignment:\n\n\njulia\n \nproblem\n \n=\n \nGlobalAlignment\n()\n\n\nBio.Align.GlobalAlignment()\n\n\n\njulia\n \nscoremodel\n \n=\n \nAffineGapScoreModel\n(\n\n\n\n                  match=5,\n\n\n\n                  mismatch=-4,\n\n\n\n                  gap_open=-4,\n\n\n\n                  gap_extend=-1\n\n\n\n              )\n\n\nBio.Align.AffineGapScoreModel{Int64}:\n\n\n    mismatch = -4\n\n\n    gap_open = -4\n\n\n  gap_extend = -1\n\n\n\n\n       match = 5\n\n\njulia\n \npairalign\n(\nproblem\n,\n \ndna\nCGGATTA\n,\n \ndna\nGGTTTAC\n,\n \nscoremodel\n)\n\n\nBio.Align.PairwiseAlignmentResult{Int64,Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:\n\n\n  score: 11\n\n\n  seq: 1 CGGATTA- 7\n\n\n  ref: 0 -GGTTTAC 7\n\n\n\n\n\n\npairalign\n takes an alignment type as its first argument, then two sequences to align, and score (or cost) model. Alignment type is one of the following four types:\n\n\n\n\nGlobalAlignment\n: global-to-global alignment\n\n\nSemiGlobalAlignment\n: local-to-global alignment\n\n\nLocalAlignment\n: local-to-local alignment\n\n\nOverlapAlignment\n: end-free alignment\n\n\n\n\nFor scoring model, \nAffineGapScoreModel\n is currently supported. It imposes an \naffine gap penalty\n for insertions and deletions: \ngap_open + k * gap_extend\n for a consecutive insertion/deletion of length \nk\n. The affine gap penalty is flexible enough to create a constant and linear scoring model. Setting \ngap_extend = 0\n or \ngap_open = 0\n, they are equivalent to the constant or linear gap penalty, respectively. The first argument of \nAffineGapScoreModel\n can be a substitution matrix like \nAffineGapScoreModel(BLOSUM62, gap_open=-10, gap_extend=-1)\n. For details on substitution matrices, see the \nSubstitution matrices\n section.\n\n\nAlignment type can also be a distance of two sequences:\n\n\n\n\nEditDistance\n\n\nLevenshteinDistance\n\n\nHammingDistance\n\n\n\n\nIn this alignment, \nCostModel\n is used instead of \nAffineGapScoreModel\n to define cost of substitution, insertion, and deletion:\n\n\njulia\n \ncostmodel\n \n=\n \nCostModel\n(\nmatch\n=\n0\n,\n \nmismatch\n=\n1\n,\n \ninsertion\n=\n1\n,\n \ndeletion\n=\n1\n);\n\n\n\njulia\n \npairalign\n(\nEditDistance\n(),\n \nabcd\n,\n \nadcde\n,\n \ncostmodel\n)\n\n\nBio.Align.PairwiseAlignmentResult{Int64,ASCIIString,ASCIIString}:\n\n\n  distance: 2\n\n\n  seq: 1 abcd- 4\n\n\n  ref: 1 adcde 5\n\n\n\n\n\n\n\n\nOperations on pairwise alignment\n\n\npairalign\n returns a \nPairwiseAlignmentResult\n object and some accessors are provided for it.\n\n\n#\n\n\nBio.Align.score\n \n \nFunction\n.\n\n\nscore(alignment_result)\n\n\n\n\n\nReturn score of alignment.\n\n\nsource\n\n\n#\n\n\nBio.Align.distance\n \n \nFunction\n.\n\n\ndistance(alignment_result)\n\n\n\n\n\nRetrun distance of alignment.\n\n\nsource\n\n\n#\n\n\nBio.Align.hasalignment\n \n \nFunction\n.\n\n\nhasalignment(alignment_result)\n\n\n\n\n\nCheck if alignment is stored or not.\n\n\nsource\n\n\n#\n\n\nBio.Align.alignment\n \n \nFunction\n.\n\n\nalignment(alignment_result)\n\n\n\n\n\nReturn alignment if any.\n\n\nSee also: \nhasalignment\n\n\nsource\n\n\nPairwise alignment also implements some useful operations on it.\n\n\n#\n\n\nBio.Align.count_matches\n \n \nFunction\n.\n\n\ncount_matches(aln)\n\n\n\n\n\nCount the number of matching positions.\n\n\nsource\n\n\n#\n\n\nBio.Align.count_mismatches\n \n \nFunction\n.\n\n\ncount_mismatches(aln)\n\n\n\n\n\nCount the number of mismatching positions.\n\n\nsource\n\n\n#\n\n\nBio.Align.count_insertions\n \n \nFunction\n.\n\n\ncount_insertions(aln)\n\n\n\n\n\nCount the number of inserting positions.\n\n\nsource\n\n\n#\n\n\nBio.Align.count_deletions\n \n \nFunction\n.\n\n\ncount_deletions(aln)\n\n\n\n\n\nCount the number of deleting positions.\n\n\nsource\n\n\n#\n\n\nBio.Align.count_aligned\n \n \nFunction\n.\n\n\ncount_aligned(aln)\n\n\n\n\n\nCount the number of aligned positions.\n\n\nsource\n\n\nThe example below shows a use case of these operations:\n\n\njulia\n \ns1\n \n=\n \ndna\nCCTAGGAGGG\n;\n\n\n\njulia\n \ns2\n \n=\n \ndna\nACCTGGTATGATAGCG\n;\n\n\n\njulia\n \nscoremodel\n \n=\n \nAffineGapScoreModel\n(\nEDNAFULL\n,\n \ngap_open\n=-\n5\n,\n \ngap_extend\n=-\n1\n);\n\n\n\njulia\n \nres\n \n=\n \npairalign\n(\nGlobalAlignment\n(),\n \ns1\n,\n \ns2\n,\n \nscoremodel\n)\n  \n# run pairwise alignment\n\n\nBio.Align.PairwiseAlignmentResult{Int64,Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:\n\n\n  score: 13\n\n\n  seq:  0 -CCTAGG------AGGG 10\n\n\n  ref:  1 ACCT-GGTATGATAGCG 16\n\n\n\n\n\n           ||| ||      || |\n\n\njulia\n \nscore\n(\nres\n)\n  \n# get the achieved score of this alignment\n\n\n13\n\n\n\njulia\n \naln\n \n=\n \nalignment\n(\nres\n)\n\n\nPairwiseAlignment{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:\n\n\n  seq:  0 -CCTAGG------AGGG 10\n\n\n  ref:  1 ACCT-GGTATGATAGCG 16\n\n\n\n\n\n           ||| ||      || |\n\n\njulia\n \ncount_matches\n(\naln\n)\n\n\n8\n\n\n\njulia\n \ncount_mismatches\n(\naln\n)\n\n\n1\n\n\n\njulia\n \ncount_insertions\n(\naln\n)\n\n\n1\n\n\n\njulia\n \ncount_deletions\n(\naln\n)\n\n\n7\n\n\n\njulia\n \ncount_aligned\n(\naln\n)\n\n\n17\n\n\n\njulia\n \ncollect\n(\naln\n)\n  \n# pairwise alignment is iterable\n\n\n17-element Array{Tuple{Bio.Seq.DNANucleotide,Bio.Seq.DNANucleotide},1}:\n\n\n (-,A)\n\n\n (C,C)\n\n\n (C,C)\n\n\n (T,T)\n\n\n (A,-)\n\n\n (G,G)\n\n\n (G,G)\n\n\n (-,T)\n\n\n (-,A)\n\n\n (-,T)\n\n\n (-,G)\n\n\n (-,A)\n\n\n (-,T)\n\n\n (A,A)\n\n\n (G,G)\n\n\n (G,C)\n\n\n (G,G)\n\n\n\njulia\n \nDNASequence\n([\nx\n \nfor\n \n(\nx\n,\n \n_\n)\n \nin\n \naln\n])\n  \n# create aligned `s1` with gaps\n\n\n17nt DNA Sequence:\n\n\n-CCTAGG------AGGG\n\n\n\njulia\n \nDNASequence\n([\ny\n \nfor\n \n(\n_\n,\n \ny\n)\n \nin\n \naln\n])\n  \n# create aligned `s2` with gaps\n\n\n17nt DNA Sequence:\n\n\nACCT-GGTATGATAGCG\n\n\n\n\n\n\n\n\nSubstitution matrices\n\n\nA substitution matrix is a function of substitution score (or cost) from one symbol to other. Substitution value of \nsubmat\n from \nx\n to \ny\n can be obtained by writing \nsubmat[x,y]\n. In \nBio.Align\n, \nSubstitutionMatrix\n and \nDichotomousSubstitutionMatrix\n are two distinct types representing substitution matrices.\n\n\nSubstitutionMatrix\n is a general substitution matrix type that is a thin wrapper of regular matrix.\n\n\nSome common substitution matrices are provided. For DNA and RNA, \nEDNAFULL\n is defined:\n\n\njulia\n \nEDNAFULL\n\n\nBio.Align.SubstitutionMatrix{Bio.Seq.DNANucleotide,Int64}:\n\n\n     A  C  G  T  M  R  W  S  Y  K  V  H  D  B  N\n\n\n  A  5 -4 -4 -4  1  1  1 -4 -4 -4 -1 -1 -1 -4 -2\n\n\n  C -4  5 -4 -4  1 -4 -4  1  1 -4 -1 -1 -4 -1 -2\n\n\n  G -4 -4  5 -4 -4  1 -4  1 -4  1 -1 -4 -1 -1 -2\n\n\n  T -4 -4 -4  5 -4 -4  1 -4  1  1 -4 -1 -1 -1 -2\n\n\n  M  1  1 -4 -4 -1 -2 -2 -2 -2 -4 -1 -1 -3 -3 -1\n\n\n  R  1 -4  1 -4 -2 -1 -2 -2 -4 -2 -1 -3 -1 -3 -1\n\n\n  W  1 -4 -4  1 -2 -2 -1 -4 -2 -2 -3 -1 -1 -3 -1\n\n\n  S -4  1  1 -4 -2 -2 -4 -1 -2 -2 -1 -3 -3 -1 -1\n\n\n  Y -4  1 -4  1 -2 -4 -2 -2 -1 -2 -3 -1 -3 -1 -1\n\n\n  K -4 -4  1  1 -4 -2 -2 -2 -2 -1 -3 -3 -1 -1 -1\n\n\n  V -1 -1 -1 -4 -1 -1 -3 -1 -3 -3 -1 -2 -2 -2 -1\n\n\n  H -1 -1 -4 -1 -1 -3 -1 -3 -1 -3 -2 -1 -2 -2 -1\n\n\n  D -1 -4 -1 -1 -3 -1 -1 -3 -3 -1 -2 -2 -1 -2 -1\n\n\n  B -4 -1 -1 -1 -3 -3 -3 -1 -1 -1 -2 -2 -2 -1 -1\n\n\n  N -2 -2 -2 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1\n\n\n(underlined values are default ones)\n\n\n\n\n\n\nFor amino acids, PAM (Point Accepted Mutation) and BLOSUM (BLOcks SUbstitution Matrix) matrices are defined:\n\n\njulia\n \nBLOSUM62\n\n\nBio.Align.SubstitutionMatrix{Bio.Seq.AminoAcid,Int64}:\n\n\n     A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V  O  U  B  J  Z  X  *\n\n\n  A  4 -1 -2 -2  0 -1 -1  0 -2 -1 -1 -1 -1 -2 -1  1  0 -3 -2  0  0\u0332  0\u0332 -2  0\u0332 -1  0 -4\n\n\n  R -1  5  0 -2 -3  1  0 -2  0 -3 -2  2 -1 -3 -2 -1 -1 -3 -2 -3  0\u0332  0\u0332 -1  0\u0332  0 -1 -4\n\n\n  N -2  0  6  1 -3  0  0  0  1 -3 -3  0 -2 -3 -2  1  0 -4 -2 -3  0\u0332  0\u0332  3  0\u0332  0 -1 -4\n\n\n  D -2 -2  1  6 -3  0  2 -1 -1 -3 -4 -1 -3 -3 -1  0 -1 -4 -3 -3  0\u0332  0\u0332  4  0\u0332  1 -1 -4\n\n\n  C  0 -3 -3 -3  9 -3 -4 -3 -3 -1 -1 -3 -1 -2 -3 -1 -1 -2 -2 -1  0\u0332  0\u0332 -3  0\u0332 -3 -2 -4\n\n\n  Q -1  1  0  0 -3  5  2 -2  0 -3 -2  1  0 -3 -1  0 -1 -2 -1 -2  0\u0332  0\u0332  0  0\u0332  3 -1 -4\n\n\n  E -1  0  0  2 -4  2  5 -2  0 -3 -3  1 -2 -3 -1  0 -1 -3 -2 -2  0\u0332  0\u0332  1  0\u0332  4 -1 -4\n\n\n  G  0 -2  0 -1 -3 -2 -2  6 -2 -4 -4 -2 -3 -3 -2  0 -2 -2 -3 -3  0\u0332  0\u0332 -1  0\u0332 -2 -1 -4\n\n\n  H -2  0  1 -1 -3  0  0 -2  8 -3 -3 -1 -2 -1 -2 -1 -2 -2  2 -3  0\u0332  0\u0332  0  0\u0332  0 -1 -4\n\n\n  I -1 -3 -3 -3 -1 -3 -3 -4 -3  4  2 -3  1  0 -3 -2 -1 -3 -1  3  0\u0332  0\u0332 -3  0\u0332 -3 -1 -4\n\n\n  L -1 -2 -3 -4 -1 -2 -3 -4 -3  2  4 -2  2  0 -3 -2 -1 -2 -1  1  0\u0332  0\u0332 -4  0\u0332 -3 -1 -4\n\n\n  K -1  2  0 -1 -3  1  1 -2 -1 -3 -2  5 -1 -3 -1  0 -1 -3 -2 -2  0\u0332  0\u0332  0  0\u0332  1 -1 -4\n\n\n  M -1 -1 -2 -3 -1  0 -2 -3 -2  1  2 -1  5  0 -2 -1 -1 -1 -1  1  0\u0332  0\u0332 -3  0\u0332 -1 -1 -4\n\n\n  F -2 -3 -3 -3 -2 -3 -3 -3 -1  0  0 -3  0  6 -4 -2 -2  1  3 -1  0\u0332  0\u0332 -3  0\u0332 -3 -1 -4\n\n\n  P -1 -2 -2 -1 -3 -1 -1 -2 -2 -3 -3 -1 -2 -4  7 -1 -1 -4 -3 -2  0\u0332  0\u0332 -2  0\u0332 -1 -2 -4\n\n\n  S  1 -1  1  0 -1  0  0  0 -1 -2 -2  0 -1 -2 -1  4  1 -3 -2 -2  0\u0332  0\u0332  0  0\u0332  0  0 -4\n\n\n  T  0 -1  0 -1 -1 -1 -1 -2 -2 -1 -1 -1 -1 -2 -1  1  5 -2 -2  0  0\u0332  0\u0332 -1  0\u0332 -1  0 -4\n\n\n  W -3 -3 -4 -4 -2 -2 -3 -2 -2 -3 -2 -3 -1  1 -4 -3 -2 11  2 -3  0\u0332  0\u0332 -4  0\u0332 -3 -2 -4\n\n\n  Y -2 -2 -2 -3 -2 -1 -2 -3  2 -1 -1 -2 -1  3 -3 -2 -2  2  7 -1  0\u0332  0\u0332 -3  0\u0332 -2 -1 -4\n\n\n  V  0 -3 -3 -3 -1 -2 -2 -3 -3  3  1 -2  1 -1 -2 -2  0 -3 -1  4  0\u0332  0\u0332 -3  0\u0332 -2 -1 -4\n\n\n  O  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332\n\n\n  U  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332\n\n\n  B -2 -1  3  4 -3  0  1 -1  0 -3 -4  0 -3 -3 -2  0 -1 -4 -3 -3  0\u0332  0\u0332  4  0\u0332  1 -1 -4\n\n\n  J  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332\n\n\n  Z -1  0  0  1 -3  3  4 -2  0 -3 -3  1 -1 -3 -1  0 -1 -3 -2 -2  0\u0332  0\u0332  1  0\u0332  4 -1 -4\n\n\n  X  0 -1 -1 -1 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -2  0  0 -2 -1 -1  0\u0332  0\u0332 -1  0\u0332 -1 -1 -4\n\n\n  * -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4  0\u0332  0\u0332 -4  0\u0332 -4 -4  1\n\n\n(underlined values are default ones)\n\n\n\n\n\n\n\n\n\n\n\n\nMatrix\n\n\nConstants\n\n\n\n\n\n\n\n\n\n\nPAM\n\n\nPAM30\n, \nPAM70\n, \nPAM250\n\n\n\n\n\n\nBLOSUM\n\n\nBLOSUM45\n, \nBLOSUM50\n, \nBLOSUM62\n, \nBLOSUM80\n, \nBLOSUM90\n\n\n\n\n\n\n\n\nThese matrices are downloaded from: \nftp://ftp.ncbi.nih.gov/blast/matrices/\n.\n\n\nSubstitutionMatrix\n can be modified like a regular matrix:\n\n\njulia\n \nmysubmat\n \n=\n \ncopy\n(\nBLOSUM62\n);\n  \n# create a copy\n\n\n\njulia\n \nmysubmat\n[\nAA_A\n,\nAA_R\n]\n  \n# score of AA_A =\n AA_R substitution is -1\n\n\n-1\n\n\n\njulia\n \nmysubmat\n[\nAA_A\n,\nAA_R\n]\n \n=\n \n-\n3\n  \n# set the score to -3\n\n\n-3\n\n\n\njulia\n \nmysubmat\n[\nAA_A\n,\nAA_R\n]\n  \n# the score is modified\n\n\n-3\n\n\n\n\n\n\nMake sure to create a copy of the original matrix when you create a matrix from a predefined matrix. In the above case, \nBLOSUM62\n is shared in the whole program and modification on it will affect any result that uses \nBLOSUM62\n.\n\n\nDichotomousSubstitutionMatrix\n is a specialized matrix for matching or mismatching substitution.  This is a preferable choice when performance is more important than flexibility because looking up score is faster than \nSubstitutionMatrix\n.\n\n\njulia\n \nsubmat\n \n=\n \nDichotomousSubstitutionMatrix\n(\n1\n,\n \n-\n1\n)\n\n\nBio.Align.DichotomousSubstitutionMatrix{Int64}:\n\n\n     match =  1\n\n\n  mismatch = -1\n\n\n\njulia\n \nsubmat\n[\nA\n,\nA\n]\n  \n# match\n\n\n1\n\n\n\njulia\n \nsubmat\n[\nA\n,\nB\n]\n  \n# mismatch\n\n\n-1", 
            "title": "Alignments"
        }, 
        {
            "location": "/man/alignments/#align-sequence-alignments", 
            "text": "The  Align  module contains tools for computing and working with sequence alignments.", 
            "title": "Align: Sequence Alignments"
        }, 
        {
            "location": "/man/alignments/#representing-alignments", 
            "text": "The  Alignment  type can represent a wide variety of global or local sequence alignments while facilitating efficient coordinate transformation.  Alignment are always relative to a possibly unspecified reference sequence and represent a series of  edit operations  performed on that reference to transform it to the query sequence.  To represent an alignment we use a series of \"anchors\" stored in the  AlignmentAnchor  type. Anchors are form of run-length encoding alignment operations, but rather than store an operation along with a length, we store the end-point of that operation in both reference and query coordinates.  immutable   AlignmentAnchor \n     seqpos :: Int \n     refpos :: Int \n     op :: Operation  end   Every alignment starts with a special  OP_START  operation which is used to give the position in the reference and query prior to the start of the alignment, or 0, if the alignment starts at position 1.  For example, consider the following alignment:                0   4        9  12 15     19\n              |   |        |  |  |      |\n    query:     TGGC----ATCATTTAACG---CAAG\nreference: AGGGTGGCATTTATCAG---ACGTTTCGAGAC\n              |   |   |    |     |  |   |\n              4   8   12   17    20 23  27  Using anchors we would represent this as the following series of anchors:  [ \n     AlignmentAnchor (   0 ,    4 ,   OP_START ), \n     AlignmentAnchor (   4 ,    8 ,   OP_MATCH ), \n     AlignmentAnchor (   4 ,   12 ,   OP_DELETE ), \n     AlignmentAnchor (   9 ,   17 ,   OP_MATCH ), \n     AlignmentAnchor ( 12 ,   17 ,   OP_INSERT ), \n     AlignmentAnchor ( 15 ,   20 ,   OP_MATCH ), \n     AlignmentAnchor ( 15 ,   23 ,   OP_DELETE ), \n     AlignmentAnchor ( 19 ,   27 ,   OP_MATCH )  ]   An  Alignment  object can be created from a series of anchors:  julia   Alignment ([             AlignmentAnchor(0, 4, OP_START),             AlignmentAnchor(4, 8, OP_MATCH),             AlignmentAnchor(4, 12, OP_DELETE)         ])  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  \u00b7\u00b7\u00b7\u00b7----", 
            "title": "Representing alignments"
        }, 
        {
            "location": "/man/alignments/#operations", 
            "text": "Alignment operations follow closely from those used in the  SAM/BAM format  and are stored in the  Operation  bitstype.     Operation  Operation Type  Description      OP_MATCH  match  non-specific match    OP_INSERT  insert  insertion into reference sequence    OP_DELETE  delete  deletion from reference sequence    OP_SKIP  delete  (typically long) deletion from the reference, e.g. due to RNA splicing    OP_SOFT_CLIP  insert  sequence removed from the beginning or end of the query sequence but stored    OP_HARD_CLIP  insert  sequence removed from the beginning or end of the query sequence and not stored    OP_PAD  special  not currently supported, but present for SAM/BAM compatibility    OP_SEQ_MATCH  match  match operation with matching sequence positions    OP_SEQ_MISMATCH  match  match operation with mismatching sequence positions    OP_BACK  special  not currently supported, but present for SAM/BAM compatibility    OP_START  special  indicate the start of an alignment within the reference and query sequence", 
            "title": "Operations"
        }, 
        {
            "location": "/man/alignments/#aligned-sequence", 
            "text": "A sequence aligned to another sequence is represented by the  AlignedSequence  type, which is a pair of the aligned sequence and an  Alignment  object.  The following example creates an aligned sequence object from a sequence and an alignment:  julia   AlignedSequence (    # pass an Alignment object             dna ACGTAT ,             Alignment([                 AlignmentAnchor(0, 0, OP_START),                 AlignmentAnchor(3, 3, OP_MATCH),                 AlignmentAnchor(6, 3, OP_INSERT)             ])         )  \u00b7\u00b7\u00b7---  ACGTAT  julia   AlignedSequence (    # or pass a vector of anchors             dna ACGTAT ,             [                 AlignmentAnchor(0, 0, OP_START),                 AlignmentAnchor(3, 3, OP_MATCH),                 AlignmentAnchor(6, 3, OP_INSERT)             ]         )  \u00b7\u00b7\u00b7---  ACGTAT   If you already have an aligned sequence with gap symbols, it can be converted to an  AlignedSequence  object by passing a reference sequence with it:  julia   seq   =   dna ACGT--AAT--  11nt DNA Sequence:  ACGT--AAT--  julia   ref   =   dna ACGTTTAT-GG  11nt DNA Sequence:  ACGTTTAT-GG  julia   AlignedSequence ( seq ,   ref )  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7-\u00b7\u00b7  ACGT--AAT--", 
            "title": "Aligned sequence"
        }, 
        {
            "location": "/man/alignments/#operating-on-alignments", 
            "text": "#  Base.first     Function .  first(coll)  Get the first element of an iterable collection. Returns the start point of a  Range  even if it is empty.  source  #  Base.last     Function .  last(coll)  Get the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling  endof  to get the last index. Returns the end point of a  Range  even if it is empty.  source  #  Bio.Align.seq2ref     Function .  seq2ref(i, aln)  Map a position from sequence to reference.  source  #  Bio.Align.ref2seq     Function .  ref2seq(i, aln)  Map a position from reference to sequence.  source  #  Bio.Align.cigar     Function .  Output a CIGAR string encoding of an  Alignment . This is not entirely lossless as it discards the alignments start positions.  source", 
            "title": "Operating on alignments"
        }, 
        {
            "location": "/man/alignments/#pairwise-alignment", 
            "text": "Pairwise alignment is a sequence alignment between two sequences.  The  Bio.Align  module implements several pairwise alignment methods that maximize alignment score or minimize alignment cost.  A pair of optimization type and score (or cost) model determines the best alignments between two sequences. The next example uses a pair of  GlobalAlignment  and  AffineGapScoreModel  to obtain the best alignment:  julia   problem   =   GlobalAlignment ()  Bio.Align.GlobalAlignment()  julia   scoremodel   =   AffineGapScoreModel (                    match=5,                    mismatch=-4,                    gap_open=-4,                    gap_extend=-1                )  Bio.Align.AffineGapScoreModel{Int64}:      mismatch = -4      gap_open = -4    gap_extend = -1         match = 5  julia   pairalign ( problem ,   dna CGGATTA ,   dna GGTTTAC ,   scoremodel )  Bio.Align.PairwiseAlignmentResult{Int64,Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:    score: 11    seq: 1 CGGATTA- 7    ref: 0 -GGTTTAC 7   pairalign  takes an alignment type as its first argument, then two sequences to align, and score (or cost) model. Alignment type is one of the following four types:   GlobalAlignment : global-to-global alignment  SemiGlobalAlignment : local-to-global alignment  LocalAlignment : local-to-local alignment  OverlapAlignment : end-free alignment   For scoring model,  AffineGapScoreModel  is currently supported. It imposes an  affine gap penalty  for insertions and deletions:  gap_open + k * gap_extend  for a consecutive insertion/deletion of length  k . The affine gap penalty is flexible enough to create a constant and linear scoring model. Setting  gap_extend = 0  or  gap_open = 0 , they are equivalent to the constant or linear gap penalty, respectively. The first argument of  AffineGapScoreModel  can be a substitution matrix like  AffineGapScoreModel(BLOSUM62, gap_open=-10, gap_extend=-1) . For details on substitution matrices, see the  Substitution matrices  section.  Alignment type can also be a distance of two sequences:   EditDistance  LevenshteinDistance  HammingDistance   In this alignment,  CostModel  is used instead of  AffineGapScoreModel  to define cost of substitution, insertion, and deletion:  julia   costmodel   =   CostModel ( match = 0 ,   mismatch = 1 ,   insertion = 1 ,   deletion = 1 );  julia   pairalign ( EditDistance (),   abcd ,   adcde ,   costmodel )  Bio.Align.PairwiseAlignmentResult{Int64,ASCIIString,ASCIIString}:    distance: 2    seq: 1 abcd- 4    ref: 1 adcde 5", 
            "title": "Pairwise alignment"
        }, 
        {
            "location": "/man/alignments/#operations-on-pairwise-alignment", 
            "text": "pairalign  returns a  PairwiseAlignmentResult  object and some accessors are provided for it.  #  Bio.Align.score     Function .  score(alignment_result)  Return score of alignment.  source  #  Bio.Align.distance     Function .  distance(alignment_result)  Retrun distance of alignment.  source  #  Bio.Align.hasalignment     Function .  hasalignment(alignment_result)  Check if alignment is stored or not.  source  #  Bio.Align.alignment     Function .  alignment(alignment_result)  Return alignment if any.  See also:  hasalignment  source  Pairwise alignment also implements some useful operations on it.  #  Bio.Align.count_matches     Function .  count_matches(aln)  Count the number of matching positions.  source  #  Bio.Align.count_mismatches     Function .  count_mismatches(aln)  Count the number of mismatching positions.  source  #  Bio.Align.count_insertions     Function .  count_insertions(aln)  Count the number of inserting positions.  source  #  Bio.Align.count_deletions     Function .  count_deletions(aln)  Count the number of deleting positions.  source  #  Bio.Align.count_aligned     Function .  count_aligned(aln)  Count the number of aligned positions.  source  The example below shows a use case of these operations:  julia   s1   =   dna CCTAGGAGGG ;  julia   s2   =   dna ACCTGGTATGATAGCG ;  julia   scoremodel   =   AffineGapScoreModel ( EDNAFULL ,   gap_open =- 5 ,   gap_extend =- 1 );  julia   res   =   pairalign ( GlobalAlignment (),   s1 ,   s2 ,   scoremodel )    # run pairwise alignment  Bio.Align.PairwiseAlignmentResult{Int64,Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:    score: 13    seq:  0 -CCTAGG------AGGG 10    ref:  1 ACCT-GGTATGATAGCG 16             ||| ||      || |  julia   score ( res )    # get the achieved score of this alignment  13  julia   aln   =   alignment ( res )  PairwiseAlignment{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:    seq:  0 -CCTAGG------AGGG 10    ref:  1 ACCT-GGTATGATAGCG 16             ||| ||      || |  julia   count_matches ( aln )  8  julia   count_mismatches ( aln )  1  julia   count_insertions ( aln )  1  julia   count_deletions ( aln )  7  julia   count_aligned ( aln )  17  julia   collect ( aln )    # pairwise alignment is iterable  17-element Array{Tuple{Bio.Seq.DNANucleotide,Bio.Seq.DNANucleotide},1}:   (-,A)   (C,C)   (C,C)   (T,T)   (A,-)   (G,G)   (G,G)   (-,T)   (-,A)   (-,T)   (-,G)   (-,A)   (-,T)   (A,A)   (G,G)   (G,C)   (G,G)  julia   DNASequence ([ x   for   ( x ,   _ )   in   aln ])    # create aligned `s1` with gaps  17nt DNA Sequence:  -CCTAGG------AGGG  julia   DNASequence ([ y   for   ( _ ,   y )   in   aln ])    # create aligned `s2` with gaps  17nt DNA Sequence:  ACCT-GGTATGATAGCG", 
            "title": "Operations on pairwise alignment"
        }, 
        {
            "location": "/man/alignments/#substitution-matrices", 
            "text": "A substitution matrix is a function of substitution score (or cost) from one symbol to other. Substitution value of  submat  from  x  to  y  can be obtained by writing  submat[x,y] . In  Bio.Align ,  SubstitutionMatrix  and  DichotomousSubstitutionMatrix  are two distinct types representing substitution matrices.  SubstitutionMatrix  is a general substitution matrix type that is a thin wrapper of regular matrix.  Some common substitution matrices are provided. For DNA and RNA,  EDNAFULL  is defined:  julia   EDNAFULL  Bio.Align.SubstitutionMatrix{Bio.Seq.DNANucleotide,Int64}:       A  C  G  T  M  R  W  S  Y  K  V  H  D  B  N    A  5 -4 -4 -4  1  1  1 -4 -4 -4 -1 -1 -1 -4 -2    C -4  5 -4 -4  1 -4 -4  1  1 -4 -1 -1 -4 -1 -2    G -4 -4  5 -4 -4  1 -4  1 -4  1 -1 -4 -1 -1 -2    T -4 -4 -4  5 -4 -4  1 -4  1  1 -4 -1 -1 -1 -2    M  1  1 -4 -4 -1 -2 -2 -2 -2 -4 -1 -1 -3 -3 -1    R  1 -4  1 -4 -2 -1 -2 -2 -4 -2 -1 -3 -1 -3 -1    W  1 -4 -4  1 -2 -2 -1 -4 -2 -2 -3 -1 -1 -3 -1    S -4  1  1 -4 -2 -2 -4 -1 -2 -2 -1 -3 -3 -1 -1    Y -4  1 -4  1 -2 -4 -2 -2 -1 -2 -3 -1 -3 -1 -1    K -4 -4  1  1 -4 -2 -2 -2 -2 -1 -3 -3 -1 -1 -1    V -1 -1 -1 -4 -1 -1 -3 -1 -3 -3 -1 -2 -2 -2 -1    H -1 -1 -4 -1 -1 -3 -1 -3 -1 -3 -2 -1 -2 -2 -1    D -1 -4 -1 -1 -3 -1 -1 -3 -3 -1 -2 -2 -1 -2 -1    B -4 -1 -1 -1 -3 -3 -3 -1 -1 -1 -2 -2 -2 -1 -1    N -2 -2 -2 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1  (underlined values are default ones)   For amino acids, PAM (Point Accepted Mutation) and BLOSUM (BLOcks SUbstitution Matrix) matrices are defined:  julia   BLOSUM62  Bio.Align.SubstitutionMatrix{Bio.Seq.AminoAcid,Int64}:       A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V  O  U  B  J  Z  X  *    A  4 -1 -2 -2  0 -1 -1  0 -2 -1 -1 -1 -1 -2 -1  1  0 -3 -2  0  0\u0332  0\u0332 -2  0\u0332 -1  0 -4    R -1  5  0 -2 -3  1  0 -2  0 -3 -2  2 -1 -3 -2 -1 -1 -3 -2 -3  0\u0332  0\u0332 -1  0\u0332  0 -1 -4    N -2  0  6  1 -3  0  0  0  1 -3 -3  0 -2 -3 -2  1  0 -4 -2 -3  0\u0332  0\u0332  3  0\u0332  0 -1 -4    D -2 -2  1  6 -3  0  2 -1 -1 -3 -4 -1 -3 -3 -1  0 -1 -4 -3 -3  0\u0332  0\u0332  4  0\u0332  1 -1 -4    C  0 -3 -3 -3  9 -3 -4 -3 -3 -1 -1 -3 -1 -2 -3 -1 -1 -2 -2 -1  0\u0332  0\u0332 -3  0\u0332 -3 -2 -4    Q -1  1  0  0 -3  5  2 -2  0 -3 -2  1  0 -3 -1  0 -1 -2 -1 -2  0\u0332  0\u0332  0  0\u0332  3 -1 -4    E -1  0  0  2 -4  2  5 -2  0 -3 -3  1 -2 -3 -1  0 -1 -3 -2 -2  0\u0332  0\u0332  1  0\u0332  4 -1 -4    G  0 -2  0 -1 -3 -2 -2  6 -2 -4 -4 -2 -3 -3 -2  0 -2 -2 -3 -3  0\u0332  0\u0332 -1  0\u0332 -2 -1 -4    H -2  0  1 -1 -3  0  0 -2  8 -3 -3 -1 -2 -1 -2 -1 -2 -2  2 -3  0\u0332  0\u0332  0  0\u0332  0 -1 -4    I -1 -3 -3 -3 -1 -3 -3 -4 -3  4  2 -3  1  0 -3 -2 -1 -3 -1  3  0\u0332  0\u0332 -3  0\u0332 -3 -1 -4    L -1 -2 -3 -4 -1 -2 -3 -4 -3  2  4 -2  2  0 -3 -2 -1 -2 -1  1  0\u0332  0\u0332 -4  0\u0332 -3 -1 -4    K -1  2  0 -1 -3  1  1 -2 -1 -3 -2  5 -1 -3 -1  0 -1 -3 -2 -2  0\u0332  0\u0332  0  0\u0332  1 -1 -4    M -1 -1 -2 -3 -1  0 -2 -3 -2  1  2 -1  5  0 -2 -1 -1 -1 -1  1  0\u0332  0\u0332 -3  0\u0332 -1 -1 -4    F -2 -3 -3 -3 -2 -3 -3 -3 -1  0  0 -3  0  6 -4 -2 -2  1  3 -1  0\u0332  0\u0332 -3  0\u0332 -3 -1 -4    P -1 -2 -2 -1 -3 -1 -1 -2 -2 -3 -3 -1 -2 -4  7 -1 -1 -4 -3 -2  0\u0332  0\u0332 -2  0\u0332 -1 -2 -4    S  1 -1  1  0 -1  0  0  0 -1 -2 -2  0 -1 -2 -1  4  1 -3 -2 -2  0\u0332  0\u0332  0  0\u0332  0  0 -4    T  0 -1  0 -1 -1 -1 -1 -2 -2 -1 -1 -1 -1 -2 -1  1  5 -2 -2  0  0\u0332  0\u0332 -1  0\u0332 -1  0 -4    W -3 -3 -4 -4 -2 -2 -3 -2 -2 -3 -2 -3 -1  1 -4 -3 -2 11  2 -3  0\u0332  0\u0332 -4  0\u0332 -3 -2 -4    Y -2 -2 -2 -3 -2 -1 -2 -3  2 -1 -1 -2 -1  3 -3 -2 -2  2  7 -1  0\u0332  0\u0332 -3  0\u0332 -2 -1 -4    V  0 -3 -3 -3 -1 -2 -2 -3 -3  3  1 -2  1 -1 -2 -2  0 -3 -1  4  0\u0332  0\u0332 -3  0\u0332 -2 -1 -4    O  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332    U  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332    B -2 -1  3  4 -3  0  1 -1  0 -3 -4  0 -3 -3 -2  0 -1 -4 -3 -3  0\u0332  0\u0332  4  0\u0332  1 -1 -4    J  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332    Z -1  0  0  1 -3  3  4 -2  0 -3 -3  1 -1 -3 -1  0 -1 -3 -2 -2  0\u0332  0\u0332  1  0\u0332  4 -1 -4    X  0 -1 -1 -1 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -2  0  0 -2 -1 -1  0\u0332  0\u0332 -1  0\u0332 -1 -1 -4    * -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4  0\u0332  0\u0332 -4  0\u0332 -4 -4  1  (underlined values are default ones)      Matrix  Constants      PAM  PAM30 ,  PAM70 ,  PAM250    BLOSUM  BLOSUM45 ,  BLOSUM50 ,  BLOSUM62 ,  BLOSUM80 ,  BLOSUM90     These matrices are downloaded from:  ftp://ftp.ncbi.nih.gov/blast/matrices/ .  SubstitutionMatrix  can be modified like a regular matrix:  julia   mysubmat   =   copy ( BLOSUM62 );    # create a copy  julia   mysubmat [ AA_A , AA_R ]    # score of AA_A =  AA_R substitution is -1  -1  julia   mysubmat [ AA_A , AA_R ]   =   - 3    # set the score to -3  -3  julia   mysubmat [ AA_A , AA_R ]    # the score is modified  -3   Make sure to create a copy of the original matrix when you create a matrix from a predefined matrix. In the above case,  BLOSUM62  is shared in the whole program and modification on it will affect any result that uses  BLOSUM62 .  DichotomousSubstitutionMatrix  is a specialized matrix for matching or mismatching substitution.  This is a preferable choice when performance is more important than flexibility because looking up score is faster than  SubstitutionMatrix .  julia   submat   =   DichotomousSubstitutionMatrix ( 1 ,   - 1 )  Bio.Align.DichotomousSubstitutionMatrix{Int64}:       match =  1    mismatch = -1  julia   submat [ A , A ]    # match  1  julia   submat [ A , B ]    # mismatch  -1", 
            "title": "Substitution matrices"
        }, 
        {
            "location": "/man/intervals/", 
            "text": "Intervals: Genomic Interval Manipulation\n\n\nThe \nIntervals\n module consists of tools for working efficiently with genomic intervals.\n\n\n\n\nInterval types\n\n\nIntervals in Bio.jl are consistent with ranges in Julia: \n1-based and end-inclusive\n. When data is read from formats with different representations (i.e. 0-based and/or end-exclusive) they are always converted automatically. Similarly when writing data. You should not have to reason about off-by-one errors due to format differences while using functionality provided in Bio.jl.\n\n\nThe \nInterval\n type is defined as\n\n\ntype\n Interval\n{\nT\n}\n \n:\n \nAbstractInterval\n{\nInt64\n}\n\n    \nseqname\n::\nStringField\n\n    \nfirst\n::\nInt64\n\n    \nlast\n::\nInt64\n\n    \nstrand\n::\nStrand\n\n    \nmetadata\n::\nT\n\n\nend\n\n\n\n\n\n\nSimilarly to the \nSeqRecord\n type in the \nSeq\n module, \nInterval\n is parameterized on metadata type, which lets it efficiently and precisely be specialized to represent intervals from a variety of formats.\n\n\nStrand is represented by the \nStrand\n type which can take four possible values:\n\n\nSTRAND_NA\n   \n# strand is unknown or inapplicable\n\n\nSTRAND_POS\n  \n# positive strand\n\n\nSTRAND_NEG\n  \n# negative strand\n\n\nSTRAND_BOTH\n \n# non-strand-specific feature\n\n\n\n\n\n\n\n\nCollections of intervals\n\n\nCollections of intervals are represented using the \nIntervalCollection\n type, which is a general purpose indexed container for intervals. It supports fast intersection operations as well as insertion, deletion, and sorted iteration.\n\n\nInterval collections can be initialized by inserting elements one by one using \npush!\n.\n\n\n# The type parameter (Void here) indicates the interval metadata type.\n\n\nincol\n \n=\n \nIntervalCollection\n{\nVoid\n}()\n\n\n\nfor\n \ni\n \nin\n \n1\n:\n100\n:\n10000\n\n    \npush!\n(\nincol\n,\n \nInterval\n(\nchr1\n,\n \ni\n,\n \ni\n \n+\n \n99\n,\n \nSTRAND_POS\n,\n \nnothing\n))\n\n\nend\n\n\n\n\n\n\nIncrementally building an interval collection like this works, but \nIntervalCollection\n also has a bulk insertion constructor that is able to build the indexed data structure extremely efficiently from an array of intervals.\n\n\nincol\n \n=\n \nIntervalCollection\n([\nInterval\n(\nchr1\n,\n \ni\n,\n \ni\n \n+\n \n99\n,\n \nSTRAND_POS\n,\n \nnothing\n)\n \nfor\n \ni\n \nin\n \n1\n:\n100\n:\n10000\n])\n\n\n\n\n\n\nBulding \nIntervalCollections\n in one shot like this should be preferred when it's convenient or speed in an issue.\n\n\n\n\nIntersection\n\n\nThere are number of \nintersect\n function in the Intervals module. They follow two patterns: interval versus collection queries which return an iterator over intervals in the collection that intersect the query, and collection versus collection queries which iterate over all pairs of intersecting intervals.\n\n\n#\n\n\nBase.intersect\n \n \nFunction\n.\n\n\nintersect(s1,s2...)\n\u2229(s1,s2)\n\n\n\n\n\nConstruct the intersection of two or more sets. Maintains order and multiplicity of the first argument for arrays and ranges.\n\n\nsource\n\n\n\n\nInterval streams\n\n\nIntervals need not necessarily stored in an indexed data structure for efficient intersection to be practical. Two collections of intervals need only be both sorted to compute all intersecting pairs. This is particularly useful in genomics where datasets are sometimes so large that loading them entirely into memory is not practical.\n\n\nThe Intervals module is able to intersect any two iterators that yield intervals in sorted order, which we refer to as \"interval streams\". An \nIntervalCollection\n is also a interval stream, but so is a sorted array of intervals, and parsers over interval file formats. This allows for a very general notion of intersection.\n\n\nfor\n \n(\nx\n,\n \ny\n)\n \nin\n \nintersect\n(\nopen\n(\nx_features.bed\n,\n \nBED\n),\n \nopen\n(\ny_features.bed\n,\n \nBED\n))\n\n    \nprintln\n(\nIntersection found between \n,\n \nx\n,\n \n and \n,\n \ny\n)\n\n\nend\n\n\n\n\n\n\nAn exception will be thrown if an interval in encountered out of order while processing an interval stream. Ordering of intervals has one complication: there is not necessarily a standardized way to order sequence names. By default in Bio.jl intervals are sorted using a special \nalphanum_isless\n comparison function that compares numbers numerically if they exist in string, so that names like \nchr1, chr2, chr10\n end up in their natural order.\n\n\nThe \nintersect\n function takes as an optional parameter an \nisless\n function to use to compare sequence names to account for arbitrary sequence name orderings.\n\n\n# assume lexigraphic ordering for sequence names\n\n\nfor\n \n(\nx\n,\n \ny\n)\n \nin\n \nintersect\n(\nxs\n,\n \nys\n,\n \nisless\n)\n\n    \nprintln\n(\nIntersection found between \n,\n \na\n,\n \n and \n,\n \nb\n)\n\n\nend\n\n\n\n\n\n\nA special sort of intersection can also be performed on a \nIntervalStreams\n against itself to produce \"coverage intervals\".\n\n\n#\n\n\nBio.Intervals.coverage\n \n \nFunction\n.\n\n\nCompute the coverage of a collection of intervals.\n\n\nArguments\n\n\n\n\nintervals\n: any IntervalStream\n\n\n\n\nReturns\n\n\nAn IntervalCollection that contains run-length encoded coverage data.\n\n\nE.g. for intervals like\n\n\n```{execute=\"false\"}\n    [------]     [------------]\n       [---------------]\n\n\nthis function would return a new set of disjoint intervals with annotated coverage like:\n\n```{execute=\nfalse\n}\n    [1][-2-][-1-][--2--][--1--]\n\n\n\n\n\nsource", 
            "title": "Intervals"
        }, 
        {
            "location": "/man/intervals/#intervals-genomic-interval-manipulation", 
            "text": "The  Intervals  module consists of tools for working efficiently with genomic intervals.", 
            "title": "Intervals: Genomic Interval Manipulation"
        }, 
        {
            "location": "/man/intervals/#interval-types", 
            "text": "Intervals in Bio.jl are consistent with ranges in Julia:  1-based and end-inclusive . When data is read from formats with different representations (i.e. 0-based and/or end-exclusive) they are always converted automatically. Similarly when writing data. You should not have to reason about off-by-one errors due to format differences while using functionality provided in Bio.jl.  The  Interval  type is defined as  type  Interval { T }   :   AbstractInterval { Int64 } \n     seqname :: StringField \n     first :: Int64 \n     last :: Int64 \n     strand :: Strand \n     metadata :: T  end   Similarly to the  SeqRecord  type in the  Seq  module,  Interval  is parameterized on metadata type, which lets it efficiently and precisely be specialized to represent intervals from a variety of formats.  Strand is represented by the  Strand  type which can take four possible values:  STRAND_NA     # strand is unknown or inapplicable  STRAND_POS    # positive strand  STRAND_NEG    # negative strand  STRAND_BOTH   # non-strand-specific feature", 
            "title": "Interval types"
        }, 
        {
            "location": "/man/intervals/#collections-of-intervals", 
            "text": "Collections of intervals are represented using the  IntervalCollection  type, which is a general purpose indexed container for intervals. It supports fast intersection operations as well as insertion, deletion, and sorted iteration.  Interval collections can be initialized by inserting elements one by one using  push! .  # The type parameter (Void here) indicates the interval metadata type.  incol   =   IntervalCollection { Void }()  for   i   in   1 : 100 : 10000 \n     push! ( incol ,   Interval ( chr1 ,   i ,   i   +   99 ,   STRAND_POS ,   nothing ))  end   Incrementally building an interval collection like this works, but  IntervalCollection  also has a bulk insertion constructor that is able to build the indexed data structure extremely efficiently from an array of intervals.  incol   =   IntervalCollection ([ Interval ( chr1 ,   i ,   i   +   99 ,   STRAND_POS ,   nothing )   for   i   in   1 : 100 : 10000 ])   Bulding  IntervalCollections  in one shot like this should be preferred when it's convenient or speed in an issue.", 
            "title": "Collections of intervals"
        }, 
        {
            "location": "/man/intervals/#intersection", 
            "text": "There are number of  intersect  function in the Intervals module. They follow two patterns: interval versus collection queries which return an iterator over intervals in the collection that intersect the query, and collection versus collection queries which iterate over all pairs of intersecting intervals.  #  Base.intersect     Function .  intersect(s1,s2...)\n\u2229(s1,s2)  Construct the intersection of two or more sets. Maintains order and multiplicity of the first argument for arrays and ranges.  source", 
            "title": "Intersection"
        }, 
        {
            "location": "/man/intervals/#interval-streams", 
            "text": "Intervals need not necessarily stored in an indexed data structure for efficient intersection to be practical. Two collections of intervals need only be both sorted to compute all intersecting pairs. This is particularly useful in genomics where datasets are sometimes so large that loading them entirely into memory is not practical.  The Intervals module is able to intersect any two iterators that yield intervals in sorted order, which we refer to as \"interval streams\". An  IntervalCollection  is also a interval stream, but so is a sorted array of intervals, and parsers over interval file formats. This allows for a very general notion of intersection.  for   ( x ,   y )   in   intersect ( open ( x_features.bed ,   BED ),   open ( y_features.bed ,   BED )) \n     println ( Intersection found between  ,   x ,    and  ,   y )  end   An exception will be thrown if an interval in encountered out of order while processing an interval stream. Ordering of intervals has one complication: there is not necessarily a standardized way to order sequence names. By default in Bio.jl intervals are sorted using a special  alphanum_isless  comparison function that compares numbers numerically if they exist in string, so that names like  chr1, chr2, chr10  end up in their natural order.  The  intersect  function takes as an optional parameter an  isless  function to use to compare sequence names to account for arbitrary sequence name orderings.  # assume lexigraphic ordering for sequence names  for   ( x ,   y )   in   intersect ( xs ,   ys ,   isless ) \n     println ( Intersection found between  ,   a ,    and  ,   b )  end   A special sort of intersection can also be performed on a  IntervalStreams  against itself to produce \"coverage intervals\".  #  Bio.Intervals.coverage     Function .  Compute the coverage of a collection of intervals.  Arguments   intervals : any IntervalStream   Returns  An IntervalCollection that contains run-length encoded coverage data.  E.g. for intervals like  ```{execute=\"false\"}\n    [------]     [------------]\n       [---------------]  this function would return a new set of disjoint intervals with annotated coverage like:\n\n```{execute= false }\n    [1][-2-][-1-][--2--][--1--]  source", 
            "title": "Interval streams"
        }, 
        {
            "location": "/man/var/", 
            "text": "Bio.Var: Biological Variation.\n\n\n\n\nCounting mutations\n\n\nYou can count the numbers of different types of mutations between two aligned (i.e. of equal length) nucleotide sequences.\n\n\n\n\nDifferent types of mutation\n\n\nThe types of mutations that can currently be counted are displayed in the following table.\n\n\n\n\n\n\n\n\nType\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nDifferentMutation\n\n\nNucleotides that are different\n\n\n\n\n\n\nTransitionMutation\n\n\nTransition mutations\n\n\n\n\n\n\nTransversionMutation\n\n\nTransversion mutations\n\n\n\n\n\n\n\n\nDifferentMutation\n simply compares two nucleotides to see if they can be deemed the same or different. Ambiguous cases are detected and excluded from the computation.\n\n\nTransitionMutation\n compares two nucleotides to see if they can be determined to be a transition mutation. As with \nDifferentMutation\n, cases where a nucleotide is ambiguous are excluded from the computation.\n\n\nTransversionMutation\n compares two nucleotides to see if they can be determined to be a transversion mutation. As with \nDifferentMutation\n, cases where a nucleotide is ambiguous are excluded from the computation.\n\n\n\n\ncount_mutations\n method\n\n\nMutations are counted using the \ncount_mutations\n method. The method outputs a tuple. The first value is the number of mutations counted. The second value is the number of sites examined. Sites which have gaps and uncertain nucleotides are not examined and so this second value will be less than the length of the two biological sequences.\n\n\ncount_mutations\n(\ndna\nATCGATCG\n,\n \ndna\nACCGATCG\n,\n \nDifferentMutation\n)\n\n\n\ncount_mutations\n(\ndna\nATCGATCG\n,\n \ndna\nACCGATCG\n,\n \nTransitionMutation\n)\n\n\n\ncount_mutations\n(\ndna\nATCGATCG\n,\n \ndna\nACCGATCG\n,\n \nTransversionMutation\n)\n\n\n\ncount_mutations\n(\ndna\nATCGATCG\n,\n \ndna\nACCGATCG\n,\n \nTransitionMutation\n,\n \nTransversionMutation\n)\n\n\n\ncount_mutations\n(\nrna\nAUCGAUCG\n,\n \nrna\nACCGAUCG\n,\n \nDifferentMutation\n)\n\n\n\ncount_mutations\n(\nrna\nAUCGAUCG\n,\n \nrna\nACCGAUCG\n,\n \nTransitionMutation\n)\n\n\n\ncount_mutations\n(\nrna\nAUCGAUCG\n,\n \nrna\nACCGAUCG\n,\n \nTransversionMutation\n)\n\n\n\ncount_mutations\n(\nrna\nAUCGAUCG\n,\n \nrna\nACCGAUCG\n,\n \nTransitionMutation\n,\n \nTransversionMutation\n)\n\n\n\n\n\n\n\n\nComputing evolutionary and genetic distances\n\n\nJust as you can count the number of mutations between two nucleotide sequences, you can compute the evolutionary distance between two nucleotide sequences.\n\n\n\n\nDifferent evolutionary distance measures\n\n\nThe types of distances that can currently be computed are described below.\n\n\n#\n\n\nBio.Var.Count\n \n \nType\n.\n\n\nA distance which is the count of the mutations of type T that exist between the two sequences.\n\n\nsource\n\n\n#\n\n\nBio.Var.Proportion\n \n \nType\n.\n\n\nProportion{T} is a distance which is the count of the mutations of type T that exist between the two biological sequences, divided by the number of valid sites examined (sites which don't have gap or ambiguous symbols).\n\n\nIn other words this so called p-distance is simply the proportion of sites between each pair of sequences, that are mutated (again where T determines what kind of mutation).\n\n\nsource\n\n\n#\n\n\nBio.Var.JukesCantor69\n \n \nType\n.\n\n\nThe JukesCantor69 distance is a p-distance adjusted/corrected by the substitution model developed by Jukes and Cantor in 1969.\n\n\nThe Jukes and Cantor model assumes that all substitutions (i.e. a change of a base by another one) have the same probability. This probability is the same for all sites along the DNA sequence.\n\n\nsource\n\n\n#\n\n\nBio.Var.Kimura80\n \n \nType\n.\n\n\nThe Kimura80 distance uses a substitution model developed by Kimura in 1980. It is somtimes called Kimura's 2 parameter distance.\n\n\nThe model makes the same assumptions as Jukes and Cantor's model, but with a crucial difference: two-kinds of mutation are considered called Transitions and Transversions. Transitions and transversions can occur with different probabilities in this model, however, both transition and transversion rates/probabilities are the same for all sites along the DNA sequence.\n\n\nsource\n\n\n\n\nThe distance method\n\n\n#\n\n\nBio.Var.distance\n \n \nFunction\n.\n\n\ndistance(::Type{EvolutionaryDistance}, a::BioSequence, b::BioSequence)\n\n\n\n\n\nCompute the genetic distance between two nucleotide sequences of equal length.\n\n\nThe distance measure to compute is determined by the type provided as the first parameter. The second and third parameter provide the two nucleotide sequences.\n\n\nsource", 
            "title": "Biological Variation"
        }, 
        {
            "location": "/man/var/#biovar-biological-variation", 
            "text": "", 
            "title": "Bio.Var: Biological Variation."
        }, 
        {
            "location": "/man/var/#counting-mutations", 
            "text": "You can count the numbers of different types of mutations between two aligned (i.e. of equal length) nucleotide sequences.", 
            "title": "Counting mutations"
        }, 
        {
            "location": "/man/var/#different-types-of-mutation", 
            "text": "The types of mutations that can currently be counted are displayed in the following table.     Type  Meaning      DifferentMutation  Nucleotides that are different    TransitionMutation  Transition mutations    TransversionMutation  Transversion mutations     DifferentMutation  simply compares two nucleotides to see if they can be deemed the same or different. Ambiguous cases are detected and excluded from the computation.  TransitionMutation  compares two nucleotides to see if they can be determined to be a transition mutation. As with  DifferentMutation , cases where a nucleotide is ambiguous are excluded from the computation.  TransversionMutation  compares two nucleotides to see if they can be determined to be a transversion mutation. As with  DifferentMutation , cases where a nucleotide is ambiguous are excluded from the computation.", 
            "title": "Different types of mutation"
        }, 
        {
            "location": "/man/var/#count_mutations-method", 
            "text": "Mutations are counted using the  count_mutations  method. The method outputs a tuple. The first value is the number of mutations counted. The second value is the number of sites examined. Sites which have gaps and uncertain nucleotides are not examined and so this second value will be less than the length of the two biological sequences.  count_mutations ( dna ATCGATCG ,   dna ACCGATCG ,   DifferentMutation )  count_mutations ( dna ATCGATCG ,   dna ACCGATCG ,   TransitionMutation )  count_mutations ( dna ATCGATCG ,   dna ACCGATCG ,   TransversionMutation )  count_mutations ( dna ATCGATCG ,   dna ACCGATCG ,   TransitionMutation ,   TransversionMutation )  count_mutations ( rna AUCGAUCG ,   rna ACCGAUCG ,   DifferentMutation )  count_mutations ( rna AUCGAUCG ,   rna ACCGAUCG ,   TransitionMutation )  count_mutations ( rna AUCGAUCG ,   rna ACCGAUCG ,   TransversionMutation )  count_mutations ( rna AUCGAUCG ,   rna ACCGAUCG ,   TransitionMutation ,   TransversionMutation )", 
            "title": "count_mutations method"
        }, 
        {
            "location": "/man/var/#computing-evolutionary-and-genetic-distances", 
            "text": "Just as you can count the number of mutations between two nucleotide sequences, you can compute the evolutionary distance between two nucleotide sequences.", 
            "title": "Computing evolutionary and genetic distances"
        }, 
        {
            "location": "/man/var/#different-evolutionary-distance-measures", 
            "text": "The types of distances that can currently be computed are described below.  #  Bio.Var.Count     Type .  A distance which is the count of the mutations of type T that exist between the two sequences.  source  #  Bio.Var.Proportion     Type .  Proportion{T} is a distance which is the count of the mutations of type T that exist between the two biological sequences, divided by the number of valid sites examined (sites which don't have gap or ambiguous symbols).  In other words this so called p-distance is simply the proportion of sites between each pair of sequences, that are mutated (again where T determines what kind of mutation).  source  #  Bio.Var.JukesCantor69     Type .  The JukesCantor69 distance is a p-distance adjusted/corrected by the substitution model developed by Jukes and Cantor in 1969.  The Jukes and Cantor model assumes that all substitutions (i.e. a change of a base by another one) have the same probability. This probability is the same for all sites along the DNA sequence.  source  #  Bio.Var.Kimura80     Type .  The Kimura80 distance uses a substitution model developed by Kimura in 1980. It is somtimes called Kimura's 2 parameter distance.  The model makes the same assumptions as Jukes and Cantor's model, but with a crucial difference: two-kinds of mutation are considered called Transitions and Transversions. Transitions and transversions can occur with different probabilities in this model, however, both transition and transversion rates/probabilities are the same for all sites along the DNA sequence.  source", 
            "title": "Different evolutionary distance measures"
        }, 
        {
            "location": "/man/var/#the-distance-method", 
            "text": "#  Bio.Var.distance     Function .  distance(::Type{EvolutionaryDistance}, a::BioSequence, b::BioSequence)  Compute the genetic distance between two nucleotide sequences of equal length.  The distance measure to compute is determined by the type provided as the first parameter. The second and third parameter provide the two nucleotide sequences.  source", 
            "title": "The distance method"
        }, 
        {
            "location": "/man/structure/", 
            "text": "Bio.Structure: Macromolecular Structures\n\n\nThe \nBio.Structure\n module provides functionality to read Protein Data Bank (PDB) files and manipulate macromolecular structures.\n\n\n\n\nParsing PDB files\n\n\nTo download a PDB file:\n\n\ndownloadpdb\n(\n1EN2\n)\n\n\n\n\n\n\nTo parse a PDB file into a Structure-Model-Chain-Residue-Atom framework:\n\n\njulia\n \nstruc\n \n=\n \nread\n(\nfilepath_1EN2\n,\n \nPDB\n)\n\n\nName\n                        \n-\n  \n1\nEN2\n.\npdb\n\n\nNumber\n \nof\n \nmodels\n            \n-\n  \n1\n\n\nChain\n(\ns\n)\n                    \n-\n  \nA\n\n\nNumber\n \nof\n \nresidues\n          \n-\n  \n85\n\n\nNumber\n \nof\n \npoint\n \nmutations\n   \n-\n  \n5\n\n\nNumber\n \nof\n \nother\n \nmolecules\n   \n-\n  \n5\n\n\nNumber\n \nof\n \nwater\n \nmolecules\n   \n-\n  \n76\n\n\nNumber\n \nof\n \natoms\n             \n-\n  \n614\n\n\nNumber\n \nof\n \nhydrogens\n         \n-\n  \n0\n\n\nNumber\n \nof\n \ndisordered\n \natoms\n  \n-\n  \n27\n\n\n\n\n\n\nThe elements of \nstruc\n can be accessed as follows:\n\n\n\n\n\n\n\n\nCommand\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nstruc[1]\n\n\nModel 1\n\n\n\n\n\n\nstruc[1]['A']\n\n\nModel 1, chain A\n\n\n\n\n\n\nstruc['A']\n\n\nThe lowest model (model 1), chain A\n\n\n\n\n\n\nstruc['A'][\"50\"]\n\n\nModel 1, chain A, residue 50\n\n\n\n\n\n\nstruc['A'][50]\n\n\nShortcut to above if it is not a hetero residue and the insertion code is blank\n\n\n\n\n\n\nstruc['A'][\"H_90\"]\n\n\nModel 1, chain A, hetero residue 90\n\n\n\n\n\n\nstruc['A'][50][\"CA\"]\n\n\nModel 1, chain A, residue 50, atom name CA\n\n\n\n\n\n\nstruc['A'][15][\"CG\"]['A']\n\n\nFor disordered atoms, access a specific location\n\n\n\n\n\n\nstruc['A'][15][\"CG\"]\n\n\nFor disordered atoms, access the default location\n\n\n\n\n\n\n\n\nDisordered atoms are stored in a \nDisorderedAtom\n container but calls fall back to the default atom, so disorder can be ignored if you are not interested in it.\n\n\nDisordered residues (i.e. point mutations with different residue names) are stored in a \nDisorderedResidue\n container.\n\n\nThe idea is that disorder will only bother you if you want it to. See the \nBiopython discussion\n for more.\n\n\nProperties can be retrieved as follows:\n\n\n\n\n\n\n\n\nCommand\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nstructurename(struc)\n\n\nName of a structure\n\n\n\n\n\n\nmodelnumbers(struc)\n\n\nModel numbers in a structure\n\n\n\n\n\n\nchainids(struc)\n\n\nChain IDs in a structure\n\n\n\n\n\n\nmodelnumber(model)\n\n\nNumber of a model\n\n\n\n\n\n\nchainids(model)\n\n\nChain IDs in a model\n\n\n\n\n\n\nchainid(chain)\n\n\nChain ID of a chain\n\n\n\n\n\n\nresids(chain)\n\n\nResidue IDs in a chain\n\n\n\n\n\n\nresname(res)\n\n\nName of a residue\n\n\n\n\n\n\nchainid(res)\n\n\nChain ID of a residue\n\n\n\n\n\n\nresnumber(res)\n\n\nResidue number of a residue\n\n\n\n\n\n\ninscode(res)\n\n\nInsertion code of a residue\n\n\n\n\n\n\nishetres(res)\n\n\ntrue\n if the residue consists of hetero atoms\n\n\n\n\n\n\natomnames(res)\n\n\nAtom names in a residue\n\n\n\n\n\n\nisdisorderedres(res)\n\n\ntrue\n if the residue has multiple residue names\n\n\n\n\n\n\nresid(res)\n\n\nResidue ID of a residue\n\n\n\n\n\n\nishetatom(atom)\n\n\ntrue\n if the atom is a hetero atom\n\n\n\n\n\n\nserial(atom)\n\n\nSerial number of an atom\n\n\n\n\n\n\natomname(atom)\n\n\nName of an atom\n\n\n\n\n\n\naltlocid(atom)\n\n\nAlternative location ID of an atom\n\n\n\n\n\n\nresname(atom)\n\n\nResidue name of an atom\n\n\n\n\n\n\nchainid(atom)\n\n\nChain ID of an atom\n\n\n\n\n\n\nresnumber(atom)\n\n\nResidue number of an atom\n\n\n\n\n\n\ninscode(atom)\n\n\nInsertion code of an atom\n\n\n\n\n\n\nx(atom)\n\n\nx coordinate of an atom\n\n\n\n\n\n\ny(atom)\n\n\ny coordinate of an atom\n\n\n\n\n\n\nz(atom)\n\n\nz coordinate of an atom\n\n\n\n\n\n\ncoords(atom)\n\n\ncoordinates of an atom as a \nVector{Float64}\n\n\n\n\n\n\noccupancy(atom)\n\n\nOccupancy of an atom (default is \n1.0\n)\n\n\n\n\n\n\ntempfac(atom)\n\n\nTemperature factor of an atom (default is \n0.0\n)\n\n\n\n\n\n\nelement(atom)\n\n\nElement of an atom (default is \n\"\"\n)\n\n\n\n\n\n\ncharge(atom)\n\n\nCharge of an atom (default is \n\"\"\n)\n\n\n\n\n\n\nisdisorderedatom(atom)\n\n\ntrue\n if the atom is disordered\n\n\n\n\n\n\nresid(atom)\n\n\nResidue ID of an atom\n\n\n\n\n\n\n\n\nThe coordinates of an atom can be set using \nx!\n, \ny!\n, \nz!\n and \ncoords!\n.\n\n\n\n\nManipulating Structures\n\n\nElements can be looped over to reveal the sub-elements in the correct order:\n\n\nfor\n \nmodel\n \nin\n \nstruc\n\n    \nfor\n \nchain\n \nin\n \nmodel\n\n        \nfor\n \nres\n \nin\n \nchain\n\n            \nfor\n \natom\n \nin\n \nres\n\n                \n# Do something\n\n            \nend\n\n        \nend\n\n    \nend\n\n\nend\n\n\n\n\n\n\ncollect\n, \ncollectresidues\n and \ncollectatoms\n can be used to get lists of sub-elements.\n\n\nSelectors are functions passed as additional arguments to \ncollectresidues\n and \ncollectatoms\n. Only residues/atoms that return \ntrue\n when passed to the selector are retained.\n\n\n\n\n\n\n\n\nCommand\n\n\nAction\n\n\n\n\n\n\n\n\n\n\ncollect(struc['A'][50])\n\n\nCollect the sub-elements of an element, e.g. atoms from a residue\n\n\n\n\n\n\ncollectresidues(struc)\n\n\nCollect the residues of an element\n\n\n\n\n\n\ncollectatoms(struc)\n\n\nCollect the atoms of an element\n\n\n\n\n\n\ncollectatoms(struc, calphaselector)\n\n\nCollect the C-alpha atoms of an element\n\n\n\n\n\n\ncollectatoms(struc, calphaselector, disorderselector)\n\n\nCollect the disordered C-alpha atoms of an element\n\n\n\n\n\n\n\n\nIt is easy to define your own selector. The below will collect all atoms with x coordinate less than 0:\n\n\nxselector\n(\natom\n::\nAbstractAtom\n)\n \n=\n \nx\n(\natom\n)\n \n \n0\n\n\ncollectatoms\n(\nstruc\n,\n \nxselector\n)\n\n\n\n\n\n\ncountmodels\n, \ncountchains\n, \ncountresidues\n and \ncountatoms\n can be used to count elements. For example:\n\n\njulia\n \ncountatoms\n(\nstruc\n)\n\n\n754\n\n\n\njulia\n \ncountatoms\n(\nstruc\n,\n \ncalphaselector\n)\n\n\n85\n\n\n\njulia\n \ncountresidues\n(\nstruc\n,\n \nstdresselector\n)\n\n\n85\n\n\n\n\n\n\norganise\n, \norganisemodel\n and \norganisestruc\n can be used to organise sub-elements into elements:\n\n\n\n\n\n\n\n\nCommand\n\n\nAction\n\n\n\n\n\n\n\n\n\n\norganise(collectatoms(struc))\n\n\nOrganise an atom list into a residue list\n\n\n\n\n\n\norganise(collectresidues(struc))\n\n\nOrganise a residue list into a chain list\n\n\n\n\n\n\norganise(struc['A'])\n\n\nOrganise chain(s) into a model\n\n\n\n\n\n\norganise(struc[1])\n\n\nOrganise model(s) into a structure\n\n\n\n\n\n\norganisemodel(collectatoms(struc))\n\n\nOrganise elements into a model\n\n\n\n\n\n\norganisestructure(collectatoms(struc))\n\n\nOrganise elements into a structure\n\n\n\n\n\n\n\n\nDistances can be calculated. The minimum distance between residue 10 and 20 is:\n\n\njulia\n \ndistance\n(\nstruc\n[\nA\n][\n10\n],\n \nstruc\n[\nA\n][\n20\n])\n\n\n10.782158874733762\n\n\n\n\n\n\nRMSDs/displacements between elements of the same size can also be calculated with \nrmsd\n and \ndisplacements\n.\n\n\n\n\nWriting PDB files\n\n\nPDB format files can be written:\n\n\nwritepdb\n(\n1EN2_out.pdb\n,\n \nstruc\n)\n\n\n\n\n\n\nAny element type can be given as input. Selectors can also be given as additional arguments:\n\n\nwritepdb\n(\n1EN2_out.pdb\n,\n \nstruc\n,\n \nbackboneselector\n)\n\n\n\n\n\n\n\n\nExamples\n\n\nA few examples of \nBio.Structure\n usage are given below.\n\n\nA)\n To plot the temperature factors of a protein, if you have Gadfly installed:\n\n\nusing\n \nGadfly\n\n\natoms\n \n=\n \ncollectatoms\n(\nstruc\n,\n \ncalphaselector\n)\n\n\nres_numbers\n \n=\n \nmap\n(\nresnumber\n,\n \natoms\n)\n\n\ntemp_facs\n \n=\n \nmap\n(\ntempfac\n,\n \natoms\n)\n\n\nplot\n(\nx\n=\nres_numbers\n,\n \ny\n=\ntemp_facs\n,\n \nGeom\n.\nline\n)\n\n\n\n\n\n\nB)\n To find all C-alpha atoms within 5 Angstroms of residue 38:\n\n\nfor\n \natom\n \nin\n \natoms\n\n    \nif\n \ndistance\n(\nstruc\n[\nA\n][\n38\n],\n \natom\n)\n \n \n5.0\n \n \nresnumber\n(\natom\n)\n \n!=\n \n38\n\n        \nshow\n(\natom\n)\n\n    \nend\n\n\nend\n\n\n\n\n\n\nC)\n To calculate the RMSD and displacements between the heavy (non-hydrogen) atoms of two models in an NMR structure:\n\n\ndownloadpdb\n(\n1SSU\n)\n\n\nstruc_nmr\n \n=\n \nread\n(\n1SSU.pdb\n,\n \nPDB\n)\n\n\nrmsd\n(\nstruc_nmr\n[\n5\n],\n \nstruc_nmr\n[\n10\n],\n \nheavyatomselector\n)\n\n\ndisplacements\n(\nstruc_nmr\n[\n5\n],\n \nstruc_nmr\n[\n10\n],\n \nheavyatomselector\n)", 
            "title": "Structure"
        }, 
        {
            "location": "/man/structure/#biostructure-macromolecular-structures", 
            "text": "The  Bio.Structure  module provides functionality to read Protein Data Bank (PDB) files and manipulate macromolecular structures.", 
            "title": "Bio.Structure: Macromolecular Structures"
        }, 
        {
            "location": "/man/structure/#parsing-pdb-files", 
            "text": "To download a PDB file:  downloadpdb ( 1EN2 )   To parse a PDB file into a Structure-Model-Chain-Residue-Atom framework:  julia   struc   =   read ( filepath_1EN2 ,   PDB )  Name                          -    1 EN2 . pdb  Number   of   models              -    1  Chain ( s )                      -    A  Number   of   residues            -    85  Number   of   point   mutations     -    5  Number   of   other   molecules     -    5  Number   of   water   molecules     -    76  Number   of   atoms               -    614  Number   of   hydrogens           -    0  Number   of   disordered   atoms    -    27   The elements of  struc  can be accessed as follows:     Command  Returns      struc[1]  Model 1    struc[1]['A']  Model 1, chain A    struc['A']  The lowest model (model 1), chain A    struc['A'][\"50\"]  Model 1, chain A, residue 50    struc['A'][50]  Shortcut to above if it is not a hetero residue and the insertion code is blank    struc['A'][\"H_90\"]  Model 1, chain A, hetero residue 90    struc['A'][50][\"CA\"]  Model 1, chain A, residue 50, atom name CA    struc['A'][15][\"CG\"]['A']  For disordered atoms, access a specific location    struc['A'][15][\"CG\"]  For disordered atoms, access the default location     Disordered atoms are stored in a  DisorderedAtom  container but calls fall back to the default atom, so disorder can be ignored if you are not interested in it.  Disordered residues (i.e. point mutations with different residue names) are stored in a  DisorderedResidue  container.  The idea is that disorder will only bother you if you want it to. See the  Biopython discussion  for more.  Properties can be retrieved as follows:     Command  Returns      structurename(struc)  Name of a structure    modelnumbers(struc)  Model numbers in a structure    chainids(struc)  Chain IDs in a structure    modelnumber(model)  Number of a model    chainids(model)  Chain IDs in a model    chainid(chain)  Chain ID of a chain    resids(chain)  Residue IDs in a chain    resname(res)  Name of a residue    chainid(res)  Chain ID of a residue    resnumber(res)  Residue number of a residue    inscode(res)  Insertion code of a residue    ishetres(res)  true  if the residue consists of hetero atoms    atomnames(res)  Atom names in a residue    isdisorderedres(res)  true  if the residue has multiple residue names    resid(res)  Residue ID of a residue    ishetatom(atom)  true  if the atom is a hetero atom    serial(atom)  Serial number of an atom    atomname(atom)  Name of an atom    altlocid(atom)  Alternative location ID of an atom    resname(atom)  Residue name of an atom    chainid(atom)  Chain ID of an atom    resnumber(atom)  Residue number of an atom    inscode(atom)  Insertion code of an atom    x(atom)  x coordinate of an atom    y(atom)  y coordinate of an atom    z(atom)  z coordinate of an atom    coords(atom)  coordinates of an atom as a  Vector{Float64}    occupancy(atom)  Occupancy of an atom (default is  1.0 )    tempfac(atom)  Temperature factor of an atom (default is  0.0 )    element(atom)  Element of an atom (default is  \"\" )    charge(atom)  Charge of an atom (default is  \"\" )    isdisorderedatom(atom)  true  if the atom is disordered    resid(atom)  Residue ID of an atom     The coordinates of an atom can be set using  x! ,  y! ,  z!  and  coords! .", 
            "title": "Parsing PDB files"
        }, 
        {
            "location": "/man/structure/#manipulating-structures", 
            "text": "Elements can be looped over to reveal the sub-elements in the correct order:  for   model   in   struc \n     for   chain   in   model \n         for   res   in   chain \n             for   atom   in   res \n                 # Do something \n             end \n         end \n     end  end   collect ,  collectresidues  and  collectatoms  can be used to get lists of sub-elements.  Selectors are functions passed as additional arguments to  collectresidues  and  collectatoms . Only residues/atoms that return  true  when passed to the selector are retained.     Command  Action      collect(struc['A'][50])  Collect the sub-elements of an element, e.g. atoms from a residue    collectresidues(struc)  Collect the residues of an element    collectatoms(struc)  Collect the atoms of an element    collectatoms(struc, calphaselector)  Collect the C-alpha atoms of an element    collectatoms(struc, calphaselector, disorderselector)  Collect the disordered C-alpha atoms of an element     It is easy to define your own selector. The below will collect all atoms with x coordinate less than 0:  xselector ( atom :: AbstractAtom )   =   x ( atom )     0  collectatoms ( struc ,   xselector )   countmodels ,  countchains ,  countresidues  and  countatoms  can be used to count elements. For example:  julia   countatoms ( struc )  754  julia   countatoms ( struc ,   calphaselector )  85  julia   countresidues ( struc ,   stdresselector )  85   organise ,  organisemodel  and  organisestruc  can be used to organise sub-elements into elements:     Command  Action      organise(collectatoms(struc))  Organise an atom list into a residue list    organise(collectresidues(struc))  Organise a residue list into a chain list    organise(struc['A'])  Organise chain(s) into a model    organise(struc[1])  Organise model(s) into a structure    organisemodel(collectatoms(struc))  Organise elements into a model    organisestructure(collectatoms(struc))  Organise elements into a structure     Distances can be calculated. The minimum distance between residue 10 and 20 is:  julia   distance ( struc [ A ][ 10 ],   struc [ A ][ 20 ])  10.782158874733762   RMSDs/displacements between elements of the same size can also be calculated with  rmsd  and  displacements .", 
            "title": "Manipulating Structures"
        }, 
        {
            "location": "/man/structure/#writing-pdb-files", 
            "text": "PDB format files can be written:  writepdb ( 1EN2_out.pdb ,   struc )   Any element type can be given as input. Selectors can also be given as additional arguments:  writepdb ( 1EN2_out.pdb ,   struc ,   backboneselector )", 
            "title": "Writing PDB files"
        }, 
        {
            "location": "/man/structure/#examples", 
            "text": "A few examples of  Bio.Structure  usage are given below.  A)  To plot the temperature factors of a protein, if you have Gadfly installed:  using   Gadfly  atoms   =   collectatoms ( struc ,   calphaselector )  res_numbers   =   map ( resnumber ,   atoms )  temp_facs   =   map ( tempfac ,   atoms )  plot ( x = res_numbers ,   y = temp_facs ,   Geom . line )   B)  To find all C-alpha atoms within 5 Angstroms of residue 38:  for   atom   in   atoms \n     if   distance ( struc [ A ][ 38 ],   atom )     5.0     resnumber ( atom )   !=   38 \n         show ( atom ) \n     end  end   C)  To calculate the RMSD and displacements between the heavy (non-hydrogen) atoms of two models in an NMR structure:  downloadpdb ( 1SSU )  struc_nmr   =   read ( 1SSU.pdb ,   PDB )  rmsd ( struc_nmr [ 5 ],   struc_nmr [ 10 ],   heavyatomselector )  displacements ( struc_nmr [ 5 ],   struc_nmr [ 10 ],   heavyatomselector )", 
            "title": "Examples"
        }, 
        {
            "location": "/man/util/", 
            "text": "Bio.Util: Utility Functions\n\n\nThe \nBio.Util\n module provides utility functions commonly used in bioinformatics.\n\n\n\n\nLabelled square matrix parsers\n\n\nThis module contains a function \nreadlsm\n, that reads labelled square matrices.\n\n\nSuch matrices are commonly used to store pairwise measures of similarity or dissimilarity between two sets. This format consists of a delimited file, with text labels on the upper and left sides of a square matrix. Such matrices are often but not exclusively symmetric.\n\n\nAn example would be:\n\n\n    A   B\nA   1   2\nB   2   1\n\n\n\n\n\n(Note that we use spaces as a delimiter, where tabs would normally be used)", 
            "title": "Util"
        }, 
        {
            "location": "/man/util/#bioutil-utility-functions", 
            "text": "The  Bio.Util  module provides utility functions commonly used in bioinformatics.", 
            "title": "Bio.Util: Utility Functions"
        }, 
        {
            "location": "/man/util/#labelled-square-matrix-parsers", 
            "text": "This module contains a function  readlsm , that reads labelled square matrices.  Such matrices are commonly used to store pairwise measures of similarity or dissimilarity between two sets. This format consists of a delimited file, with text labels on the upper and left sides of a square matrix. Such matrices are often but not exclusively symmetric.  An example would be:      A   B\nA   1   2\nB   2   1  (Note that we use spaces as a delimiter, where tabs would normally be used)", 
            "title": "Labelled square matrix parsers"
        }, 
        {
            "location": "/man/tools/", 
            "text": "Bio.Tools: Misc tools and function wrappers\n\n\n\n\nBLAST wrapper\n\n\nThe \nBio.Tools.BLAST\n module is a wrapper for the command line interface of \nBLAST+\n from NCBI. It requires that you have BLAST+ \ninstalled\n and accessible in your PATH (eg. you should be able to execute \n$ blastn -h\n from the command line).\n\n\n\n\nThe Basics\n\n\nThis module allows you to run protein and nucleotide BLAST (\nblastp\n and \nblastn\n respectively) within julia and to parse BLAST results into Bio.jl types.\n\n\nusing\n \nBio\n.\nSeq\n,\n\n      \nBio\n.\nTools\n.\nBLAST\n\n\n\nseq1\n \n=\n \ndna\n\n\nCGGACCAGACGGACACAGGGAGAAGCTAGTTTCTTTCATGTGATTGANAT\n\n\nNATGACTCTACTCCTAAAAGGGAAAAANCAATATCCTTGTTTACAGAAGA\n\n\nGAAACAAACAAGCCCCACTCAGCTCAGTCACAGGAGAGAN\n\n\n\n\n\nseq2\n \n=\n \ndna\n\n\nCGGAGCCAGCGAGCATATGCTGCATGAGGACCTTTCTATCTTACATTATG\n\n\nGCTGGGAATCTTACTCTTTCATCTGATACCTTGTTCAGATTTCAAAATAG\n\n\nTTGTAGCCTTATCCTGGTTTTACAGATGTGAAACTTTCAA\n\n\n\n\n\nblastn\n(\nseq1\n,\n \nseq2\n)\n\n\n\n\n\n\nThese functions return a \nVector{BLASTResult}\n. Each element is a hit which includes the sequence of the hit, an \nAlignedSequence\n using the original query as a reference and some additional information (expect vaue, bitscore) for the hit.\n\n\nimmutable\n \nBLASTResult\n\n    \nbitscore\n::\nFloat64\n\n    \nexpect\n::\nFloat64\n\n    \nqueryname\n::\nASCIIString\n\n    \nhitname\n::\nASCIIString\n\n    \nhit\n::\nBioSequence\n\n    \nalignment\n::\nAlignedSequence\n\n\nend\n\n\n\n\n\n\nIf you've already run a blast analysis or have downloaded blast results in XML format from NCBI you can also pass an XML string to \nreadblastXML()\n in order to obtain an array of \nBLASTResult\ns.\n\n\nresults\n \n=\n \nreadall\n(\nopen\n(\nblast_results.xml\n))\n \n# need to use `readstring` instead of `readall` for v0.5\n\n\nreadblastXML\n(\nresults\n)\n\n\n\n\n\n\nWhen parsing protein blast results, you must include the argument \nseqtype=\"prot\"\n, eg. \nreadblastXML(\"results, seqtype=\"prot\")\n\n\n\n\nOptions for \nblastn\n and \nblastp\n\n\nBoth of the basic BLAST+ commands can accept a single \nBioSequence\n, a \nVector{BioSequence}\n or a sting representing a file path to a fasta formatted file as arguments for both \nquery\n and \nsubject\n.\n\n\nblastn\n([\nseq1\n,\n \nseq2\n],\n \n[\nseq2\n,\n \nseq3\n])\n\n\n\nblastp\n(\naaseq\n,\n \npath/to/sequences.fasta\n)\n\n\n\n\n\n\nIf you have a local blast database (eg through the use of \n$ makeblastdb\n), you can use this database as the \nsubject\n\n\nblastn\n(\nseq1\n,\n \npath/to/blast_db\n,\n \ndb\n=\ntrue\n)\n\n\n\n\n\n\nIf you want to modify the search using additional options (eg. return only results with greater than 90% identity), you may pass a \nVector\n of flags (see \nhere\n for valid arguments - do not use flags that will alter file handling such as \n-outfmt\n)\n\n\nblastn\n(\nseq1\n,\n \nseq2\n,\n \n[\n-perc_identity\n,\n \n90\n,\n \n-evalue\n,\n \n9.0\n])", 
            "title": "Tools"
        }, 
        {
            "location": "/man/tools/#biotools-misc-tools-and-function-wrappers", 
            "text": "", 
            "title": "Bio.Tools: Misc tools and function wrappers"
        }, 
        {
            "location": "/man/tools/#blast-wrapper", 
            "text": "The  Bio.Tools.BLAST  module is a wrapper for the command line interface of  BLAST+  from NCBI. It requires that you have BLAST+  installed  and accessible in your PATH (eg. you should be able to execute  $ blastn -h  from the command line).", 
            "title": "BLAST wrapper"
        }, 
        {
            "location": "/man/tools/#the-basics", 
            "text": "This module allows you to run protein and nucleotide BLAST ( blastp  and  blastn  respectively) within julia and to parse BLAST results into Bio.jl types.  using   Bio . Seq , \n       Bio . Tools . BLAST  seq1   =   dna  CGGACCAGACGGACACAGGGAGAAGCTAGTTTCTTTCATGTGATTGANAT  NATGACTCTACTCCTAAAAGGGAAAAANCAATATCCTTGTTTACAGAAGA  GAAACAAACAAGCCCCACTCAGCTCAGTCACAGGAGAGAN   seq2   =   dna  CGGAGCCAGCGAGCATATGCTGCATGAGGACCTTTCTATCTTACATTATG  GCTGGGAATCTTACTCTTTCATCTGATACCTTGTTCAGATTTCAAAATAG  TTGTAGCCTTATCCTGGTTTTACAGATGTGAAACTTTCAA   blastn ( seq1 ,   seq2 )   These functions return a  Vector{BLASTResult} . Each element is a hit which includes the sequence of the hit, an  AlignedSequence  using the original query as a reference and some additional information (expect vaue, bitscore) for the hit.  immutable   BLASTResult \n     bitscore :: Float64 \n     expect :: Float64 \n     queryname :: ASCIIString \n     hitname :: ASCIIString \n     hit :: BioSequence \n     alignment :: AlignedSequence  end   If you've already run a blast analysis or have downloaded blast results in XML format from NCBI you can also pass an XML string to  readblastXML()  in order to obtain an array of  BLASTResult s.  results   =   readall ( open ( blast_results.xml ))   # need to use `readstring` instead of `readall` for v0.5  readblastXML ( results )   When parsing protein blast results, you must include the argument  seqtype=\"prot\" , eg.  readblastXML(\"results, seqtype=\"prot\")", 
            "title": "The Basics"
        }, 
        {
            "location": "/man/tools/#options-for-blastn-and-blastp", 
            "text": "Both of the basic BLAST+ commands can accept a single  BioSequence , a  Vector{BioSequence}  or a sting representing a file path to a fasta formatted file as arguments for both  query  and  subject .  blastn ([ seq1 ,   seq2 ],   [ seq2 ,   seq3 ])  blastp ( aaseq ,   path/to/sequences.fasta )   If you have a local blast database (eg through the use of  $ makeblastdb ), you can use this database as the  subject  blastn ( seq1 ,   path/to/blast_db ,   db = true )   If you want to modify the search using additional options (eg. return only results with greater than 90% identity), you may pass a  Vector  of flags (see  here  for valid arguments - do not use flags that will alter file handling such as  -outfmt )  blastn ( seq1 ,   seq2 ,   [ -perc_identity ,   90 ,   -evalue ,   9.0 ])", 
            "title": "Options for blastn and blastp"
        }, 
        {
            "location": "/lib/seq/", 
            "text": "Reference: Bio.Seq - Biological Sequences\n\n\nUnder_Construction\n\n\n\n\nTypes\n\n\n\n\nMethods", 
            "title": "Seq"
        }, 
        {
            "location": "/lib/seq/#reference-bioseq-biological-sequences", 
            "text": "Under_Construction", 
            "title": "Reference: Bio.Seq - Biological Sequences"
        }, 
        {
            "location": "/lib/seq/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lib/seq/#methods", 
            "text": "", 
            "title": "Methods"
        }, 
        {
            "location": "/man/contributing/", 
            "text": "Contributing\n\n\nWe welcome contributions in the form of pull requests. For your code to be considered it must meet the following guidelines.\n\n\n\n\nBy making a pull request, you're agreeing to license your code under an MIT license. See LICENSE.md.\n\n\n\n\nTypes and functions must be documented using Julia's \ndocstrings\n. Documentation regarding specific implementation details that aren't relevant to users should be in the form of comments.\n\n\nDocumentation may be omitted if the function is not exported (i.e. only used internally) and is short and obvious. E.g. \ncube(x) = x^3\n.\n  * In addition to documenting code in the source files through docstrings, we encourage contributers to create documentation which is more akin to  a manual, with user guides, tutorials, or R-like vignettes. We use Documenter.jl  and mkdocs, to generate such documentation and host it on our website. The source markdown files for such documentation, guides, and vignettes are located in the \ndocs/src/man\n folder of the Bio.jl git repo.\n  * All significant code must be tested. Tests should be organized into contexts, and into separate files based on module. Files for tests for a module go into an appropriately named folder, within the \ntest\n folder in the Bio.jl git repo. E.g. tests for the Seq module go in \ntest/seq\n.\n  * Contributions are included if the code has been reviewed by at least two team members who are \nnot\n the author of the proposed contribution, and there is general consensus (or general lack of objections) that it's useful and fits with the intended scope of Bio.jl.\n  * Code must be consistent with the prevailing style in Bio.jl, which includes, but is not necessarily limited to the following style guide.\n  * Code contributed should be compatible with Julia v0.4.\n\n\n\n\n\n\n\n\nStyle\n\n\n\n\nIndent with 4 spaces.\n\n\nType names are camel case, with the first letter capitalized. E.g. \nSomeVeryUsefulType\n.\n\n\nModule names are also camel case.\n\n\nFunction names, apart from constructors, are all lowercase. Include underscores between words only if the name would be hard to read without. E.g.  \nstart\n, \nstop\n, \nfindletter\n \nfind_last_digit\n.\n\n\nGenerally try to keep lines below 80-columns, unless splitting a long line onto multiple lines makes it harder to read.\n\n\n\n\nFiles that declare modules should only declare the module, and import any modules that it requires. Any code should be included from separate files. E.g.\n\n\n```julia\nmodule AwesomeFeatures\n\n\nusing IntervalTrees, JSON\n\n\ninclude(\"feature1.jl\")\ninclude(\"feature2.jl\")\n\n\nend\n\n``\n  * Files that declare modules should have the same name name of the module, e.g the module\nSomeModule\nis declared under the file\nSomeModule.jl`.\n  * Separate logical blocks of code with one blank line, or two blank lines for function/type definitions.\n  * When extending method definitions, explicitly import the method.\n\n\njulia\nimport Base: start, next, done\n\n  * Document functions using bare docstrings before a definition:\n\n\n\n\n\n\njulia   \"This function foo's something\"   foo(x) = 2*x\n\n\n\n\nFunctions that get or set variables in a type should not be prefixed with 'get' or 'set'. The getter should be named for the variable it sets, and the setter should have the same name as the getter, with the suffix \n!\n. For exmaple, for the variable \nnames\n:\n\n\n\n\njulia   name(node) # get node name   name!(node, \"somename\") # set node name\n\n\n\n\nConduct\n\n\nWe adhere to the Julia \ncommunity standards\n.", 
            "title": "Contributing"
        }, 
        {
            "location": "/man/contributing/#contributing", 
            "text": "We welcome contributions in the form of pull requests. For your code to be considered it must meet the following guidelines.   By making a pull request, you're agreeing to license your code under an MIT license. See LICENSE.md.   Types and functions must be documented using Julia's  docstrings . Documentation regarding specific implementation details that aren't relevant to users should be in the form of comments.  Documentation may be omitted if the function is not exported (i.e. only used internally) and is short and obvious. E.g.  cube(x) = x^3 .\n  * In addition to documenting code in the source files through docstrings, we encourage contributers to create documentation which is more akin to  a manual, with user guides, tutorials, or R-like vignettes. We use Documenter.jl  and mkdocs, to generate such documentation and host it on our website. The source markdown files for such documentation, guides, and vignettes are located in the  docs/src/man  folder of the Bio.jl git repo.\n  * All significant code must be tested. Tests should be organized into contexts, and into separate files based on module. Files for tests for a module go into an appropriately named folder, within the  test  folder in the Bio.jl git repo. E.g. tests for the Seq module go in  test/seq .\n  * Contributions are included if the code has been reviewed by at least two team members who are  not  the author of the proposed contribution, and there is general consensus (or general lack of objections) that it's useful and fits with the intended scope of Bio.jl.\n  * Code must be consistent with the prevailing style in Bio.jl, which includes, but is not necessarily limited to the following style guide.\n  * Code contributed should be compatible with Julia v0.4.", 
            "title": "Contributing"
        }, 
        {
            "location": "/man/contributing/#style", 
            "text": "Indent with 4 spaces.  Type names are camel case, with the first letter capitalized. E.g.  SomeVeryUsefulType .  Module names are also camel case.  Function names, apart from constructors, are all lowercase. Include underscores between words only if the name would be hard to read without. E.g.   start ,  stop ,  findletter   find_last_digit .  Generally try to keep lines below 80-columns, unless splitting a long line onto multiple lines makes it harder to read.   Files that declare modules should only declare the module, and import any modules that it requires. Any code should be included from separate files. E.g.  ```julia\nmodule AwesomeFeatures  using IntervalTrees, JSON  include(\"feature1.jl\")\ninclude(\"feature2.jl\")  end ``\n  * Files that declare modules should have the same name name of the module, e.g the module SomeModule is declared under the file SomeModule.jl`.\n  * Separate logical blocks of code with one blank line, or two blank lines for function/type definitions.\n  * When extending method definitions, explicitly import the method.  julia\nimport Base: start, next, done \n  * Document functions using bare docstrings before a definition:    julia   \"This function foo's something\"   foo(x) = 2*x   Functions that get or set variables in a type should not be prefixed with 'get' or 'set'. The getter should be named for the variable it sets, and the setter should have the same name as the getter, with the suffix  ! . For exmaple, for the variable  names :   julia   name(node) # get node name   name!(node, \"somename\") # set node name", 
            "title": "Style"
        }, 
        {
            "location": "/man/contributing/#conduct", 
            "text": "We adhere to the Julia  community standards .", 
            "title": "Conduct"
        }
    ]
}