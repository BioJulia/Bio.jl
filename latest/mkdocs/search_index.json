{
    "docs": [
        {
            "location": "/", 
            "text": "Bio.jl Documentation\n\n\nThis documentation site contains \nThe Bio.jl User Manual\n\n\nAs the flagship package of the BioJulia organisation, Bio.jl provides core modules containing efficient data types and algorithms, that most bioinformaticians and biologists would want to use for analyses or for building their own applications. Bio.jl is built on top of the Julia programming language, a high-level and high-performance programming language for technical computing. Bio.jl and Julia are open source and their source codes are immediately available to the public.\n\n\nBio.jl provides programmable components for quick prototyping of new analyses and algorithms. These components are carefully tuned to achieve the best performance without sacrificing the usability of the dynamic programming language. The following modules are currently part of the package and actively developed as submodules:\n\n\n\n\n\n\nBio.Seq\n: Biological sequences\n\n\n\n\nBiological symbols (DNA, RNA and amino acid)\n\n\nBiological sequences\n\n\nSequence search algorithms\n\n\nReaders for FASTA, FASTQ and .2bit file formats\n\n\n\n\nBio.Align\n: Sequence alignment\n\n\n\n\n\n\nAlignment data structures\n\n\n\n\nPairwise alignment algorithms\n\n\nReader for SAM and BAM file formats\n\n\n\n\nBio.Intervals\n: Genomic intervals and annotations\n\n\n\n\n\n\nGenomic intervals with annotations\n\n\n\n\nReaders for BED, BigBed and GFF3 file formats\n\n\n\n\nBio.Structure\n: Molecular structures\n\n\n\n\n\n\nMacromolecular structures (e.g. proteins)\n\n\n\n\nReader for PDB file format\n\n\n\n\nBio.Var\n: Biological variation\n\n\n\n\n\n\nMutation counting\n\n\n\n\nGenetic and evolutionary distances\n\n\nReaders for VCF and BCF file formats\n\n\n\n\nBio.Phylo\n: Phylogenetics\n\n\n\n\n\n\nPhylogenetic trees\n\n\n\n\n\n\nBio.Services\n: APIs to other services\n\n\n\n\n\n\nEntrez utilities (E-utilities)", 
            "title": "Home"
        }, 
        {
            "location": "/#biojl-documentation", 
            "text": "This documentation site contains  The Bio.jl User Manual  As the flagship package of the BioJulia organisation, Bio.jl provides core modules containing efficient data types and algorithms, that most bioinformaticians and biologists would want to use for analyses or for building their own applications. Bio.jl is built on top of the Julia programming language, a high-level and high-performance programming language for technical computing. Bio.jl and Julia are open source and their source codes are immediately available to the public.  Bio.jl provides programmable components for quick prototyping of new analyses and algorithms. These components are carefully tuned to achieve the best performance without sacrificing the usability of the dynamic programming language. The following modules are currently part of the package and actively developed as submodules:    Bio.Seq : Biological sequences   Biological symbols (DNA, RNA and amino acid)  Biological sequences  Sequence search algorithms  Readers for FASTA, FASTQ and .2bit file formats   Bio.Align : Sequence alignment    Alignment data structures   Pairwise alignment algorithms  Reader for SAM and BAM file formats   Bio.Intervals : Genomic intervals and annotations    Genomic intervals with annotations   Readers for BED, BigBed and GFF3 file formats   Bio.Structure : Molecular structures    Macromolecular structures (e.g. proteins)   Reader for PDB file format   Bio.Var : Biological variation    Mutation counting   Genetic and evolutionary distances  Readers for VCF and BCF file formats   Bio.Phylo : Phylogenetics    Phylogenetic trees    Bio.Services : APIs to other services    Entrez utilities (E-utilities)", 
            "title": "Bio.jl Documentation"
        }, 
        {
            "location": "/man/frontpage/", 
            "text": "The Bio.jl User Manual\n\n\nThis User manual is an in-depth guide to the modules provided by the Bio.jl package, and how to use the data-types and methods contained within to complete common bioinformatics tasks.\n\n\nIf you are browsing this manual online you will notice a green Gitter chat tab on the bottom-right of your screen. If you have questions when reading this manual, you are welcomed to ask questions to our user and developer community. If the question is a more involved one, they may ask you to start a post at the \nJulia Discourse Site\n.\n\n\n\n\nContents\n\n\nThe contents of this user manual are laid out according to the organisation of the modules of the Bio.jl package. For example, if you want to do work on biological sequences, the Bio.jl module \nBio.Seq\n, and the manual section \nThe Bio.Seq Module: Biological Sequences\n is for you!\n\n\n\n\nInstallation\n\n\nThe Bio.Seq Module: Biological Sequences\n\n\nAlign: Sequence Alignments\n\n\nIntervals: Genomic Interval Manipulation\n\n\nBio.Var: Biological Variation.\n\n\nMASH Distances\n\n\nBio.Structure: Macromolecular Structures\n\n\nBio.Services: APIs for Web Services\n\n\nBio.Util: Utility Functions\n\n\nBio.Tools: Misc tools and function wrappers", 
            "title": "Front Page"
        }, 
        {
            "location": "/man/frontpage/#the-biojl-user-manual", 
            "text": "This User manual is an in-depth guide to the modules provided by the Bio.jl package, and how to use the data-types and methods contained within to complete common bioinformatics tasks.  If you are browsing this manual online you will notice a green Gitter chat tab on the bottom-right of your screen. If you have questions when reading this manual, you are welcomed to ask questions to our user and developer community. If the question is a more involved one, they may ask you to start a post at the  Julia Discourse Site .", 
            "title": "The Bio.jl User Manual"
        }, 
        {
            "location": "/man/frontpage/#contents", 
            "text": "The contents of this user manual are laid out according to the organisation of the modules of the Bio.jl package. For example, if you want to do work on biological sequences, the Bio.jl module  Bio.Seq , and the manual section  The Bio.Seq Module: Biological Sequences  is for you!   Installation  The Bio.Seq Module: Biological Sequences  Align: Sequence Alignments  Intervals: Genomic Interval Manipulation  Bio.Var: Biological Variation.  MASH Distances  Bio.Structure: Macromolecular Structures  Bio.Services: APIs for Web Services  Bio.Util: Utility Functions  Bio.Tools: Misc tools and function wrappers", 
            "title": "Contents"
        }, 
        {
            "location": "/man/install/", 
            "text": "Installation\n\n\nInstall Bio.jl using the package manager.\n\n\nPkg\n.\nadd\n(\nBio\n)\n\n\n\n\n\n\nAlternatively, clone the latest version or a specific branch using Pkg.clone.", 
            "title": "Installation"
        }, 
        {
            "location": "/man/install/#installation", 
            "text": "Install Bio.jl using the package manager.  Pkg . add ( Bio )   Alternatively, clone the latest version or a specific branch using Pkg.clone.", 
            "title": "Installation"
        }, 
        {
            "location": "/man/reading/", 
            "text": "Reading and writing data\n\n\nBio.jl has a unified interface for reading and writing files in a variety of formats. Reader and writer type names have a prefix of the file format. For example, files of a format \nX\n can be read using \nXReader\n and can be written using \nXWriter\n.  To initialize a reader/writer of \nX\n, you can use one of the following syntaxes:\n\n\n# reader\n\n\nopen\n(\n::\nType\n{\nXReader\n},\n \nfilepath\n::\nAbstractString\n,\n \nargs\n...\n)\n\n\nXReader\n(\nstream\n::\nIO\n,\n \nargs\n...\n)\n\n\n\n# writer\n\n\nopen\n(\n::\nType\n{\nXWriter\n},\n \nfilepath\n::\nAbstractString\n,\n \nargs\n...\n)\n\n\nXWriter\n(\nstream\n::\nIO\n,\n \nargs\n...\n)\n\n\n\n\n\n\nFor example, when reading a FASTA file, a reader for the FASTA file format can be initialized as:\n\n\nusing\n \nBio\n.\nSeq\n  \n# import FASTA\n\n\nreader\n \n=\n \nopen\n(\nFASTA\n.\nReader\n,\n \nhg38.fa\n)\n\n\n# do something\n\n\nclose\n(\nreader\n)\n\n\n\n\n\n\n\n\nReading by iteration\n\n\nReaders in Bio.jl all read and return entries one at a time. The most convenient way to do this by iteration:\n\n\nreader\n \n=\n \nopen\n(\nBED\n.\nReader\n,\n \ninput.bed\n)\n\n\nfor\n \nrecord\n \nin\n \nreader\n\n    \n# perform some operation on entry\n\n\nend\n\n\nclose\n(\nreader\n)\n\n\n\n\n\n\n\n\nIn-place reading\n\n\nIterating through entries in a file is convenient, but for each entry in the file, the reader must allocate, and ultimately the garbage collector must spend time to deallocate it. For performance critical applications, a separate lower level parsing interface can be used that avoid unnecessary allocation by overwriting one entry. For files with a large number of small entries, this can greatly speed up reading.\n\n\nInstead of looping over a reader stream \nread!\n is called with a preallocated entry.  Some care is necessary when using this interface because \nrecord\n is completely overwritten on each iteration:\n\n\nreader\n \n=\n \nopen\n(\nBED\n.\nReader\n,\n \ninput.bed\n)\n\n\nrecord\n \n=\n \nBED\n.\nRecord\n()\n\n\nwhile\n \n!\neof\n(\nreader\n)\n\n    \nread!\n(\nreader\n,\n \nrecord\n)\n\n    \n# perform some operation on `record`\n\n\nend\n\n\nclose\n(\nreader\n)\n\n\n\n\n\n\nEmpty record types that correspond to the file format be found using \neltype\n, making it easy to allocate an empty record for any reader stream:\n\n\nrecord\n \n=\n \neltype\n(\nstream\n)()\n\n\n\n\n\n\n\n\nWriting data\n\n\nA FASTA file will be created as follows:\n\n\nwriter\n \n=\n \nopen\n(\nFASTAWriter\n,\n \nout.fa\n)\n\n\nwrite\n(\nwriter\n,\n \nFASTASeqRecord\n(\nseq1\n,\n \ndna\nACGTN\n))\n\n\nwrite\n(\nwriter\n,\n \nFASTASeqRecord\n(\nseq2\n,\n \ndna\nTTATA\n,\n \nAT rich\n))\n\n\nclose\n(\nwriter\n)\n\n\n\n\n\n\nAnother way is using Julia's do-block syntax, which closes the data file after finished writing:\n\n\nopen\n(\nFASTAWriter\n,\n \nout.fa\n)\n \ndo\n \nwriter\n\n    \nwrite\n(\nwriter\n,\n \nFASTASeqRecord\n(\nseq1\n,\n \ndna\nACGTN\n))\n\n    \nwrite\n(\nwriter\n,\n \nFASTASeqRecord\n(\nseq2\n,\n \ndna\nTTATA\n,\n \nAT rich\n))\n\n\nend\n\n\n\n\n\n\n\n\nSupported file formats\n\n\nThe following table summarizes supported file formats.\n\n\n\n\n\n\n\n\nFile format\n\n\nPrefix\n\n\nModule\n\n\nSpecification\n\n\n\n\n\n\n\n\n\n\nFASTA\n\n\nFASTA\n\n\nBio.Seq\n\n\nhttps://en.wikipedia.org/wiki/FASTA_format\n\n\n\n\n\n\nFASTQ\n\n\nFASTQ\n\n\nBio.Seq\n\n\nhttps://en.wikipedia.org/wiki/FASTQ_format\n\n\n\n\n\n\n.2bit\n\n\nTwoBit\n\n\nBio.Seq\n\n\nhttp://genome.ucsc.edu/FAQ/FAQformat.html#format7\n\n\n\n\n\n\nBED\n\n\nBED\n\n\nBio.Intervals\n\n\nhttps://genome.ucsc.edu/FAQ/FAQformat.html#format1\n\n\n\n\n\n\nGFF3\n\n\nGFF3\n\n\nBio.Intervals\n\n\nhttps://github.com/The-Sequence-Ontology/Specifications/blob/master/gff3.md\n\n\n\n\n\n\nbigBed\n\n\nBigBed\n\n\nBio.Intervals\n\n\nhttps://doi.org/10.1093/bioinformatics/btq351\n\n\n\n\n\n\nPDB\n\n\nPDB\n\n\nBio.Structure\n\n\nhttp://www.wwpdb.org/documentation/file-format-content/format33/v3.3.html\n\n\n\n\n\n\nSAM\n\n\nSAM\n\n\nBio.Align\n\n\nhttps://samtools.github.io/hts-specs/SAMv1.pdf\n\n\n\n\n\n\nBAM\n\n\nBAM\n\n\nBio.Align\n\n\nhttps://samtools.github.io/hts-specs/SAMv1.pdf\n\n\n\n\n\n\nVCF\n\n\nVCF\n\n\nBio.Var\n\n\nhttps://samtools.github.io/hts-specs/VCFv4.3.pdf\n\n\n\n\n\n\nBCF\n\n\nBCF\n\n\nBio.Var\n\n\nhttps://samtools.github.io/hts-specs/VCFv4.3.pdf\n\n\n\n\n\n\n\n\n\n\nFASTA\n\n\n\n\nReader type: \nFASTA.Reader\n\n\nWriter type: \nFASTA.Writer\n\n\nElement type: \nFASTA.Record\n\n\n\n\nFASTA is a text-based file format for representing biological sequences. A FASTA file stores a list of records with identifier, description, and sequence. The template of a sequence record is:\n\n\n{identifier} {description}?\n{sequence}\n\n\n\n\n\nHere is an example of a chromosomal sequence:\n\n\nchrI chromosome 1\nCCACACCACACCCACACACCCACACACCACACCACACACCACACCACACC\nCACACACACACATCCTAACACTACCCTAACACAGCCCTAATCTAACCCTG\n\n\n\n\n\nUsually sequence records will be read sequentially from a file by iteration. But if the FASTA file has an auxiliary index file formatted in \nfai\n, the reader supports random access to FASTA records, which would be useful when accessing specific parts of a huge genome sequence:\n\n\nreader\n \n=\n \nopen\n(\nFASTAReader\n,\n \nsacCer.fa\n,\n \nindex\n=\nsacCer.fa.fai\n)\n\n\nchrIV\n \n=\n \nreader\n[\nchrIV\n]\n  \n# directly read chromosome 4\n\n\n\n\n\n\n#\n\n\nBio.Seq.FASTA.Reader\n \n \nType\n.\n\n\nFASTA\n.\nReader\n(\ninput\n::\nIO\n;\n \nindex\n=\nnothing\n)\n\n\n\n\n\n\nCreate a data reader of the FASTA file format.\n\n\nArguments\n\n\n\n\ninput\n: data source\n\n\nindex=nothing\n: filepath to a random access index (currently \nfai\n is supported)\n\n\n\n\nsource\n\n\n#\n\n\nBio.Seq.FASTA.Writer\n \n \nType\n.\n\n\nFASTA\n.\nWriter\n(\noutput\n::\nIO\n;\n \nwidth\n=\n70\n)\n\n\n\n\n\n\nCreate a data writer of the FASTA file format.\n\n\nArguments\n\n\n\n\noutput\n: data sink\n\n\nwidth=70\n: wrapping width of sequence characters\n\n\n\n\nsource\n\n\n#\n\n\nBio.Seq.FASTA.Record\n \n \nType\n.\n\n\nFASTA.Record()\n\n\n\n\n\nCreate an unfilled FASTA record.\n\n\nsource\n\n\nFASTA.Record(data::Vector{UInt8})\n\n\n\n\n\nCreate a FASTA record object from \ndata\n.\n\n\nThis function verifies and indexes fields for accessors. Note that the ownership of \ndata\n is transferred to a new record object.\n\n\nsource\n\n\nFASTA.Record(str::AbstractString)\n\n\n\n\n\nCreate a FASTA record object from \nstr\n.\n\n\nThis function verifies and indexes fields for accessors.\n\n\nsource\n\n\nFASTA.Record(identifier, sequence)\n\n\n\n\n\nCreate a FASTA record object from \nidentifier\n and \nsequence\n.\n\n\nsource\n\n\nFASTA.Record(identifier, description, sequence)\n\n\n\n\n\nCreate a FASTA record object from \nidentifier\n, \ndescription\n and \nsequence\n.\n\n\nsource\n\n\n#\n\n\nBio.Seq.FASTA.identifier\n \n \nFunction\n.\n\n\nidentifier(record::Record)::String\n\n\n\n\n\nGet the sequence identifier of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Seq.FASTA.description\n \n \nFunction\n.\n\n\ndescription(record::Record)::String\n\n\n\n\n\nGet the description of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Seq.FASTA.sequence\n \n \nFunction\n.\n\n\nsequence(::Type{S}, record::Record, [part::UnitRange{Int}])::S\n\n\n\n\n\nGet the sequence of \nrecord\n.\n\n\nS\n can be either a subtype of \nBio.Seq.Sequence\n or \nString\n. If \npart\n argument is given, it returns the specified part of the sequence.\n\n\nsource\n\n\nsequence(record::Record, [part::UnitRange{Int}])\n\n\n\n\n\nGet the sequence of \nrecord\n.\n\n\nThis function infers the sequence type from the data. When it is wrong or unreliable, use \nsequence(::Type{S}, record::Record)\n.  If \npart\n argument is given, it returns the specified part of the sequence.\n\n\nsource\n\n\n\n\nFASTQ\n\n\n\n\nReader type: \nFASTQReader{S\n:Sequence}\n\n\nWriter type: \nFASTQWriter{T\n:IO}\n\n\nElement type: \nSeqRecord{S,FASTQMetadata}\n (alias: \nFASTQSeqRecord{S}\n)\n\n\n\n\nFASTQ is a text-based file format for representing DNA sequences along with qualities for each base. A FASTQ file stores a list of sequence records in the following format:\n\n\n@{name} {description}?\n{sequence}\n+\n{qualities}\n\n\n\n\n\nHere is an example of one record from a FASTQ file:\n\n\n@FSRRS4401BE7HA\ntcagTTAAGATGGGAT\n+\n###EEEEEEEEE##E#\n\n\n\n\n\nTo read a file containing such records, one could use:\n\n\n# The default base quality encoding is Sanger.\n\n\nreader\n \n=\n \nopen\n(\nFASTQReader\n,\n \nreads.fastq\n)\n\n\nfor\n \nrecord\n \nin\n \nreader\n\n    \n# do something\n\n\nend\n\n\nclose\n(\nreader\n)\n\n\n\n# If performance is important, in-place reading will be much faster.\n\n\nreader\n \n=\n \nopen\n(\nFASTQReader\n,\n \nreads.fastq\n)\n\n\nrecord\n \n=\n \nFASTQSeqRecord\n{\nDNASequence\n}()\n\n\nwhile\n \n!\neof\n(\nreader\n)\n\n    \nread!\n(\nreader\n,\n \nrecord\n)\n\n    \n# do something\n\n\nend\n\n\nclose\n(\nreader\n)\n\n\n\n\n\n\n#\n\n\nBio.Seq.FASTQReader\n \n \nType\n.\n\n\nFASTQReader(input::IO, quality_encoding=:sanger, fill_ambiguous=nothing)\n\n\n\n\n\nCreate a data reader of the FASTQ file format.\n\n\nArguments\n\n\n\n\ninput\n: data source\n\n\nquality_encoding=:sanger\n: encoding of base qualities; see the following table for available values\n\n\nfill_ambiguous=nothing\n: fill ambiguous nucleotides with the given nucleotide\n\n\n\n\n\n\n\n\n\n\nQuality encoding\n\n\nSymbol\n\n\nASCII offset\n\n\nQuality range\n\n\n\n\n\n\n\n\n\n\nSanger\n\n\n:sanger\n\n\n+33\n\n\n0-93\n\n\n\n\n\n\nSolexa\n\n\n:solexa\n\n\n+64\n\n\n-5-62\n\n\n\n\n\n\nIllumina 1.3+\n\n\n:illumina13\n\n\n+64\n\n\n0-62\n\n\n\n\n\n\nIllumina 1.5+\n\n\n:illumina15\n\n\n+64\n\n\n2-62\n\n\n\n\n\n\nIllumina 1.8+\n\n\n:illumina18\n\n\n+33\n\n\n0-93\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBio.Seq.FASTQWriter\n \n \nType\n.\n\n\nFASTQWriter\n(\noutput\n::\nIO\n;\n \nquality_header\n=\nfalse\n,\n \nquality_encoding\n=\n:\nsanger\n)\n\n\n\n\n\n\nCreate a data writer of the FASTQ file format.\n\n\nArguments\n\n\n\n\noutput\n: data sink\n\n\nquality_header=false\n: output the title line at the third line just after '+'\n\n\nquality_encoding=:sanger\n: encoding of base qualities; see \nFASTQReader\n for available values\n\n\n\n\nsource\n\n\n\n\n.2bit\n\n\n\n\nReader type: \nTwoBit.Reader{T\n:IO}\n\n\nWriter type: \nTwoBit.Writer{T\n:IO}\n\n\nElement type: \nTwoBit.Record\n\n\n\n\n.2bit is a binary file format designed for storing a genome consists of multiple chromosomal sequences. The reading speed is often an order of magnitude faster than that of FASTA and the file size is smaller. However, since the .2bit file format is specialized for genomic sequences, it cannot store either RNA or amino acid sequences.\n\n\nLike FASTA, the .2bit reader supports random access using an index included in the header section of a .2bit file:\n\n\nreader\n \n=\n \nopen\n(\nTwoBit\n.\nReader\n,\n \nsacCer.2bit\n)\n  \n# load a random access index in the header\n\n\nchrIV\n \n=\n \nreader\n[\nchrIV\n]\n                      \n# directly read chromosome 4\n\n\n\n\n\n\n#\n\n\nBio.Seq.TwoBit.Reader\n \n \nType\n.\n\n\nTwoBit.Reader(input::IO)\n\n\n\n\n\nCreate a data reader of the 2bit file format.\n\n\nArguments\n\n\n\n\ninput\n: data source\n\n\n\n\nsource\n\n\n#\n\n\nBio.Seq.TwoBit.Writer\n \n \nType\n.\n\n\nTwoBitWriter(output::IO, names::AbstractVector)\n\n\n\n\n\nCreate a data writer of the 2bit file format.\n\n\nArguments\n\n\n\n\noutput\n: data sink\n\n\nnames\n: a vector of sequence names written to \noutput\n\n\n\n\nsource\n\n\n#\n\n\nBio.Seq.TwoBit.Record\n \n \nType\n.\n\n\nTwoBit.Record()\n\n\n\n\n\nCreate an unfilled 2bit record.\n\n\nsource\n\n\n#\n\n\nBio.Seq.TwoBit.seqnames\n \n \nFunction\n.\n\n\nseqnames(reader::Reader)::Vector{String}\n\n\n\n\n\nGet the sequence names.\n\n\nSequences are stored in this order.\n\n\nsource\n\n\n#\n\n\nBio.Seq.TwoBit.sequence\n \n \nFunction\n.\n\n\nsequence([::Type{S},] record::Record)::S\n\n\n\n\n\nGet the sequence of \nrecord\n as \nS\n.\n\n\nS\n can be either \nBio.Seq.ReferenceSequence\n or \nBio.Seq.DNASequence\n. If \nS\n is omitted, the default type is \nBio.Seq.ReferenceSequence\n.\n\n\nsource\n\n\n#\n\n\nBio.Seq.TwoBit.maskedblocks\n \n \nFunction\n.\n\n\nmaskedblocks(record::Record)::Vector{UnitRange{Int}}\n\n\n\n\n\nGet the masked blocks.\n\n\nsource\n\n\n\n\nABIF\n\n\n\n\nReader type: \nAbifReader{T\n:IO}\n\n\n\n\nABIF is a binary file format for storing data produced by sequencers, those developed by Applied Biosystems, Inc. When the file is opened, we save all the existing tags, so we can read only the tags that are needed.\n\n\nreader\n \n=\n \nopen\n(\nAbifReader\n,\n \n3100.ab1\n)\n       \n# load a random access\n\n\ndata\n   \n=\n \nreader\n[\nDATA\n]\n                     \n# directly read all existing `DATA` Tags\n\n\ndata\n   \n=\n \nreader\n[\n1\n]\n                          \n# directly read Tag at index\n\n\ndata\n  \n=\n \ntags\n(\nreader\n)\n                       \n# return all existing tags\n\n\n\n# iterator by all tags\n\n\nfor\n \n(\nkey\n,\n \nvalue\n)\n \nin\n \ngetindex\n(\nreader\n,\n \ndata\n)\n\n\nend\n\n\n\n\n\n\nBio.Seq.AbifReader\nBio.Seq.tags\nBio.Seq.elements\n\n\n\n\n\n\n\nBED\n\n\n\n\nReader type: \nBED.Reader\n\n\nWriter type: \nBED.Writer\n\n\nElement type: \nBED.Record\n\n\n\n\nBED is a text-based file format for representing genomic annotations like genes, transcripts, and so on. A BED file has tab-delimited and variable-length fields; the first three fields denoting a genomic interval are mandatory.\n\n\nThis is an example of RNA transcripts:\n\n\nchr9    68331023    68424451    NM_015110   0   +\nchr9    68456943    68486659    NM_001206   0   -\n\n\n\n\n\n#\n\n\nBio.Intervals.BED.Reader\n \n \nType\n.\n\n\nBED.Reader(input::IO)\n\n\n\n\n\nCreate a data reader of the BED file format.\n\n\nArguments:\n\n\n\n\ninput\n: data source\n\n\n\n\nsource\n\n\n#\n\n\nBio.Intervals.BED.Writer\n \n \nType\n.\n\n\nBED.Writer(output::IO)\n\n\n\n\n\nCreate a data writer of the BED file format.\n\n\nArguments:\n\n\n\n\noutput\n: data sink\n\n\n\n\nsource\n\n\n#\n\n\nBio.Intervals.BED.Record\n \n \nType\n.\n\n\nBED.Record()\n\n\n\n\n\nCreate an unfilled BED record.\n\n\nsource\n\n\nBED.Record(data::Vector{UInt8})\n\n\n\n\n\nCreate a BED record object from \ndata\n.\n\n\nThis function verifies and indexes fields for accessors. Note that the ownership of \ndata\n is transferred to a new record object.\n\n\nsource\n\n\nBED.Record(str::AbstractString)\n\n\n\n\n\nCreate a BED record object from \nstr\n.\n\n\nThis function verifies and indexes fields for accessors.\n\n\nsource\n\n\n#\n\n\nBio.Intervals.BED.chrom\n \n \nFunction\n.\n\n\nchrom(record::Record)::String\n\n\n\n\n\nGet the chromosome name of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Intervals.BED.chromstart\n \n \nFunction\n.\n\n\nchromstart(record::Record)::Int\n\n\n\n\n\nGet the starting position of \nrecord\n.\n\n\nNote that the first base is numbered 1.\n\n\nsource\n\n\n#\n\n\nBio.Intervals.BED.chromend\n \n \nFunction\n.\n\n\nchromend(record::Record)::Int\n\n\n\n\n\nGet the end position of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Intervals.BED.name\n \n \nFunction\n.\n\n\nname(record::Record)::String\n\n\n\n\n\nGet the name of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Intervals.BED.score\n \n \nFunction\n.\n\n\nscore(record::Record)::Int\n\n\n\n\n\nGet the score between 0 and 1000.\n\n\nsource\n\n\n#\n\n\nBio.Intervals.BED.strand\n \n \nFunction\n.\n\n\nstrand(record::Record)::Bio.Intervals.Strand\n\n\n\n\n\nGet the strand of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Intervals.BED.thickstart\n \n \nFunction\n.\n\n\nthickstart(record::Record)::Int\n\n\n\n\n\nGet the starting position at which \nrecord\n is drawn thickly.\n\n\nNote that the first base is numbered 1.\n\n\nsource\n\n\n#\n\n\nBio.Intervals.BED.thickend\n \n \nFunction\n.\n\n\nthickend(record::Record)::Int\n\n\n\n\n\nGet the end position at which \nrecord\n is drawn thickly.\n\n\nsource\n\n\n#\n\n\nBio.Intervals.BED.itemrgb\n \n \nFunction\n.\n\n\nitemrgb(record::Record)::ColorTypes.RGB\n\n\n\n\n\nGet the RGB value of \nrecord\n.\n\n\nThe return type is defined in \nColorTypes.jl\n.\n\n\nsource\n\n\n#\n\n\nBio.Intervals.BED.blockcount\n \n \nFunction\n.\n\n\nblockcount(record::Record)::Int\n\n\n\n\n\nGet the number of blocks (exons) in \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Intervals.BED.blocksizes\n \n \nFunction\n.\n\n\nblocksizes(record::Record)::Vector{Int}\n\n\n\n\n\nGet the block (exon) sizes of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Intervals.BED.blockstarts\n \n \nFunction\n.\n\n\nblockstarts(record::Record)::Vector{Int}\n\n\n\n\n\nGet the block (exon) starts of \nrecord\n.\n\n\nNote that the first base is numbered 1.\n\n\nsource\n\n\n\n\nGFF3\n\n\n\n\nReader type: \nBio.Intervals.GFF3.Reader\n\n\nWriter type: \nBio.Intervals.GFF3.Writer\n\n\nElement type: \nBio.Intervals.GFF3.Record\n\n\n\n\nGFF3 is a text-based file format for representing genomic annotations. The major difference from BED is that is GFF3 is more structured and can include sequences in the FASTA file format.\n\n\n#\n\n\nBio.Intervals.GFF3.Reader\n \n \nType\n.\n\n\nGFF3Reader\n(\ninput\n::\nIO\n;\n \nsave_directives\n::\nBool\n=\nfalse\n)\n\n\n\n\n\n\nCreate a reader for data in GFF3 format.\n\n\nArguments:\n\n\n\n\ninput\n: data source\n\n\nsave_directives=false\n: if true, store directive lines, which can be accessed with the \ndirectives\n function\n\n\n\n\nsource\n\n\n#\n\n\nBio.Intervals.GFF3.Writer\n \n \nType\n.\n\n\nGFF3.Writer(output::IO)\n\n\n\n\n\nCreate a data writer of the GFF3 file format.\n\n\nArguments:\n\n\n\n\noutput\n: data sink\n\n\n\n\nsource\n\n\n\n\nbigBed\n\n\n\n\nReader type: \nBigBedReader\n\n\nWriter type: \nBigBedWriter{T\n:IO}\n\n\nElement type: \nInterval{BEDMetadata}\n (alias: \nBEDInterval\n)\n\n\n\n\nBigBed is a binary file format for representing genomic annotations and often created from BED files. The bigBed files are indexed to quickly fetch specific regions.\n\n\n#\n\n\nBio.Intervals.BigBedReader\n \n \nType\n.\n\n\nBigBedReader(input::IO)\n\n\n\n\n\nCreate a data reader of the BigBed file format.\n\n\nArguments\n\n\n\n\ninput\n: data source\n\n\n\n\nsource\n\n\n#\n\n\nBio.Intervals.BigBedWriter\n \n \nType\n.\n\n\nBigBedWriter(output::IO)\n\n\n\n\n\nCreate a data writer of the BigBed file format.\n\n\nArguments\n\n\n\n\noutput\n: data sink\n\n\n\n\nsource\n\n\n\n\nPDB\n\n\nPDB is a text-based file format for representing 3D macromolecular structures. This has different reader interfaces from other file formats. Please consult the \nBio.Structure\n chapter for details.\n\n\n\n\nSAM\n\n\n\n\nReader type: \nSAM.Reader\n\n\nWriter type: \nSAM.Writer\n\n\nElement type: \nSAM.Record\n\n\n\n\nSAM is a text-based file format for representing sequence alignments.\n\n\n#\n\n\nBio.Align.SAM.Reader\n \n \nType\n.\n\n\nSAM.Reader(input::IO)\n\n\n\n\n\nCreate a data reader of the SAM file format.\n\n\nArguments\n\n\n\n\ninput\n: data source\n\n\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.header\n \n \nFunction\n.\n\n\nheader(reader::Reader)::Header\n\n\n\n\n\nGet the header of \nreader\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.Header\n \n \nType\n.\n\n\nSAM.Header()\n\n\n\n\n\nCreate an empty header.\n\n\nsource\n\n\n#\n\n\nBase.find\n \n \nMethod\n.\n\n\nfind(header::Header, key::AbstractString)::Vector{MetaInfo}\n\n\n\n\n\nFind metainfo objects satisfying \nSAM.tag(metainfo) == key\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.Writer\n \n \nType\n.\n\n\nWriter(output::IO, header::Header=Header())\n\n\n\n\n\nCreate a data writer of the SAM file format.\n\n\nArguments\n\n\n\n\noutput\n: data sink\n\n\nheader=Header()\n: SAM header object\n\n\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.MetaInfo\n \n \nType\n.\n\n\nMetaInfo(str::AbstractString)\n\n\n\n\n\nCreate a SAM metainfo from \nstr\n.\n\n\nExamples\n\n\njulia\n SAM.MetaInfo(\n@CO    some comment\n)\nBio.Align.SAM.MetaInfo:\n    tag: CO\n  value: some comment\n\njulia\n SAM.MetaInfo(\n@SQ    SN:chr1 LN:12345\n)\nBio.Align.SAM.MetaInfo:\n    tag: SQ\n  value: SN=chr1 LN=12345\n\n\n\n\n\nsource\n\n\nMetaInfo(tag::AbstractString, value)\n\n\n\n\n\nCreate a SAM metainfo with \ntag\n and \nvalue\n.\n\n\ntag\n is a two-byte ASCII string. If \ntag\n is \n\"CO\"\n, \nvalue\n must be a string; otherwise, \nvalue\n is an iterable object with key and value pairs.\n\n\nExamples\n\n\njulia\n SAM.MetaInfo(\nCO\n, \nsome comment\n)\nBio.Align.SAM.MetaInfo:\n    tag: CO\n  value: some comment\n\njulia\n string(ans)\n\n@CO    some comment\n\n\njulia\n SAM.MetaInfo(\nSQ\n, [\nSN\n =\n \nchr1\n, \nLN\n =\n 12345])\nBio.Align.SAM.MetaInfo:\n    tag: SQ\n  value: SN=chr1 LN=12345\n\njulia\n string(ans)\n\n@SQ    SN:chr1 LN:12345\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.iscomment\n \n \nFunction\n.\n\n\niscomment(metainfo::MetaInfo)::Bool\n\n\n\n\n\nTest if \nmetainfo\n is a comment (i.e. its tag is \"CO\").\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.tag\n \n \nFunction\n.\n\n\ntag(metainfo::MetaInfo)::String\n\n\n\n\n\nGet the tag of \nmetainfo\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.value\n \n \nFunction\n.\n\n\nvalue(metainfo::MetaInfo)::String\n\n\n\n\n\nGet the value of \nmetainfo\n as a string.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.keyvalues\n \n \nFunction\n.\n\n\nkeyvalues(metainfo::MetaInfo)::Vector{Pair{String,String}}\n\n\n\n\n\nGet the values of \nmetainfo\n as string pairs.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.Record\n \n \nType\n.\n\n\nSAM.Record()\n\n\n\n\n\nCreate an unfilled SAM record.\n\n\nsource\n\n\nSAM.Record(data::Vector{UInt8})\n\n\n\n\n\nCreate a SAM record from \ndata\n. This function verifies the format and indexes fields for accessors. Note that the ownership of \ndata\n is transferred to a new record object.\n\n\nsource\n\n\nSAM.Record(str::AbstractString)\n\n\n\n\n\nCreate a SAM record from \nstr\n. This function verifies the format and indexes fields for accessors.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.flag\n \n \nFunction\n.\n\n\nflag(record::Record)::UInt16\n\n\n\n\n\nGet the bitwise flag of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.ismapped\n \n \nFunction\n.\n\n\nismapped(record::Record)::Bool\n\n\n\n\n\nTest if \nrecord\n is mapped.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.refname\n \n \nFunction\n.\n\n\nrefname(record::Record)::String\n\n\n\n\n\nGet the reference sequence name of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.position\n \n \nFunction\n.\n\n\nposition(record::Record)::Int\n\n\n\n\n\nGet the 1-based leftmost mapping position of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.rightposition\n \n \nFunction\n.\n\n\nrightposition(record::Record)::Int\n\n\n\n\n\nGet the 1-based rightmost mapping position of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.isnextmapped\n \n \nFunction\n.\n\n\nisnextmapped(record::Record)::Bool\n\n\n\n\n\nTest if the mate/next read of \nrecord\n is mapped.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.nextrefname\n \n \nFunction\n.\n\n\nnextrefname(record::Record)::String\n\n\n\n\n\nGet the reference name of the mate/next read of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.nextposition\n \n \nFunction\n.\n\n\nnextposition(record::Record)::Int\n\n\n\n\n\nGet the position of the mate/next read of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.mappingquality\n \n \nFunction\n.\n\n\nmappingquality(record::Record)::UInt8\n\n\n\n\n\nGet the mapping quality of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.cigar\n \n \nFunction\n.\n\n\ncigar(record::Record)::String\n\n\n\n\n\nGet the CIGAR string of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.alignment\n \n \nFunction\n.\n\n\nalignment(record::Record)::Bio.Align.Alignment\n\n\n\n\n\nGet the alignment of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.alignlength\n \n \nFunction\n.\n\n\nalignlength(record::Record)::Int\n\n\n\n\n\nGet the alignment length of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.tempname\n \n \nFunction\n.\n\n\ntempname(record::Record)::String\n\n\n\n\n\nGet the query template name of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.templength\n \n \nFunction\n.\n\n\ntemplength(record::Record)::Int\n\n\n\n\n\nGet the template length of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.sequence\n \n \nFunction\n.\n\n\nsequence(record::Record)::Bio.Seq.DNASequence\n\n\n\n\n\nGet the segment sequence of \nrecord\n.\n\n\nsource\n\n\nsequence(::Type{String}, record::Record)::String\n\n\n\n\n\nGet the segment sequence of \nrecord\n as \nString\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.seqlength\n \n \nFunction\n.\n\n\nseqlength(record::Record)::Int\n\n\n\n\n\nGet the sequence length of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.quality\n \n \nFunction\n.\n\n\nquality(record::Record)::Vector{UInt8}\n\n\n\n\n\nGet the Phred-scaled base quality of \nrecord\n.\n\n\nsource\n\n\nquality(::Type{String}, record::Record)::String\n\n\n\n\n\nGet the ASCII-encoded base quality of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.SAM.auxdata\n \n \nFunction\n.\n\n\nauxdata(record::Record)::Dict{String,Any}\n\n\n\n\n\nGet the auxiliary data (optional fields) of \nrecord\n.\n\n\nsource\n\n\nThis module provides 16-bit flags defined in the SAM specs:\n\n\n\n\n\n\n\n\nFlag\n\n\nBit\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSAM.FLAG_PAIRED\n\n\n0x0001\n\n\ntemplate having multiple segments in sequencing\n\n\n\n\n\n\nSAM.FLAG_PROPER_PAIR\n\n\n0x0002\n\n\neach segment properly aligned according to the aligner\n\n\n\n\n\n\nSAM.FLAG_UNMAP\n\n\n0x0004\n\n\nsegment unmapped\n\n\n\n\n\n\nSAM.FLAG_MUNMAP\n\n\n0x0008\n\n\nnext segment in the template unmapped\n\n\n\n\n\n\nSAM.FLAG_REVERSE\n\n\n0x0010\n\n\nSEQ being reverse complemented\n\n\n\n\n\n\nSAM.FLAG_MREVERSE\n\n\n0x0020\n\n\nSEQ of the next segment in the template being reverse complemented\n\n\n\n\n\n\nSAM.FLAG_READ1\n\n\n0x0040\n\n\nthe first segment in the template\n\n\n\n\n\n\nSAM.FLAG_READ2\n\n\n0x0080\n\n\nthe last segment in the template\n\n\n\n\n\n\nSAM.FLAG_SECONDARY\n\n\n0x0100\n\n\nsecondary alignment\n\n\n\n\n\n\nSAM.FLAG_QCFAIL\n\n\n0x0200\n\n\nnot passing filters, such as platform/vendor quality controls\n\n\n\n\n\n\nSAM.FLAG_DUP\n\n\n0x0400\n\n\nPCR or optical duplicate\n\n\n\n\n\n\nSAM.FLAG_SUPPLEMENTARY\n\n\n0x0800\n\n\nsupplementary alignment\n\n\n\n\n\n\n\n\n\n\nBAM\n\n\n\n\nReader type: \nBAM.Reader\n\n\nWriter type: \nBAM.Writer\n\n\nElement type: \nBAM.Record\n\n\n\n\nBAM is a binary counterpart of the \nSAM\n file format.\n\n\nWhen writing data in the BAM file format, the underlying output stream needs to be wrapped with a \nBGZFStream\n object provided from \nBGZFStreams.jl\n.\n\n\nFlags and the header type are defined in the \nSAM\n module.\n\n\n#\n\n\nBio.Align.BAM.Reader\n \n \nType\n.\n\n\nBAM\n.\nReader\n(\ninput\n::\nIO\n;\n \nindex\n=\nnothing\n)\n\n\n\n\n\n\nCreate a data reader of the BAM file format.\n\n\nArguments\n\n\n\n\ninput\n: data source\n\n\nindex=nothing\n: filepath to a random access index (currently \nbai\n is Supported)\n\n\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.header\n \n \nFunction\n.\n\n\nheader\n(\nreader\n::\nReader\n;\n \nfillSQ\n::\nBool\n=\nfalse\n)\n::\nSAM\n.\nHeader\n\n\n\n\n\n\nGet the header of \nreader\n.\n\n\nIf \nfillSQ\n is \ntrue\n, this function fills missing \"SQ\" metainfo in the header.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.Writer\n \n \nType\n.\n\n\nBAM.Writer(output::BGZFStream, header::SAM.Header)\n\n\n\n\n\nCreate a data writer of the BAM file format.\n\n\nArguments\n\n\n\n\noutput\n: data sink\n\n\nheader\n: SAM header object\n\n\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.Record\n \n \nType\n.\n\n\nBAM.Record()\n\n\n\n\n\nCreate an unfilled BAM record.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.flag\n \n \nFunction\n.\n\n\nflag(record::Record)::UInt16\n\n\n\n\n\nGet the bitwise flag of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.ismapped\n \n \nFunction\n.\n\n\nismapped(record::Record)::Bool\n\n\n\n\n\nTest if \nrecord\n is mapped.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.refid\n \n \nFunction\n.\n\n\nrefid(record::Record)::Int\n\n\n\n\n\nGet the reference sequence ID of \nrecord\n.\n\n\nThe ID is 1-based (i.e. the first sequence is 1) and is 0 for a record without a mapping position.\n\n\nSee also: \nBAM.rname\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.refname\n \n \nFunction\n.\n\n\nrefname(record::Record)::String\n\n\n\n\n\nGet the reference sequence name of \nrecord\n.\n\n\nSee also: \nBAM.refid\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.position\n \n \nFunction\n.\n\n\nposition(record::Record)::Int\n\n\n\n\n\nGet the 1-based leftmost mapping position of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.rightposition\n \n \nFunction\n.\n\n\nrightposition(record::Record)::Int\n\n\n\n\n\nGet the 1-based rightmost mapping position of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.isnextmapped\n \n \nFunction\n.\n\n\nisnextmapped(record::Record)::Bool\n\n\n\n\n\nTest if the mate/next read of \nrecord\n is mapped.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.nextrefid\n \n \nFunction\n.\n\n\nnextrefid(record::Record)::Int\n\n\n\n\n\nGet the next/mate reference sequence ID of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.nextrefname\n \n \nFunction\n.\n\n\nnextrefname(record::Record)::String\n\n\n\n\n\nGet the reference name of the mate/next read of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.nextposition\n \n \nFunction\n.\n\n\nnextposition(record::Record)::Int\n\n\n\n\n\nGet the 1-based leftmost mapping position of the next/mate read of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.mappingquality\n \n \nFunction\n.\n\n\nmappingquality(record::Record)::UInt8\n\n\n\n\n\nGet the mapping quality of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.cigar\n \n \nFunction\n.\n\n\ncigar(record::Record)::String\n\n\n\n\n\nGet the CIGAR string of \nrecord\n.\n\n\nSee also \nBAM.cigar_rle\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.cigar_rle\n \n \nFunction\n.\n\n\ncigar_rle(record::Record)::Tuple{Vector{Bio.Align.Operation},Vector{Int}}\n\n\n\n\n\nGet a run-length encoded tuple \n(ops, lens)\n of the CIGAR string in \nrecord\n.\n\n\nSee also \nBAM.cigar\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.alignment\n \n \nFunction\n.\n\n\nalignment(record::Record)::Bio.Align.Alignment\n\n\n\n\n\nGet the alignment of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.alignlength\n \n \nFunction\n.\n\n\nalignlength(record::Record)::Int\n\n\n\n\n\nGet the alignment length of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.tempname\n \n \nFunction\n.\n\n\ntempname(record::Record)::String\n\n\n\n\n\nGet the query template name of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.templength\n \n \nFunction\n.\n\n\ntemplength(record::Record)::Int\n\n\n\n\n\nGet the template length of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.sequence\n \n \nFunction\n.\n\n\nsequence(record::Record)::Bio.Seq.DNASequence\n\n\n\n\n\nGet the segment sequence of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.seqlength\n \n \nFunction\n.\n\n\nseqlength(record::Record)::Int\n\n\n\n\n\nGet the sequence length of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.quality\n \n \nFunction\n.\n\n\nquality(record::Record)::Vector{UInt8}\n\n\n\n\n\nGet the base quality of  \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Align.BAM.auxdata\n \n \nFunction\n.\n\n\nauxdata(record::Record)::BAM.AuxData\n\n\n\n\n\nGet the auxiliary data of \nrecord\n.\n\n\nsource\n\n\n\n\nVCF\n\n\n\n\nReader type: \nVCF.Reader\n\n\nWriter type: \nVCF.Writer{T\n:IO}\n\n\nElement type: \nVCF.Record\n\n\n\n\nVCF is a text-based file format for representing genetic variations.\n\n\n#\n\n\nBio.Var.VCF.Reader\n \n \nType\n.\n\n\nVCF.Reader(input::IO)\n\n\n\n\n\nCreate a data reader of the VCF file format.\n\n\nArguments\n\n\n\n\ninput\n: data source\n\n\n\n\nsource\n\n\n#\n\n\nBio.Var.VCF.Writer\n \n \nType\n.\n\n\nVCF.Writer(output::IO, header::VCF.Header)\n\n\n\n\n\nCreate a data writer of the VCF file format.\n\n\nArguments\n\n\n\n\noutput\n: data sink\n\n\nheader\n: VCF header object\n\n\n\n\nsource\n\n\n#\n\n\nBio.Var.VCF.Record\n \n \nType\n.\n\n\nVCF.Record()\n\n\n\n\n\nCreate an unfilled VCF record.\n\n\nsource\n\n\nVCF.Record(data::Vector{UInt8})\n\n\n\n\n\nCreate a VCF object from \ndata\n containing a VCF record. This function verifies the format and indexes fields for accessors. Note that the ownership of \ndata\n is transferred to a new record.\n\n\nsource\n\n\nVCF.Record(str::AbstractString)\n\n\n\n\n\nCreate a VCF object from \nstr\n containing a VCF record. This function verifies the format and indexes fields for accessors.\n\n\nsource\n\n\n#\n\n\nBio.Var.VCF.chrom\n \n \nFunction\n.\n\n\nchrom(record::Record)::String\n\n\n\n\n\nGet the chromosome name of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Var.VCF.pos\n \n \nFunction\n.\n\n\npos(record::Record)::Int\n\n\n\n\n\nGet the reference position of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Var.VCF.id\n \n \nFunction\n.\n\n\nid(record::Record)::Vector{String}\n\n\n\n\n\nGet the identifiers of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Var.VCF.ref\n \n \nFunction\n.\n\n\nref(record::Record)::String\n\n\n\n\n\nGet the reference bases of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Var.VCF.alt\n \n \nFunction\n.\n\n\nalt(record::Record)::Vector{String}\n\n\n\n\n\nGet the alternate bases of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Var.VCF.qual\n \n \nFunction\n.\n\n\nqual(record::Record)::Float64\n\n\n\n\n\nGet the quality score of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Var.VCF.filter\n \n \nFunction\n.\n\n\nfilter(record::Record)::Vector{String}\n\n\n\n\n\nGet the filter status of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Var.VCF.info\n \n \nFunction\n.\n\n\ninfo(record::Record)::Vector{Pair{String,String}}\n\n\n\n\n\nGet the additional information of \nrecord\n.\n\n\nsource\n\n\ninfo(record::Record, key::String)::String\n\n\n\n\n\nGet the additional information of \nrecord\n with \nkey\n. Keys without corresponding values return an empty string.\n\n\nsource\n\n\n#\n\n\nBio.Var.VCF.format\n \n \nFunction\n.\n\n\nformat(record::Record)::Vector{String}\n\n\n\n\n\nGet the genotype format of \nrecord\n.\n\n\nsource\n\n\n\n\nBCF\n\n\n\n\nReader type: \nBCF.Reader{T\n:IO}\n\n\nWriter type: \nBCF.Writer{T\n:IO}\n\n\nElement type: \nBCF.Record\n\n\n\n\nBCF is a binary counterpart of the VCF file format.\n\n\n#\n\n\nBio.Var.BCF.Reader\n \n \nType\n.\n\n\nBCF.Reader(input::IO)\n\n\n\n\n\nCreate a data reader of the BCF file format.\n\n\nArguments\n\n\n\n\ninput\n: data source\n\n\n\n\nsource\n\n\n#\n\n\nBio.Var.BCF.Writer\n \n \nType\n.\n\n\nBCF.Writer(output::IO, header::VCF.Header)\n\n\n\n\n\nCreate a data writer of the BCF file format.\n\n\nArguments\n\n\n\n\noutput\n: data sink\n\n\nheader\n: VCF header object\n\n\n\n\nsource\n\n\n#\n\n\nBio.Var.BCF.Record\n \n \nType\n.\n\n\nBCF.Record()\n\n\n\n\n\nCreate an unfilled BCF record.\n\n\nsource\n\n\n#\n\n\nBio.Var.BCF.chrom\n \n \nFunction\n.\n\n\nchrom(record::Record)::Int\n\n\n\n\n\nGet the chromosome index of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Var.BCF.pos\n \n \nFunction\n.\n\n\npos(record::Record)::Int\n\n\n\n\n\nGet the reference position of \nrecord\n.\n\n\nNote that the position of the first base is 1 (i.e. 1-based coordinate).\n\n\nsource\n\n\n#\n\n\nBio.Var.BCF.rlen\n \n \nFunction\n.\n\n\nrlen(record::Record)::Int\n\n\n\n\n\nGet the length of \nrecord\n projected onto the reference sequence.\n\n\nsource\n\n\n#\n\n\nBio.Var.BCF.qual\n \n \nFunction\n.\n\n\nqual(record::Record)::Float32\n\n\n\n\n\nGet the quality score of \nrecord\n.\n\n\nNote that \n0x7F800001\n (signaling NaN) is interpreted as a missing value.\n\n\nsource\n\n\n#\n\n\nBio.Var.BCF.ref\n \n \nFunction\n.\n\n\nref(record::Record)::String\n\n\n\n\n\nGet the reference bases of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Var.BCF.alt\n \n \nFunction\n.\n\n\nalt(record::Record)::Vector{String}\n\n\n\n\n\nGet the alternate bases of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Var.BCF.filter\n \n \nFunction\n.\n\n\nfilter(record::Record)::Vector{Int}\n\n\n\n\n\nGet the filter indexes of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.Var.BCF.info\n \n \nFunction\n.\n\n\ninfo(record::Record, [simplify::Bool=true])::Vector{Tuple{Int,Any}}\n\n\n\n\n\nGet the additional information of \nrecord\n.\n\n\nWhen \nsimplify\n is \ntrue\n, a vector with a single element is converted to the element itself and an empty vector of the void type is converted to \nnothing\n.\n\n\nsource\n\n\ninfo(record::Record, key::Integer, [simplify::Bool=true])\n\n\n\n\n\nGet the additional information of \nrecord\n with \nkey\n.\n\n\nWhen \nsimplify\n is \ntrue\n, a vector with a single element is converted to the element itself and an empty vector of the void type is converted to \nnothing\n.\n\n\nsource\n\n\n#\n\n\nBio.Var.BCF.genotype\n \n \nFunction\n.\n\n\ngenotype(record::Record)::Vector{Tuple{Int,Vector{Any}}}\n\n\n\n\n\nGet the genotypes of \nrecord\n.\n\n\nBCF genotypes are encoded by field, not by sample like VCF.\n\n\nsource", 
            "title": "IO API"
        }, 
        {
            "location": "/man/reading/#reading-and-writing-data", 
            "text": "Bio.jl has a unified interface for reading and writing files in a variety of formats. Reader and writer type names have a prefix of the file format. For example, files of a format  X  can be read using  XReader  and can be written using  XWriter .  To initialize a reader/writer of  X , you can use one of the following syntaxes:  # reader  open ( :: Type { XReader },   filepath :: AbstractString ,   args ... )  XReader ( stream :: IO ,   args ... )  # writer  open ( :: Type { XWriter },   filepath :: AbstractString ,   args ... )  XWriter ( stream :: IO ,   args ... )   For example, when reading a FASTA file, a reader for the FASTA file format can be initialized as:  using   Bio . Seq    # import FASTA  reader   =   open ( FASTA . Reader ,   hg38.fa )  # do something  close ( reader )", 
            "title": "Reading and writing data"
        }, 
        {
            "location": "/man/reading/#reading-by-iteration", 
            "text": "Readers in Bio.jl all read and return entries one at a time. The most convenient way to do this by iteration:  reader   =   open ( BED . Reader ,   input.bed )  for   record   in   reader \n     # perform some operation on entry  end  close ( reader )", 
            "title": "Reading by iteration"
        }, 
        {
            "location": "/man/reading/#in-place-reading", 
            "text": "Iterating through entries in a file is convenient, but for each entry in the file, the reader must allocate, and ultimately the garbage collector must spend time to deallocate it. For performance critical applications, a separate lower level parsing interface can be used that avoid unnecessary allocation by overwriting one entry. For files with a large number of small entries, this can greatly speed up reading.  Instead of looping over a reader stream  read!  is called with a preallocated entry.  Some care is necessary when using this interface because  record  is completely overwritten on each iteration:  reader   =   open ( BED . Reader ,   input.bed )  record   =   BED . Record ()  while   ! eof ( reader ) \n     read! ( reader ,   record ) \n     # perform some operation on `record`  end  close ( reader )   Empty record types that correspond to the file format be found using  eltype , making it easy to allocate an empty record for any reader stream:  record   =   eltype ( stream )()", 
            "title": "In-place reading"
        }, 
        {
            "location": "/man/reading/#writing-data", 
            "text": "A FASTA file will be created as follows:  writer   =   open ( FASTAWriter ,   out.fa )  write ( writer ,   FASTASeqRecord ( seq1 ,   dna ACGTN ))  write ( writer ,   FASTASeqRecord ( seq2 ,   dna TTATA ,   AT rich ))  close ( writer )   Another way is using Julia's do-block syntax, which closes the data file after finished writing:  open ( FASTAWriter ,   out.fa )   do   writer \n     write ( writer ,   FASTASeqRecord ( seq1 ,   dna ACGTN )) \n     write ( writer ,   FASTASeqRecord ( seq2 ,   dna TTATA ,   AT rich ))  end", 
            "title": "Writing data"
        }, 
        {
            "location": "/man/reading/#supported-file-formats", 
            "text": "The following table summarizes supported file formats.     File format  Prefix  Module  Specification      FASTA  FASTA  Bio.Seq  https://en.wikipedia.org/wiki/FASTA_format    FASTQ  FASTQ  Bio.Seq  https://en.wikipedia.org/wiki/FASTQ_format    .2bit  TwoBit  Bio.Seq  http://genome.ucsc.edu/FAQ/FAQformat.html#format7    BED  BED  Bio.Intervals  https://genome.ucsc.edu/FAQ/FAQformat.html#format1    GFF3  GFF3  Bio.Intervals  https://github.com/The-Sequence-Ontology/Specifications/blob/master/gff3.md    bigBed  BigBed  Bio.Intervals  https://doi.org/10.1093/bioinformatics/btq351    PDB  PDB  Bio.Structure  http://www.wwpdb.org/documentation/file-format-content/format33/v3.3.html    SAM  SAM  Bio.Align  https://samtools.github.io/hts-specs/SAMv1.pdf    BAM  BAM  Bio.Align  https://samtools.github.io/hts-specs/SAMv1.pdf    VCF  VCF  Bio.Var  https://samtools.github.io/hts-specs/VCFv4.3.pdf    BCF  BCF  Bio.Var  https://samtools.github.io/hts-specs/VCFv4.3.pdf", 
            "title": "Supported file formats"
        }, 
        {
            "location": "/man/reading/#fasta", 
            "text": "Reader type:  FASTA.Reader  Writer type:  FASTA.Writer  Element type:  FASTA.Record   FASTA is a text-based file format for representing biological sequences. A FASTA file stores a list of records with identifier, description, and sequence. The template of a sequence record is:  {identifier} {description}?\n{sequence}  Here is an example of a chromosomal sequence:  chrI chromosome 1\nCCACACCACACCCACACACCCACACACCACACCACACACCACACCACACC\nCACACACACACATCCTAACACTACCCTAACACAGCCCTAATCTAACCCTG  Usually sequence records will be read sequentially from a file by iteration. But if the FASTA file has an auxiliary index file formatted in  fai , the reader supports random access to FASTA records, which would be useful when accessing specific parts of a huge genome sequence:  reader   =   open ( FASTAReader ,   sacCer.fa ,   index = sacCer.fa.fai )  chrIV   =   reader [ chrIV ]    # directly read chromosome 4   #  Bio.Seq.FASTA.Reader     Type .  FASTA . Reader ( input :: IO ;   index = nothing )   Create a data reader of the FASTA file format.  Arguments   input : data source  index=nothing : filepath to a random access index (currently  fai  is supported)   source  #  Bio.Seq.FASTA.Writer     Type .  FASTA . Writer ( output :: IO ;   width = 70 )   Create a data writer of the FASTA file format.  Arguments   output : data sink  width=70 : wrapping width of sequence characters   source  #  Bio.Seq.FASTA.Record     Type .  FASTA.Record()  Create an unfilled FASTA record.  source  FASTA.Record(data::Vector{UInt8})  Create a FASTA record object from  data .  This function verifies and indexes fields for accessors. Note that the ownership of  data  is transferred to a new record object.  source  FASTA.Record(str::AbstractString)  Create a FASTA record object from  str .  This function verifies and indexes fields for accessors.  source  FASTA.Record(identifier, sequence)  Create a FASTA record object from  identifier  and  sequence .  source  FASTA.Record(identifier, description, sequence)  Create a FASTA record object from  identifier ,  description  and  sequence .  source  #  Bio.Seq.FASTA.identifier     Function .  identifier(record::Record)::String  Get the sequence identifier of  record .  source  #  Bio.Seq.FASTA.description     Function .  description(record::Record)::String  Get the description of  record .  source  #  Bio.Seq.FASTA.sequence     Function .  sequence(::Type{S}, record::Record, [part::UnitRange{Int}])::S  Get the sequence of  record .  S  can be either a subtype of  Bio.Seq.Sequence  or  String . If  part  argument is given, it returns the specified part of the sequence.  source  sequence(record::Record, [part::UnitRange{Int}])  Get the sequence of  record .  This function infers the sequence type from the data. When it is wrong or unreliable, use  sequence(::Type{S}, record::Record) .  If  part  argument is given, it returns the specified part of the sequence.  source", 
            "title": "FASTA"
        }, 
        {
            "location": "/man/reading/#fastq", 
            "text": "Reader type:  FASTQReader{S :Sequence}  Writer type:  FASTQWriter{T :IO}  Element type:  SeqRecord{S,FASTQMetadata}  (alias:  FASTQSeqRecord{S} )   FASTQ is a text-based file format for representing DNA sequences along with qualities for each base. A FASTQ file stores a list of sequence records in the following format:  @{name} {description}?\n{sequence}\n+\n{qualities}  Here is an example of one record from a FASTQ file:  @FSRRS4401BE7HA\ntcagTTAAGATGGGAT\n+\n###EEEEEEEEE##E#  To read a file containing such records, one could use:  # The default base quality encoding is Sanger.  reader   =   open ( FASTQReader ,   reads.fastq )  for   record   in   reader \n     # do something  end  close ( reader )  # If performance is important, in-place reading will be much faster.  reader   =   open ( FASTQReader ,   reads.fastq )  record   =   FASTQSeqRecord { DNASequence }()  while   ! eof ( reader ) \n     read! ( reader ,   record ) \n     # do something  end  close ( reader )   #  Bio.Seq.FASTQReader     Type .  FASTQReader(input::IO, quality_encoding=:sanger, fill_ambiguous=nothing)  Create a data reader of the FASTQ file format.  Arguments   input : data source  quality_encoding=:sanger : encoding of base qualities; see the following table for available values  fill_ambiguous=nothing : fill ambiguous nucleotides with the given nucleotide      Quality encoding  Symbol  ASCII offset  Quality range      Sanger  :sanger  +33  0-93    Solexa  :solexa  +64  -5-62    Illumina 1.3+  :illumina13  +64  0-62    Illumina 1.5+  :illumina15  +64  2-62    Illumina 1.8+  :illumina18  +33  0-93     source  #  Bio.Seq.FASTQWriter     Type .  FASTQWriter ( output :: IO ;   quality_header = false ,   quality_encoding = : sanger )   Create a data writer of the FASTQ file format.  Arguments   output : data sink  quality_header=false : output the title line at the third line just after '+'  quality_encoding=:sanger : encoding of base qualities; see  FASTQReader  for available values   source", 
            "title": "FASTQ"
        }, 
        {
            "location": "/man/reading/#2bit", 
            "text": "Reader type:  TwoBit.Reader{T :IO}  Writer type:  TwoBit.Writer{T :IO}  Element type:  TwoBit.Record   .2bit is a binary file format designed for storing a genome consists of multiple chromosomal sequences. The reading speed is often an order of magnitude faster than that of FASTA and the file size is smaller. However, since the .2bit file format is specialized for genomic sequences, it cannot store either RNA or amino acid sequences.  Like FASTA, the .2bit reader supports random access using an index included in the header section of a .2bit file:  reader   =   open ( TwoBit . Reader ,   sacCer.2bit )    # load a random access index in the header  chrIV   =   reader [ chrIV ]                        # directly read chromosome 4   #  Bio.Seq.TwoBit.Reader     Type .  TwoBit.Reader(input::IO)  Create a data reader of the 2bit file format.  Arguments   input : data source   source  #  Bio.Seq.TwoBit.Writer     Type .  TwoBitWriter(output::IO, names::AbstractVector)  Create a data writer of the 2bit file format.  Arguments   output : data sink  names : a vector of sequence names written to  output   source  #  Bio.Seq.TwoBit.Record     Type .  TwoBit.Record()  Create an unfilled 2bit record.  source  #  Bio.Seq.TwoBit.seqnames     Function .  seqnames(reader::Reader)::Vector{String}  Get the sequence names.  Sequences are stored in this order.  source  #  Bio.Seq.TwoBit.sequence     Function .  sequence([::Type{S},] record::Record)::S  Get the sequence of  record  as  S .  S  can be either  Bio.Seq.ReferenceSequence  or  Bio.Seq.DNASequence . If  S  is omitted, the default type is  Bio.Seq.ReferenceSequence .  source  #  Bio.Seq.TwoBit.maskedblocks     Function .  maskedblocks(record::Record)::Vector{UnitRange{Int}}  Get the masked blocks.  source", 
            "title": ".2bit"
        }, 
        {
            "location": "/man/reading/#abif", 
            "text": "Reader type:  AbifReader{T :IO}   ABIF is a binary file format for storing data produced by sequencers, those developed by Applied Biosystems, Inc. When the file is opened, we save all the existing tags, so we can read only the tags that are needed.  reader   =   open ( AbifReader ,   3100.ab1 )         # load a random access  data     =   reader [ DATA ]                       # directly read all existing `DATA` Tags  data     =   reader [ 1 ]                            # directly read Tag at index  data    =   tags ( reader )                         # return all existing tags  # iterator by all tags  for   ( key ,   value )   in   getindex ( reader ,   data )  end   Bio.Seq.AbifReader\nBio.Seq.tags\nBio.Seq.elements", 
            "title": "ABIF"
        }, 
        {
            "location": "/man/reading/#bed", 
            "text": "Reader type:  BED.Reader  Writer type:  BED.Writer  Element type:  BED.Record   BED is a text-based file format for representing genomic annotations like genes, transcripts, and so on. A BED file has tab-delimited and variable-length fields; the first three fields denoting a genomic interval are mandatory.  This is an example of RNA transcripts:  chr9    68331023    68424451    NM_015110   0   +\nchr9    68456943    68486659    NM_001206   0   -  #  Bio.Intervals.BED.Reader     Type .  BED.Reader(input::IO)  Create a data reader of the BED file format.  Arguments:   input : data source   source  #  Bio.Intervals.BED.Writer     Type .  BED.Writer(output::IO)  Create a data writer of the BED file format.  Arguments:   output : data sink   source  #  Bio.Intervals.BED.Record     Type .  BED.Record()  Create an unfilled BED record.  source  BED.Record(data::Vector{UInt8})  Create a BED record object from  data .  This function verifies and indexes fields for accessors. Note that the ownership of  data  is transferred to a new record object.  source  BED.Record(str::AbstractString)  Create a BED record object from  str .  This function verifies and indexes fields for accessors.  source  #  Bio.Intervals.BED.chrom     Function .  chrom(record::Record)::String  Get the chromosome name of  record .  source  #  Bio.Intervals.BED.chromstart     Function .  chromstart(record::Record)::Int  Get the starting position of  record .  Note that the first base is numbered 1.  source  #  Bio.Intervals.BED.chromend     Function .  chromend(record::Record)::Int  Get the end position of  record .  source  #  Bio.Intervals.BED.name     Function .  name(record::Record)::String  Get the name of  record .  source  #  Bio.Intervals.BED.score     Function .  score(record::Record)::Int  Get the score between 0 and 1000.  source  #  Bio.Intervals.BED.strand     Function .  strand(record::Record)::Bio.Intervals.Strand  Get the strand of  record .  source  #  Bio.Intervals.BED.thickstart     Function .  thickstart(record::Record)::Int  Get the starting position at which  record  is drawn thickly.  Note that the first base is numbered 1.  source  #  Bio.Intervals.BED.thickend     Function .  thickend(record::Record)::Int  Get the end position at which  record  is drawn thickly.  source  #  Bio.Intervals.BED.itemrgb     Function .  itemrgb(record::Record)::ColorTypes.RGB  Get the RGB value of  record .  The return type is defined in  ColorTypes.jl .  source  #  Bio.Intervals.BED.blockcount     Function .  blockcount(record::Record)::Int  Get the number of blocks (exons) in  record .  source  #  Bio.Intervals.BED.blocksizes     Function .  blocksizes(record::Record)::Vector{Int}  Get the block (exon) sizes of  record .  source  #  Bio.Intervals.BED.blockstarts     Function .  blockstarts(record::Record)::Vector{Int}  Get the block (exon) starts of  record .  Note that the first base is numbered 1.  source", 
            "title": "BED"
        }, 
        {
            "location": "/man/reading/#gff3", 
            "text": "Reader type:  Bio.Intervals.GFF3.Reader  Writer type:  Bio.Intervals.GFF3.Writer  Element type:  Bio.Intervals.GFF3.Record   GFF3 is a text-based file format for representing genomic annotations. The major difference from BED is that is GFF3 is more structured and can include sequences in the FASTA file format.  #  Bio.Intervals.GFF3.Reader     Type .  GFF3Reader ( input :: IO ;   save_directives :: Bool = false )   Create a reader for data in GFF3 format.  Arguments:   input : data source  save_directives=false : if true, store directive lines, which can be accessed with the  directives  function   source  #  Bio.Intervals.GFF3.Writer     Type .  GFF3.Writer(output::IO)  Create a data writer of the GFF3 file format.  Arguments:   output : data sink   source", 
            "title": "GFF3"
        }, 
        {
            "location": "/man/reading/#bigbed", 
            "text": "Reader type:  BigBedReader  Writer type:  BigBedWriter{T :IO}  Element type:  Interval{BEDMetadata}  (alias:  BEDInterval )   BigBed is a binary file format for representing genomic annotations and often created from BED files. The bigBed files are indexed to quickly fetch specific regions.  #  Bio.Intervals.BigBedReader     Type .  BigBedReader(input::IO)  Create a data reader of the BigBed file format.  Arguments   input : data source   source  #  Bio.Intervals.BigBedWriter     Type .  BigBedWriter(output::IO)  Create a data writer of the BigBed file format.  Arguments   output : data sink   source", 
            "title": "bigBed"
        }, 
        {
            "location": "/man/reading/#pdb", 
            "text": "PDB is a text-based file format for representing 3D macromolecular structures. This has different reader interfaces from other file formats. Please consult the  Bio.Structure  chapter for details.", 
            "title": "PDB"
        }, 
        {
            "location": "/man/reading/#sam", 
            "text": "Reader type:  SAM.Reader  Writer type:  SAM.Writer  Element type:  SAM.Record   SAM is a text-based file format for representing sequence alignments.  #  Bio.Align.SAM.Reader     Type .  SAM.Reader(input::IO)  Create a data reader of the SAM file format.  Arguments   input : data source   source  #  Bio.Align.SAM.header     Function .  header(reader::Reader)::Header  Get the header of  reader .  source  #  Bio.Align.SAM.Header     Type .  SAM.Header()  Create an empty header.  source  #  Base.find     Method .  find(header::Header, key::AbstractString)::Vector{MetaInfo}  Find metainfo objects satisfying  SAM.tag(metainfo) == key .  source  #  Bio.Align.SAM.Writer     Type .  Writer(output::IO, header::Header=Header())  Create a data writer of the SAM file format.  Arguments   output : data sink  header=Header() : SAM header object   source  #  Bio.Align.SAM.MetaInfo     Type .  MetaInfo(str::AbstractString)  Create a SAM metainfo from  str .  Examples  julia  SAM.MetaInfo( @CO    some comment )\nBio.Align.SAM.MetaInfo:\n    tag: CO\n  value: some comment\n\njulia  SAM.MetaInfo( @SQ    SN:chr1 LN:12345 )\nBio.Align.SAM.MetaInfo:\n    tag: SQ\n  value: SN=chr1 LN=12345  source  MetaInfo(tag::AbstractString, value)  Create a SAM metainfo with  tag  and  value .  tag  is a two-byte ASCII string. If  tag  is  \"CO\" ,  value  must be a string; otherwise,  value  is an iterable object with key and value pairs.  Examples  julia  SAM.MetaInfo( CO ,  some comment )\nBio.Align.SAM.MetaInfo:\n    tag: CO\n  value: some comment\n\njulia  string(ans) @CO    some comment \n\njulia  SAM.MetaInfo( SQ , [ SN  =   chr1 ,  LN  =  12345])\nBio.Align.SAM.MetaInfo:\n    tag: SQ\n  value: SN=chr1 LN=12345\n\njulia  string(ans) @SQ    SN:chr1 LN:12345   source  #  Bio.Align.SAM.iscomment     Function .  iscomment(metainfo::MetaInfo)::Bool  Test if  metainfo  is a comment (i.e. its tag is \"CO\").  source  #  Bio.Align.SAM.tag     Function .  tag(metainfo::MetaInfo)::String  Get the tag of  metainfo .  source  #  Bio.Align.SAM.value     Function .  value(metainfo::MetaInfo)::String  Get the value of  metainfo  as a string.  source  #  Bio.Align.SAM.keyvalues     Function .  keyvalues(metainfo::MetaInfo)::Vector{Pair{String,String}}  Get the values of  metainfo  as string pairs.  source  #  Bio.Align.SAM.Record     Type .  SAM.Record()  Create an unfilled SAM record.  source  SAM.Record(data::Vector{UInt8})  Create a SAM record from  data . This function verifies the format and indexes fields for accessors. Note that the ownership of  data  is transferred to a new record object.  source  SAM.Record(str::AbstractString)  Create a SAM record from  str . This function verifies the format and indexes fields for accessors.  source  #  Bio.Align.SAM.flag     Function .  flag(record::Record)::UInt16  Get the bitwise flag of  record .  source  #  Bio.Align.SAM.ismapped     Function .  ismapped(record::Record)::Bool  Test if  record  is mapped.  source  #  Bio.Align.SAM.refname     Function .  refname(record::Record)::String  Get the reference sequence name of  record .  source  #  Bio.Align.SAM.position     Function .  position(record::Record)::Int  Get the 1-based leftmost mapping position of  record .  source  #  Bio.Align.SAM.rightposition     Function .  rightposition(record::Record)::Int  Get the 1-based rightmost mapping position of  record .  source  #  Bio.Align.SAM.isnextmapped     Function .  isnextmapped(record::Record)::Bool  Test if the mate/next read of  record  is mapped.  source  #  Bio.Align.SAM.nextrefname     Function .  nextrefname(record::Record)::String  Get the reference name of the mate/next read of  record .  source  #  Bio.Align.SAM.nextposition     Function .  nextposition(record::Record)::Int  Get the position of the mate/next read of  record .  source  #  Bio.Align.SAM.mappingquality     Function .  mappingquality(record::Record)::UInt8  Get the mapping quality of  record .  source  #  Bio.Align.SAM.cigar     Function .  cigar(record::Record)::String  Get the CIGAR string of  record .  source  #  Bio.Align.SAM.alignment     Function .  alignment(record::Record)::Bio.Align.Alignment  Get the alignment of  record .  source  #  Bio.Align.SAM.alignlength     Function .  alignlength(record::Record)::Int  Get the alignment length of  record .  source  #  Bio.Align.SAM.tempname     Function .  tempname(record::Record)::String  Get the query template name of  record .  source  #  Bio.Align.SAM.templength     Function .  templength(record::Record)::Int  Get the template length of  record .  source  #  Bio.Align.SAM.sequence     Function .  sequence(record::Record)::Bio.Seq.DNASequence  Get the segment sequence of  record .  source  sequence(::Type{String}, record::Record)::String  Get the segment sequence of  record  as  String .  source  #  Bio.Align.SAM.seqlength     Function .  seqlength(record::Record)::Int  Get the sequence length of  record .  source  #  Bio.Align.SAM.quality     Function .  quality(record::Record)::Vector{UInt8}  Get the Phred-scaled base quality of  record .  source  quality(::Type{String}, record::Record)::String  Get the ASCII-encoded base quality of  record .  source  #  Bio.Align.SAM.auxdata     Function .  auxdata(record::Record)::Dict{String,Any}  Get the auxiliary data (optional fields) of  record .  source  This module provides 16-bit flags defined in the SAM specs:     Flag  Bit  Description      SAM.FLAG_PAIRED  0x0001  template having multiple segments in sequencing    SAM.FLAG_PROPER_PAIR  0x0002  each segment properly aligned according to the aligner    SAM.FLAG_UNMAP  0x0004  segment unmapped    SAM.FLAG_MUNMAP  0x0008  next segment in the template unmapped    SAM.FLAG_REVERSE  0x0010  SEQ being reverse complemented    SAM.FLAG_MREVERSE  0x0020  SEQ of the next segment in the template being reverse complemented    SAM.FLAG_READ1  0x0040  the first segment in the template    SAM.FLAG_READ2  0x0080  the last segment in the template    SAM.FLAG_SECONDARY  0x0100  secondary alignment    SAM.FLAG_QCFAIL  0x0200  not passing filters, such as platform/vendor quality controls    SAM.FLAG_DUP  0x0400  PCR or optical duplicate    SAM.FLAG_SUPPLEMENTARY  0x0800  supplementary alignment", 
            "title": "SAM"
        }, 
        {
            "location": "/man/reading/#bam", 
            "text": "Reader type:  BAM.Reader  Writer type:  BAM.Writer  Element type:  BAM.Record   BAM is a binary counterpart of the  SAM  file format.  When writing data in the BAM file format, the underlying output stream needs to be wrapped with a  BGZFStream  object provided from  BGZFStreams.jl .  Flags and the header type are defined in the  SAM  module.  #  Bio.Align.BAM.Reader     Type .  BAM . Reader ( input :: IO ;   index = nothing )   Create a data reader of the BAM file format.  Arguments   input : data source  index=nothing : filepath to a random access index (currently  bai  is Supported)   source  #  Bio.Align.BAM.header     Function .  header ( reader :: Reader ;   fillSQ :: Bool = false ) :: SAM . Header   Get the header of  reader .  If  fillSQ  is  true , this function fills missing \"SQ\" metainfo in the header.  source  #  Bio.Align.BAM.Writer     Type .  BAM.Writer(output::BGZFStream, header::SAM.Header)  Create a data writer of the BAM file format.  Arguments   output : data sink  header : SAM header object   source  #  Bio.Align.BAM.Record     Type .  BAM.Record()  Create an unfilled BAM record.  source  #  Bio.Align.BAM.flag     Function .  flag(record::Record)::UInt16  Get the bitwise flag of  record .  source  #  Bio.Align.BAM.ismapped     Function .  ismapped(record::Record)::Bool  Test if  record  is mapped.  source  #  Bio.Align.BAM.refid     Function .  refid(record::Record)::Int  Get the reference sequence ID of  record .  The ID is 1-based (i.e. the first sequence is 1) and is 0 for a record without a mapping position.  See also:  BAM.rname  source  #  Bio.Align.BAM.refname     Function .  refname(record::Record)::String  Get the reference sequence name of  record .  See also:  BAM.refid  source  #  Bio.Align.BAM.position     Function .  position(record::Record)::Int  Get the 1-based leftmost mapping position of  record .  source  #  Bio.Align.BAM.rightposition     Function .  rightposition(record::Record)::Int  Get the 1-based rightmost mapping position of  record .  source  #  Bio.Align.BAM.isnextmapped     Function .  isnextmapped(record::Record)::Bool  Test if the mate/next read of  record  is mapped.  source  #  Bio.Align.BAM.nextrefid     Function .  nextrefid(record::Record)::Int  Get the next/mate reference sequence ID of  record .  source  #  Bio.Align.BAM.nextrefname     Function .  nextrefname(record::Record)::String  Get the reference name of the mate/next read of  record .  source  #  Bio.Align.BAM.nextposition     Function .  nextposition(record::Record)::Int  Get the 1-based leftmost mapping position of the next/mate read of  record .  source  #  Bio.Align.BAM.mappingquality     Function .  mappingquality(record::Record)::UInt8  Get the mapping quality of  record .  source  #  Bio.Align.BAM.cigar     Function .  cigar(record::Record)::String  Get the CIGAR string of  record .  See also  BAM.cigar_rle .  source  #  Bio.Align.BAM.cigar_rle     Function .  cigar_rle(record::Record)::Tuple{Vector{Bio.Align.Operation},Vector{Int}}  Get a run-length encoded tuple  (ops, lens)  of the CIGAR string in  record .  See also  BAM.cigar .  source  #  Bio.Align.BAM.alignment     Function .  alignment(record::Record)::Bio.Align.Alignment  Get the alignment of  record .  source  #  Bio.Align.BAM.alignlength     Function .  alignlength(record::Record)::Int  Get the alignment length of  record .  source  #  Bio.Align.BAM.tempname     Function .  tempname(record::Record)::String  Get the query template name of  record .  source  #  Bio.Align.BAM.templength     Function .  templength(record::Record)::Int  Get the template length of  record .  source  #  Bio.Align.BAM.sequence     Function .  sequence(record::Record)::Bio.Seq.DNASequence  Get the segment sequence of  record .  source  #  Bio.Align.BAM.seqlength     Function .  seqlength(record::Record)::Int  Get the sequence length of  record .  source  #  Bio.Align.BAM.quality     Function .  quality(record::Record)::Vector{UInt8}  Get the base quality of   record .  source  #  Bio.Align.BAM.auxdata     Function .  auxdata(record::Record)::BAM.AuxData  Get the auxiliary data of  record .  source", 
            "title": "BAM"
        }, 
        {
            "location": "/man/reading/#vcf", 
            "text": "Reader type:  VCF.Reader  Writer type:  VCF.Writer{T :IO}  Element type:  VCF.Record   VCF is a text-based file format for representing genetic variations.  #  Bio.Var.VCF.Reader     Type .  VCF.Reader(input::IO)  Create a data reader of the VCF file format.  Arguments   input : data source   source  #  Bio.Var.VCF.Writer     Type .  VCF.Writer(output::IO, header::VCF.Header)  Create a data writer of the VCF file format.  Arguments   output : data sink  header : VCF header object   source  #  Bio.Var.VCF.Record     Type .  VCF.Record()  Create an unfilled VCF record.  source  VCF.Record(data::Vector{UInt8})  Create a VCF object from  data  containing a VCF record. This function verifies the format and indexes fields for accessors. Note that the ownership of  data  is transferred to a new record.  source  VCF.Record(str::AbstractString)  Create a VCF object from  str  containing a VCF record. This function verifies the format and indexes fields for accessors.  source  #  Bio.Var.VCF.chrom     Function .  chrom(record::Record)::String  Get the chromosome name of  record .  source  #  Bio.Var.VCF.pos     Function .  pos(record::Record)::Int  Get the reference position of  record .  source  #  Bio.Var.VCF.id     Function .  id(record::Record)::Vector{String}  Get the identifiers of  record .  source  #  Bio.Var.VCF.ref     Function .  ref(record::Record)::String  Get the reference bases of  record .  source  #  Bio.Var.VCF.alt     Function .  alt(record::Record)::Vector{String}  Get the alternate bases of  record .  source  #  Bio.Var.VCF.qual     Function .  qual(record::Record)::Float64  Get the quality score of  record .  source  #  Bio.Var.VCF.filter     Function .  filter(record::Record)::Vector{String}  Get the filter status of  record .  source  #  Bio.Var.VCF.info     Function .  info(record::Record)::Vector{Pair{String,String}}  Get the additional information of  record .  source  info(record::Record, key::String)::String  Get the additional information of  record  with  key . Keys without corresponding values return an empty string.  source  #  Bio.Var.VCF.format     Function .  format(record::Record)::Vector{String}  Get the genotype format of  record .  source", 
            "title": "VCF"
        }, 
        {
            "location": "/man/reading/#bcf", 
            "text": "Reader type:  BCF.Reader{T :IO}  Writer type:  BCF.Writer{T :IO}  Element type:  BCF.Record   BCF is a binary counterpart of the VCF file format.  #  Bio.Var.BCF.Reader     Type .  BCF.Reader(input::IO)  Create a data reader of the BCF file format.  Arguments   input : data source   source  #  Bio.Var.BCF.Writer     Type .  BCF.Writer(output::IO, header::VCF.Header)  Create a data writer of the BCF file format.  Arguments   output : data sink  header : VCF header object   source  #  Bio.Var.BCF.Record     Type .  BCF.Record()  Create an unfilled BCF record.  source  #  Bio.Var.BCF.chrom     Function .  chrom(record::Record)::Int  Get the chromosome index of  record .  source  #  Bio.Var.BCF.pos     Function .  pos(record::Record)::Int  Get the reference position of  record .  Note that the position of the first base is 1 (i.e. 1-based coordinate).  source  #  Bio.Var.BCF.rlen     Function .  rlen(record::Record)::Int  Get the length of  record  projected onto the reference sequence.  source  #  Bio.Var.BCF.qual     Function .  qual(record::Record)::Float32  Get the quality score of  record .  Note that  0x7F800001  (signaling NaN) is interpreted as a missing value.  source  #  Bio.Var.BCF.ref     Function .  ref(record::Record)::String  Get the reference bases of  record .  source  #  Bio.Var.BCF.alt     Function .  alt(record::Record)::Vector{String}  Get the alternate bases of  record .  source  #  Bio.Var.BCF.filter     Function .  filter(record::Record)::Vector{Int}  Get the filter indexes of  record .  source  #  Bio.Var.BCF.info     Function .  info(record::Record, [simplify::Bool=true])::Vector{Tuple{Int,Any}}  Get the additional information of  record .  When  simplify  is  true , a vector with a single element is converted to the element itself and an empty vector of the void type is converted to  nothing .  source  info(record::Record, key::Integer, [simplify::Bool=true])  Get the additional information of  record  with  key .  When  simplify  is  true , a vector with a single element is converted to the element itself and an empty vector of the void type is converted to  nothing .  source  #  Bio.Var.BCF.genotype     Function .  genotype(record::Record)::Vector{Tuple{Int,Vector{Any}}}  Get the genotypes of  record .  BCF genotypes are encoded by field, not by sample like VCF.  source", 
            "title": "BCF"
        }, 
        {
            "location": "/man/seq/module/", 
            "text": "The Bio.Seq Module: Biological Sequences\n\n\nThe \nBio.Seq\n module provides several data types for handling biological symbols and sequences.\n\n\n\n\nBiological symbols\n\n\nDNA and RNA nucleotides\n\n\nAmino acids\n\n\nOther functions\n\n\n\n\n\n\nBiological sequences\n\n\nIntroduction to the sequence data-types\n\n\nGeneral-purpose sequences\n\n\nReference sequences\n\n\nNucleic acid k-mers\n\n\n\n\n\n\nSequence search\n\n\nExact search\n\n\nApproximate search\n\n\nRegular expression search\n\n\nSequence composition\n\n\n\n\n\n\nSequence records\n\n\nSequence demultiplexing", 
            "title": "Overview"
        }, 
        {
            "location": "/man/seq/module/#the-bioseq-module-biological-sequences", 
            "text": "The  Bio.Seq  module provides several data types for handling biological symbols and sequences.   Biological symbols  DNA and RNA nucleotides  Amino acids  Other functions    Biological sequences  Introduction to the sequence data-types  General-purpose sequences  Reference sequences  Nucleic acid k-mers    Sequence search  Exact search  Approximate search  Regular expression search  Sequence composition    Sequence records  Sequence demultiplexing", 
            "title": "The Bio.Seq Module: Biological Sequences"
        }, 
        {
            "location": "/man/seq/symbols/", 
            "text": "Biological symbols\n\n\nThe \nBio.Seq\n module provides three biological symbol (character) types:\n\n\n\n\n\n\n\n\nType\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nDNA\n\n\nDNA nucleotide\n\n\n\n\n\n\nRNA\n\n\nRNA nucleotide\n\n\n\n\n\n\nAminoAcid\n\n\nAmino acid\n\n\n\n\n\n\n\n\nThese symbols are elements of biological sequences, just as characters are elements of strings. See sections beginning from \nIntroduction to the sequence data-types\n section for details.\n\n\n\n\nDNA and RNA nucleotides\n\n\nSet of nucleotide symbols in Bio.jl covers IUPAC nucleotide base plus a gap symbol:\n\n\n\n\n\n\n\n\nSymbol\n\n\nConstant\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n'A'\n\n\nDNA_A\n / \nRNA_A\n\n\nA; Adenine\n\n\n\n\n\n\n'C'\n\n\nDNA_C\n / \nRNA_C\n\n\nC; Cytosine\n\n\n\n\n\n\n'G'\n\n\nDNA_G\n / \nRNA_G\n\n\nG; Guanine\n\n\n\n\n\n\n'T'\n\n\nDNA_T\n\n\nT; Thymine (DNA only)\n\n\n\n\n\n\n'U'\n\n\nRNA_U\n\n\nU; Uracil (RNA only)\n\n\n\n\n\n\n'M'\n\n\nDNA_M\n / \nRNA_M\n\n\nA or C\n\n\n\n\n\n\n'R'\n\n\nDNA_R\n / \nRNA_R\n\n\nA or G\n\n\n\n\n\n\n'W'\n\n\nDNA_W\n / \nRNA_W\n\n\nA or T/U\n\n\n\n\n\n\n'S'\n\n\nDNA_S\n / \nRNA_S\n\n\nC or G\n\n\n\n\n\n\n'Y'\n\n\nDNA_Y\n / \nRNA_Y\n\n\nC or T/U\n\n\n\n\n\n\n'K'\n\n\nDNA_K\n / \nRNA_K\n\n\nG or T/U\n\n\n\n\n\n\n'V'\n\n\nDNA_V\n / \nRNA_V\n\n\nA or C or G; not T/U\n\n\n\n\n\n\n'H'\n\n\nDNA_H\n / \nRNA_H\n\n\nA or C or T; not G\n\n\n\n\n\n\n'D'\n\n\nDNA_D\n / \nRNA_D\n\n\nA or G or T/U; not C\n\n\n\n\n\n\n'B'\n\n\nDNA_B\n / \nRNA_B\n\n\nC or G or T/U; not A\n\n\n\n\n\n\n'N'\n\n\nDNA_N\n / \nRNA_N\n\n\nA or C or G or T/U\n\n\n\n\n\n\n'-'\n\n\nDNA_Gap\n / \nRNA_Gap\n\n\nGap (none of the above)\n\n\n\n\n\n\n\n\nhttp://www.insdc.org/documents/feature_table.html#7.4.1\n\n\nSymbols are accessible as constants with \nDNA_\n or \nRNA_\n prefix:\n\n\njulia\n \nDNA_A\n\n\nDNA_A\n\n\n\njulia\n \nDNA_T\n\n\nDNA_T\n\n\n\njulia\n \nRNA_U\n\n\nRNA_U\n\n\n\njulia\n \nDNA_Gap\n\n\nDNA_Gap\n\n\n\njulia\n \ntypeof\n(\nDNA_A\n)\n\n\nBio.Seq.DNA\n\n\n\njulia\n \ntypeof\n(\nRNA_A\n)\n\n\nBio.Seq.RNA\n\n\n\n\n\n\nSymbols can be constructed by converting regular characters:\n\n\njulia\n \nconvert\n(\nDNA\n,\n \nC\n)\n\n\nDNA_C\n\n\n\njulia\n \nconvert\n(\nDNA\n,\n \nC\n)\n \n===\n \nDNA_C\n\n\ntrue\n\n\n\n\n\n\nEvery nucleotide is encoded using the lower 4 bits of a byte. An unambiguous nucleotide has only one set bit and the other bits are unset. The table below summarizes all unambiguous nucleotides and their corresponding bits. An ambiguous nucleotide is the bitwise OR of unambiguous nucleotides that the ambiguous nucleotide can take. For example, \nDNA_R\n (meaning the nucleotide is either \nDNA_A\n or \nDNA_G\n) is encoded as \n0101\n because \n0101\n is the bitwise OR of \n0001\n (\nDNA_A\n) and \n0100\n (\nDNA_G\n). The gap symbol is always \n0000\n.\n\n\n\n\n\n\n\n\nNucleicAcid\n\n\nBits\n\n\n\n\n\n\n\n\n\n\nDNA_A\n, \nRNA_A\n\n\n0001\n\n\n\n\n\n\nDNA_C\n, \nRNA_C\n\n\n0010\n\n\n\n\n\n\nDNA_G\n, \nRNA_G\n\n\n0100\n\n\n\n\n\n\nDNA_T\n, \nRNA_U\n\n\n1000\n\n\n\n\n\n\n\n\nThe next examples demonstrate bit operations of DNA:\n\n\njulia\n \nbits\n(\nreinterpret\n(\nUInt8\n,\n \nDNA_A\n))\n\n\n00000001\n\n\n\njulia\n \nbits\n(\nreinterpret\n(\nUInt8\n,\n \nDNA_G\n))\n\n\n00000100\n\n\n\njulia\n \nbits\n(\nreinterpret\n(\nUInt8\n,\n \nDNA_R\n))\n\n\n00000101\n\n\n\njulia\n \nbits\n(\nreinterpret\n(\nUInt8\n,\n \nDNA_B\n))\n\n\n00001110\n\n\n\njulia\n \n~\nDNA_A\n\n\nDNA_B\n\n\n\njulia\n \nDNA_A\n \n|\n \nDNA_G\n\n\nDNA_R\n\n\n\njulia\n \nDNA_R\n \n \nDNA_B\n\n\nDNA_G\n\n\n\n\n\n\n\n\nAmino acids\n\n\nSet of amino acid symbols also covers IUPAC amino acid symbols plus a gap symbol:\n\n\n\n\n\n\n\n\nSymbol\n\n\nConstant\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n'A'\n\n\nAA_A\n\n\nAlanine\n\n\n\n\n\n\n'R'\n\n\nAA_R\n\n\nArginine\n\n\n\n\n\n\n'N'\n\n\nAA_N\n\n\nAsparagine\n\n\n\n\n\n\n'D'\n\n\nAA_D\n\n\nAspartic acid (Aspartate)\n\n\n\n\n\n\n'C'\n\n\nAA_C\n\n\nCysteine\n\n\n\n\n\n\n'Q'\n\n\nAA_Q\n\n\nGlutamine\n\n\n\n\n\n\n'E'\n\n\nAA_E\n\n\nGlutamic acid (Glutamate)\n\n\n\n\n\n\n'G'\n\n\nAA_G\n\n\nGlycine\n\n\n\n\n\n\n'H'\n\n\nAA_H\n\n\nHistidine\n\n\n\n\n\n\n'I'\n\n\nAA_I\n\n\nIsoleucine\n\n\n\n\n\n\n'L'\n\n\nAA_L\n\n\nLeucine\n\n\n\n\n\n\n'K'\n\n\nAA_K\n\n\nLysine\n\n\n\n\n\n\n'M'\n\n\nAA_M\n\n\nMethionine\n\n\n\n\n\n\n'F'\n\n\nAA_F\n\n\nPhenylalanine\n\n\n\n\n\n\n'P'\n\n\nAA_P\n\n\nProline\n\n\n\n\n\n\n'S'\n\n\nAA_S\n\n\nSerine\n\n\n\n\n\n\n'T'\n\n\nAA_T\n\n\nThreonine\n\n\n\n\n\n\n'W'\n\n\nAA_W\n\n\nTryptophan\n\n\n\n\n\n\n'Y'\n\n\nAA_Y\n\n\nTyrosine\n\n\n\n\n\n\n'V'\n\n\nAA_V\n\n\nValine\n\n\n\n\n\n\n'O'\n\n\nAA_O\n\n\nPyrrolysine\n\n\n\n\n\n\n'U'\n\n\nAA_U\n\n\nSelenocysteine\n\n\n\n\n\n\n'B'\n\n\nAA_B\n\n\nAspartic acid or Asparagine\n\n\n\n\n\n\n'J'\n\n\nAA_J\n\n\nLeucine or Isoleucine\n\n\n\n\n\n\n'Z'\n\n\nAA_Z\n\n\nGlutamine or Glutamic acid\n\n\n\n\n\n\n'X'\n\n\nAA_X\n\n\nAny amino acid\n\n\n\n\n\n\n'*'\n\n\nAA_Term\n\n\nTermination codon\n\n\n\n\n\n\n'-'\n\n\nAA_Gap\n\n\nGap (none of the above)\n\n\n\n\n\n\n\n\nhttp://www.insdc.org/documents/feature_table.html#7.4.3\n\n\nSymbols are accessible as constants with \nAA_\n prefix:\n\n\njulia\n \nAA_A\n\n\nAA_A\n\n\n\njulia\n \nAA_Q\n\n\nAA_Q\n\n\n\njulia\n \nAA_Term\n\n\nAA_Term\n\n\n\njulia\n \ntypeof\n(\nAA_A\n)\n\n\nBio.Seq.AminoAcid\n\n\n\n\n\n\nSymbols can be constructed by converting regular characters:\n\n\njulia\n \nconvert\n(\nAminoAcid\n,\n \nA\n)\n\n\nAA_A\n\n\n\njulia\n \nconvert\n(\nAminoAcid\n,\n \nP\n)\n \n===\n \nAA_P\n\n\ntrue\n\n\n\n\n\n\n\n\nOther functions\n\n\n#\n\n\nBioSymbols.alphabet\n \n \nFunction\n.\n\n\nalphabet(type)\n\n\n\n\n\nGet all symbols of \ntype\n.\n\n\nExamples\n\n\njulia\n \nalphabet\n(\nDNA\n)\n\n\n(DNA_Gap,DNA_A,DNA_C,DNA_M,DNA_G,DNA_R,DNA_S,DNA_V,DNA_T,DNA_W,DNA_Y,DNA_H,DNA_K,DNA_D,DNA_B,DNA_N)\n\n\n\njulia\n \nissorted\n(\nalphabet\n(\nDNA\n))\n\n\ntrue\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBioSymbols.gap\n \n \nFunction\n.\n\n\ngap(type)\n\n\n\n\n\nReturn the gap value of \ntype\n.\n\n\nExamples\n\n\njulia\n \ngap\n(\nDNA\n)\n\n\nDNA_Gap\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBioSymbols.iscompatible\n \n \nFunction\n.\n\n\niscompatible(x, y)\n\n\n\n\n\nTest if \nx\n and \ny\n are compatible with each other (i.e. \nx\n and \ny\n can be the same symbol).\n\n\nx\n and \ny\n must be the same type (\nDNA\n, \nRNA\n or \nAminoAcid\n).\n\n\nExamples\n\n\njulia\n \niscompatible\n(\nDNA_A\n,\n \nDNA_A\n)\n\n\ntrue\n\n\n\njulia\n \niscompatible\n(\nDNA_C\n,\n \nDNA_N\n)\n  \n# DNA_N can be DNA_C\n\n\ntrue\n\n\n\njulia\n \niscompatible\n(\nDNA_C\n,\n \nDNA_R\n)\n  \n# DNA_R (A or G) cannot be DNA_C\n\n\nfalse\n\n\n\njulia\n \niscompatible\n(\nAA_A\n,\n \nAA_X\n)\n    \n# AA_X can be AA_A\n\n\ntrue\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBioSymbols.isambiguous\n \n \nFunction\n.\n\n\nisambiguous(nt::NucleicAcid)\n\n\n\n\n\nTest if \nnt\n is ambiguous nucleotide.\n\n\nsource", 
            "title": "Biological Symbols"
        }, 
        {
            "location": "/man/seq/symbols/#biological-symbols", 
            "text": "The  Bio.Seq  module provides three biological symbol (character) types:     Type  Meaning      DNA  DNA nucleotide    RNA  RNA nucleotide    AminoAcid  Amino acid     These symbols are elements of biological sequences, just as characters are elements of strings. See sections beginning from  Introduction to the sequence data-types  section for details.", 
            "title": "Biological symbols"
        }, 
        {
            "location": "/man/seq/symbols/#dna-and-rna-nucleotides", 
            "text": "Set of nucleotide symbols in Bio.jl covers IUPAC nucleotide base plus a gap symbol:     Symbol  Constant  Meaning      'A'  DNA_A  /  RNA_A  A; Adenine    'C'  DNA_C  /  RNA_C  C; Cytosine    'G'  DNA_G  /  RNA_G  G; Guanine    'T'  DNA_T  T; Thymine (DNA only)    'U'  RNA_U  U; Uracil (RNA only)    'M'  DNA_M  /  RNA_M  A or C    'R'  DNA_R  /  RNA_R  A or G    'W'  DNA_W  /  RNA_W  A or T/U    'S'  DNA_S  /  RNA_S  C or G    'Y'  DNA_Y  /  RNA_Y  C or T/U    'K'  DNA_K  /  RNA_K  G or T/U    'V'  DNA_V  /  RNA_V  A or C or G; not T/U    'H'  DNA_H  /  RNA_H  A or C or T; not G    'D'  DNA_D  /  RNA_D  A or G or T/U; not C    'B'  DNA_B  /  RNA_B  C or G or T/U; not A    'N'  DNA_N  /  RNA_N  A or C or G or T/U    '-'  DNA_Gap  /  RNA_Gap  Gap (none of the above)     http://www.insdc.org/documents/feature_table.html#7.4.1  Symbols are accessible as constants with  DNA_  or  RNA_  prefix:  julia   DNA_A  DNA_A  julia   DNA_T  DNA_T  julia   RNA_U  RNA_U  julia   DNA_Gap  DNA_Gap  julia   typeof ( DNA_A )  Bio.Seq.DNA  julia   typeof ( RNA_A )  Bio.Seq.RNA   Symbols can be constructed by converting regular characters:  julia   convert ( DNA ,   C )  DNA_C  julia   convert ( DNA ,   C )   ===   DNA_C  true   Every nucleotide is encoded using the lower 4 bits of a byte. An unambiguous nucleotide has only one set bit and the other bits are unset. The table below summarizes all unambiguous nucleotides and their corresponding bits. An ambiguous nucleotide is the bitwise OR of unambiguous nucleotides that the ambiguous nucleotide can take. For example,  DNA_R  (meaning the nucleotide is either  DNA_A  or  DNA_G ) is encoded as  0101  because  0101  is the bitwise OR of  0001  ( DNA_A ) and  0100  ( DNA_G ). The gap symbol is always  0000 .     NucleicAcid  Bits      DNA_A ,  RNA_A  0001    DNA_C ,  RNA_C  0010    DNA_G ,  RNA_G  0100    DNA_T ,  RNA_U  1000     The next examples demonstrate bit operations of DNA:  julia   bits ( reinterpret ( UInt8 ,   DNA_A ))  00000001  julia   bits ( reinterpret ( UInt8 ,   DNA_G ))  00000100  julia   bits ( reinterpret ( UInt8 ,   DNA_R ))  00000101  julia   bits ( reinterpret ( UInt8 ,   DNA_B ))  00001110  julia   ~ DNA_A  DNA_B  julia   DNA_A   |   DNA_G  DNA_R  julia   DNA_R     DNA_B  DNA_G", 
            "title": "DNA and RNA nucleotides"
        }, 
        {
            "location": "/man/seq/symbols/#amino-acids", 
            "text": "Set of amino acid symbols also covers IUPAC amino acid symbols plus a gap symbol:     Symbol  Constant  Meaning      'A'  AA_A  Alanine    'R'  AA_R  Arginine    'N'  AA_N  Asparagine    'D'  AA_D  Aspartic acid (Aspartate)    'C'  AA_C  Cysteine    'Q'  AA_Q  Glutamine    'E'  AA_E  Glutamic acid (Glutamate)    'G'  AA_G  Glycine    'H'  AA_H  Histidine    'I'  AA_I  Isoleucine    'L'  AA_L  Leucine    'K'  AA_K  Lysine    'M'  AA_M  Methionine    'F'  AA_F  Phenylalanine    'P'  AA_P  Proline    'S'  AA_S  Serine    'T'  AA_T  Threonine    'W'  AA_W  Tryptophan    'Y'  AA_Y  Tyrosine    'V'  AA_V  Valine    'O'  AA_O  Pyrrolysine    'U'  AA_U  Selenocysteine    'B'  AA_B  Aspartic acid or Asparagine    'J'  AA_J  Leucine or Isoleucine    'Z'  AA_Z  Glutamine or Glutamic acid    'X'  AA_X  Any amino acid    '*'  AA_Term  Termination codon    '-'  AA_Gap  Gap (none of the above)     http://www.insdc.org/documents/feature_table.html#7.4.3  Symbols are accessible as constants with  AA_  prefix:  julia   AA_A  AA_A  julia   AA_Q  AA_Q  julia   AA_Term  AA_Term  julia   typeof ( AA_A )  Bio.Seq.AminoAcid   Symbols can be constructed by converting regular characters:  julia   convert ( AminoAcid ,   A )  AA_A  julia   convert ( AminoAcid ,   P )   ===   AA_P  true", 
            "title": "Amino acids"
        }, 
        {
            "location": "/man/seq/symbols/#other-functions", 
            "text": "#  BioSymbols.alphabet     Function .  alphabet(type)  Get all symbols of  type .  Examples  julia   alphabet ( DNA )  (DNA_Gap,DNA_A,DNA_C,DNA_M,DNA_G,DNA_R,DNA_S,DNA_V,DNA_T,DNA_W,DNA_Y,DNA_H,DNA_K,DNA_D,DNA_B,DNA_N)  julia   issorted ( alphabet ( DNA ))  true   source  #  BioSymbols.gap     Function .  gap(type)  Return the gap value of  type .  Examples  julia   gap ( DNA )  DNA_Gap   source  #  BioSymbols.iscompatible     Function .  iscompatible(x, y)  Test if  x  and  y  are compatible with each other (i.e.  x  and  y  can be the same symbol).  x  and  y  must be the same type ( DNA ,  RNA  or  AminoAcid ).  Examples  julia   iscompatible ( DNA_A ,   DNA_A )  true  julia   iscompatible ( DNA_C ,   DNA_N )    # DNA_N can be DNA_C  true  julia   iscompatible ( DNA_C ,   DNA_R )    # DNA_R (A or G) cannot be DNA_C  false  julia   iscompatible ( AA_A ,   AA_X )      # AA_X can be AA_A  true   source  #  BioSymbols.isambiguous     Function .  isambiguous(nt::NucleicAcid)  Test if  nt  is ambiguous nucleotide.  source", 
            "title": "Other functions"
        }, 
        {
            "location": "/man/seq/sequences/sequences/", 
            "text": "Biological sequences\n\n\nThe \nBio.Seq\n module provides representations and tools for manipulating nucleotide and amino acid sequences.\n\n\n\n\nIntroduction to the sequence data-types\n\n\nSequences in Bio.jl are more strictly typed than in many other libraries; elements in a sequence are typed as biological symbol instead of character or byte. They are special purpose types rather than simply strings and hence offer additional functionality that naive string types don't have. Though this strictness sacrifices some convenience, it also means you can always rely on a DNA sequence type to store DNA and nothing but DNA, without having to check, or deal with lowercase versus uppercase and so on. Strict separation of sequence types also means we are free to choose the most efficient representation. DNA and RNA sequences are encoded using either four bits per base (which is the default), or two bits per base. This makes them memory efficient and allows us to speed up many common operations and transformations, like nucleotide composition, reverse complement, and \nk\n-mer enumeration.\n\n\nThe \nBio.Seq\n provides three different sequence types: \nBioSequence\n, \nKmer\n and \nReferenceSequence\n. Each of these types is a subtype of an abstract type called \nSequence\n and supports various string-like operations such as random access and iteration. Different sequence types have different features. In most situations, \nBioSequence\n type will do and is used as the default representation. But sometimes other types are much more preferable in terms of memory efficiency and computation performance.  Here is the summary table of these three types:\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nElement type\n\n\nMutability\n\n\nAllocation\n\n\n\n\n\n\n\n\n\n\nBioSequence{A\n:Alphabet}\n\n\ngeneral-purpose biological sequences\n\n\nDNA, RNA, Amino acids\n\n\nmutable\n\n\nheap\n\n\n\n\n\n\nKmer{T\n:NucleicAcid,k}\n\n\nspecialized for short nucleotide sequences\n\n\nDNA, RNA\n\n\nimmutable\n\n\nstack / register\n\n\n\n\n\n\nReferenceSequence\n\n\nspecialized for long reference genomes\n\n\nDNA\n\n\nimmutable\n\n\nheap\n\n\n\n\n\n\n\n\nDetails of these different representations are explained in the following sections:\n\n\n\n\nBioSequence\n: \nGeneral-purpose sequences\n\n\nKmer\n: \nNucleic acid k-mers\n\n\nReferenceSequence\n: \nReference sequences", 
            "title": "Overview"
        }, 
        {
            "location": "/man/seq/sequences/sequences/#biological-sequences", 
            "text": "The  Bio.Seq  module provides representations and tools for manipulating nucleotide and amino acid sequences.", 
            "title": "Biological sequences"
        }, 
        {
            "location": "/man/seq/sequences/sequences/#introduction-to-the-sequence-data-types", 
            "text": "Sequences in Bio.jl are more strictly typed than in many other libraries; elements in a sequence are typed as biological symbol instead of character or byte. They are special purpose types rather than simply strings and hence offer additional functionality that naive string types don't have. Though this strictness sacrifices some convenience, it also means you can always rely on a DNA sequence type to store DNA and nothing but DNA, without having to check, or deal with lowercase versus uppercase and so on. Strict separation of sequence types also means we are free to choose the most efficient representation. DNA and RNA sequences are encoded using either four bits per base (which is the default), or two bits per base. This makes them memory efficient and allows us to speed up many common operations and transformations, like nucleotide composition, reverse complement, and  k -mer enumeration.  The  Bio.Seq  provides three different sequence types:  BioSequence ,  Kmer  and  ReferenceSequence . Each of these types is a subtype of an abstract type called  Sequence  and supports various string-like operations such as random access and iteration. Different sequence types have different features. In most situations,  BioSequence  type will do and is used as the default representation. But sometimes other types are much more preferable in terms of memory efficiency and computation performance.  Here is the summary table of these three types:     Type  Description  Element type  Mutability  Allocation      BioSequence{A :Alphabet}  general-purpose biological sequences  DNA, RNA, Amino acids  mutable  heap    Kmer{T :NucleicAcid,k}  specialized for short nucleotide sequences  DNA, RNA  immutable  stack / register    ReferenceSequence  specialized for long reference genomes  DNA  immutable  heap     Details of these different representations are explained in the following sections:   BioSequence :  General-purpose sequences  Kmer :  Nucleic acid k-mers  ReferenceSequence :  Reference sequences", 
            "title": "Introduction to the sequence data-types"
        }, 
        {
            "location": "/man/seq/sequences/bioseq/", 
            "text": "General-purpose sequences\n\n\nBioSequence{A}\n is a generic sequence type parameterized by an alphabet type \nA\n that defines the domain (or set) of biological symbols, and each alphabet has an associated symbol type. For example, \nAminoAcidAlphabet\n is associated with \nAminoAcid\n and hence an object of the \nBioSequence{AminoAcidAlphabet}\n type represents a sequence of amino acids.  Symbols from multiple alphabets can't be intermixed in one sequence type.\n\n\nThe following table summarizes common sequence types that are defined in the \nBio.Seq\n module:\n\n\n\n\n\n\n\n\nType\n\n\nSymbol type\n\n\nType alias\n\n\n\n\n\n\n\n\n\n\nBioSequence{DNAAlphabet{4}}\n\n\nDNA\n\n\nDNASequence\n\n\n\n\n\n\nBioSequence{RNAAlphabet{4}}\n\n\nRNA\n\n\nRNASequence\n\n\n\n\n\n\nBioSequence{AminoAcidAlphabet}\n\n\nAminoAcid\n\n\nAminoAcidSequence\n\n\n\n\n\n\nBioSequence{CharAlphabet}\n\n\nChar\n\n\nCharSequence\n\n\n\n\n\n\n\n\nParameterized definition of the \nBioSequence{A}\n type is for the purpose of unifying the data structure and operations of any symbol type. In most cases, users don't have to care about it and can use type aliases listed above. However, the alphabet type fixes the internal memory encoding and plays an important role when optimizing performance of a program (see \nUsing a more compact sequence representation\n section for low-memory encodings).  It also enables a user to define their own alphabet only by defining few numbers of methods. This is described in \nDefining a new alphabet\n section.\n\n\n\n\nConstructing sequences\n\n\n\n\nUsing string literals\n\n\nMost immediately, sequence literals can be constructed using the string macros \ndna\n, \nrna\n, \naa\n, and \nchar\n:\n\n\njulia\n \ndna\nTACGTANNATC\n\n\n11nt DNA Sequence:\n\n\nTACGTANNATC\n\n\n\njulia\n \nrna\nAUUUGNCCANU\n\n\n11nt RNA Sequence:\n\n\nAUUUGNCCANU\n\n\n\njulia\n \naa\nARNDCQEGHILKMFPSTWYVX\n\n\n21aa Amino Acid Sequence:\n\n\nARNDCQEGHILKMFPSTWYVX\n\n\n\njulia\n \nchar\n\u03b1\u03b2\u03b3\u03b4\u03f5\n\n\n5char Char Sequence:\n\n\n\u03b1\u03b2\u03b3\u03b4\u03f5\n\n\n\n\n\n\nHowever it should be noted that by default these sequence literals allocate the \nBioSequence\n object before the code containing the sequence literal is run. This means there may be occasions where your program does not behave as you first expect. For example consider the following code:\n\n\njulia\n \nfunction\n \nfoo\n()\n\n           \ns\n \n=\n \ndna\nCTT\n\n           \npush!\n(\ns\n,\n \nDNA_A\n)\n\n       \nend\n\n\nfoo (generic function with 1 method)\n\n\n\n\n\n\nYou might expect that every time you call \nfoo\n, that a DNA sequence \nCTTA\n would be returned. You might expect that this is because every time \nfoo\n is called, a new DNA sequence variable \nCTT\n is created, and and \nA\n nucleotide is pushed to it, and the result, \nCTTA\n is returned. In other words you might expect the following output:\n\n\njulia\n \nfoo\n()\n\n\n4nt DNA Sequence:\n\n\nCTTA\n\n\n\njulia\n \nfoo\n()\n\n\n4nt DNA Sequence:\n\n\nCTTA\n\n\n\njulia\n \nfoo\n()\n\n\n4nt DNA Sequence:\n\n\nCTTA\n\n\n\n\n\n\nHowever, this is not what happens, instead the following happens:\n\n\njulia\n \nfoo\n()\n\n\n4nt DNA Sequence:\n\n\nCTTA\n\n\n\njulia\n \nfoo\n()\n\n\n5nt DNA Sequence:\n\n\nCTTAA\n\n\n\njulia\n \nfoo\n()\n\n\n6nt DNA Sequence:\n\n\nCTTAAA\n\n\n\n\n\n\nThe reason for this is because the sequence literal is allocated only once before the first time the function \nfoo\n is called and run. Therefore, \ns\n in \nfoo\n is always a reference to that one sequence that was allocated. So one sequence is created before \nfoo\n is called, and then it is pushed to every time \nfoo\n is called. Thus, that one allocated sequence grows with every call of \nfoo\n.\n\n\nIf you wanted \nfoo\n to create a new sequence each time it is called, then you can add a flag to the end of the sequence literal to dictate behaviour: A flag of 's' means 'static': the sequence will be allocated before code is run, as is the default behaviour described above. However providing 'd' flag changes the behaviour: 'd' means 'dynamic': the sequence will be allocated at whilst the code is running, and not before. So to change \nfoo\n so as it creates a new sequence each time it is called, simply add the 'd' flag to the sequence literal:\n\n\njulia\n \nfunction\n \nfoo\n()\n\n           \ns\n \n=\n \ndna\nCTT\nd\n     \n# \nd\n flag appended to the string literal.\n\n           \npush!\n(\ns\n,\n \nDNA_A\n)\n\n       \nend\n\n\nfoo (generic function with 1 method)\n\n\n\n\n\n\nNow every time \nfoo\n is called, a new sequence \nCTT\n is created, and an \nA\n nucleotide is pushed to it:\n\n\njulia\n \nfoo\n()\n\n\n4nt DNA Sequence:\n\n\nCTTA\n\n\n\njulia\n \nfoo\n()\n\n\n4nt DNA Sequence:\n\n\nCTTA\n\n\n\njulia\n \nfoo\n()\n\n\n4nt DNA Sequence:\n\n\nCTTA\n\n\n\n\n\n\nSo the take home message of sequence literals is this:\n\n\nBe careful when you are using sequence literals inside of functions, and inside the bodies of things like for loops. And if you use them and are unsure, use the  's' and 'd' flags to ensure the behaviour you get is the behaviour you intend.\n\n\n\n\nOther constructors and conversion\n\n\nSequences can also be constructed from strings or arrays of nucleotide or amino acid symbols using constructors or the \nconvert\n function:\n\n\njulia\n \nDNASequence\n(\nTTANC\n)\n\n\n5nt DNA Sequence:\n\n\nTTANC\n\n\n\njulia\n \nDNASequence\n([\nDNA_T\n,\n \nDNA_T\n,\n \nDNA_A\n,\n \nDNA_N\n,\n \nDNA_C\n])\n\n\n5nt DNA Sequence:\n\n\nTTANC\n\n\n\njulia\n \nconvert\n(\nDNASequence\n,\n \n[\nDNA_T\n,\n \nDNA_T\n,\n \nDNA_A\n,\n \nDNA_N\n,\n \nDNA_C\n])\n\n\n5nt DNA Sequence:\n\n\nTTANC\n\n\n\n\n\n\nUsing \nconvert\n, these operations are reversible: sequences can be converted to strings or arrays:\n\n\njulia\n \nconvert\n(\nString\n,\n \ndna\nTTANGTA\n)\n\n\nTTANGTA\n\n\n\njulia\n \nconvert\n(\nVector\n{\nDNA\n},\n \ndna\nTTANGTA\n)\n\n\n7-element Array{Bio.Seq.DNA,1}:\n\n\n DNA_T\n\n\n DNA_T\n\n\n DNA_A\n\n\n DNA_N\n\n\n DNA_G\n\n\n DNA_T\n\n\n DNA_A\n\n\n\n\n\n\nSequences can also be concatenated into longer sequences:\n\n\njulia\n \nDNASequence\n(\ndna\nACGT\n,\n \ndna\nNNNN\n,\n \ndna\nTGCA\n)\n\n\n12nt DNA Sequence:\n\n\nACGTNNNNTGCA\n\n\n\njulia\n \ndna\nACGT\n \n*\n \ndna\nTGCA\n\n\n8nt DNA Sequence:\n\n\nACGTTGCA\n\n\n\njulia\n \nrepeat\n(\ndna\nTA\n,\n \n10\n)\n\n\n20nt DNA Sequence:\n\n\nTATATATATATATATATATA\n\n\n\njulia\n \ndna\nTA\n \n^\n \n10\n\n\n20nt DNA Sequence:\n\n\nTATATATATATATATATATA\n\n\n\n\n\n\nDespite being separate types, \nDNASequence\n and \nRNASequence\n can freely be converted between efficiently without copying the underlying data:\n\n\njulia\n \ndna\n \n=\n \ndna\nTTANGTAGACCG\n\n\n12nt DNA Sequence:\n\n\nTTANGTAGACCG\n\n\n\njulia\n \nrna\n \n=\n \nconvert\n(\nRNASequence\n,\n \ndna\n)\n\n\n12nt RNA Sequence:\n\n\nUUANGUAGACCG\n\n\n\njulia\n \ndna\n.\ndata\n \n===\n \nrna\n.\ndata\n  \n# underlying data are same\n\n\ntrue\n\n\n\n\n\n\nA random sequence can be obtained by the \nranddnaseq\n, \nrandrnaseq\n and \nrandaaseq\n functions, which generate \nDNASequence\n, \nRNASequence\n and \nAminoAcidSequence\n, respectively. Generated sequences are composed of the standard symbols without ambiguity and gap. For example, \nranddnaseq(6)\n may generate \ndna\"TCATAG\"\n but never generates \ndna\"TNANAG\"\n or \ndna\"T-ATAG\"\n.\n\n\nA translatable \nRNASequence\n can also be converted to an \nAminoAcidSequence\n using the \ntranslate\n function.\n\n\n\n\nIndexing, modifying and transformations\n\n\n\n\nGetindex\n\n\nSequences for the most part behave like other vector or string types. They can be indexed using integers or ranges:\n\n\njulia\n \nseq\n \n=\n \ndna\nACGTTTANAGTNNAGTACC\n\n\n19nt DNA Sequence:\n\n\nACGTTTANAGTNNAGTACC\n\n\n\njulia\n \nseq\n[\n5\n]\n\n\nDNA_T\n\n\n\njulia\n \nseq\n[\n6\n:\nend\n]\n\n\n14nt DNA Sequence:\n\n\nTANAGTNNAGTACC\n\n\n\n\n\n\nNote that, indexing a biological sequence by range creates a subsequence of the original sequence. Unlike \nArrays\n in the standard library, creating a subsequence is copy-free: a subsequence simply points to the original sequence data with its range. You may think that this is unsafe because modifying subsequences propagates to the original sequence, but this doesn't happen actually:\n\n\njulia\n \nseq\n \n=\n \ndna\nAAAA\n    \n# create a sequence\n\n\n4nt DNA Sequence:\n\n\nAAAA\n\n\n\njulia\n \nsubseq\n \n=\n \nseq\n[\n1\n:\n2\n]\n  \n# create a subsequence from `seq`\n\n\n2nt DNA Sequence:\n\n\nAA\n\n\n\njulia\n \nsubseq\n[\n2\n]\n \n=\n \nDNA_T\n  \n# modify the second element of it\n\n\nDNA_T\n\n\n\njulia\n \nsubseq\n             \n# the subsequence is modified\n\n\n2nt DNA Sequence:\n\n\nAT\n\n\n\njulia\n \nseq\n                \n# but the original sequence is not\n\n\n4nt DNA Sequence:\n\n\nAAAA\n\n\n\n\n\n\nThis is because modifying a sequence checks whether its underlying data are shared with other sequences under the hood. If and only if the data are shared, the subsequence creates a copy of itself. Any modifying operation does this check. This is called \ncopy-on-write\n strategy and users don't need to care about it because it is transparent: If the user modifies a sequence with or subsequence, the job of managing and protecting the underlying data of sequences is handled for them.\n\n\n\n\nSetindex and modifying DNA sequences\n\n\nThe biological symbol at a given locus in a biological sequence can be set using setindex:\n\n\njulia\n \nseq\n \n=\n \ndna\nACGTTTANAGTNNAGTACC\n\n\n19nt DNA Sequence:\n\n\nACGTTTANAGTNNAGTACC\n\n\n\njulia\n \nseq\n[\n5\n]\n \n=\n \nDNA_A\n\n\nDNA_A\n\n\n\n\n\n\nIn addition, many other modifying operations are possible for biological sequences such as \npush!\n, \npop!\n, and \ninsert!\n, which should be familiar to people used to editing arrays.\n\n\npush!\npop!\nshift!\nunshift!\ninsert!\ndeleteat!(::Bio.Seq.BioSequence, ::Integer)\nappend!\ncopy!\n\n\n\n\n\nHere are some examples:\n\n\njulia\n \nseq\n \n=\n \ndna\nACG\n\n\n3nt DNA Sequence:\n\n\nACG\n\n\n\njulia\n \npush!\n(\nseq\n,\n \nDNA_T\n)\n\n\n4nt DNA Sequence:\n\n\nACGT\n\n\n\njulia\n \nappend!\n(\nseq\n,\n \ndna\nAT\n)\n\n\n6nt DNA Sequence:\n\n\nACGTAT\n\n\n\njulia\n \nreverse!\n(\nseq\n)\n\n\n6nt DNA Sequence:\n\n\nTATGCA\n\n\n\njulia\n \ncomplement!\n(\nseq\n)\n\n\n6nt DNA Sequence:\n\n\nATACGT\n\n\n\njulia\n \nreverse_complement!\n(\nseq\n)\n\n\n6nt DNA Sequence:\n\n\nACGTAT\n\n\n\njulia\n \ndeleteat!\n(\nseq\n,\n \n2\n)\n\n\n5nt DNA Sequence:\n\n\nAGTAT\n\n\n\njulia\n \ndeleteat!\n(\nseq\n,\n \n2\n:\n3\n)\n\n\n3nt DNA Sequence:\n\n\nAAT\n\n\n\n\n\n\n\n\nAdditional transformations\n\n\nIn addition to these basic modifying functions, other sequence transformations which are common in bioinformatics are also provided.\n\n\n#\n\n\nBase.reverse!\n \n \nFunction\n.\n\n\nreverse!(v [, start=1 [, stop=length(v) ]]) -\n v\n\n\n\n\n\nIn-place version of \nreverse\n.\n\n\nsource\n\n\n#\n\n\nBio.Seq.complement!\n \n \nFunction\n.\n\n\ncomplement!(seq)\n\n\n\n\n\nMake a complement sequence of \nseq\n in place.\n\n\nsource\n\n\ncomplement!(seq)\n\n\n\n\n\nTransform \nseq\n into it's complement.\n\n\nsource\n\n\n#\n\n\nBio.Seq.reverse_complement!\n \n \nFunction\n.\n\n\nreverse_complement!(seq)\n\n\n\n\n\nMake a reversed complement sequence of \nseq\n in place.\n\n\nAmbiguous nucleotides are left as-is.\n\n\nsource\n\n\njulia\n \nseq\n \n=\n \ndna\nACG\n\n\n3nt DNA Sequence:\n\n\nACG\n\n\n\njulia\n \npush!\n(\nseq\n,\n \nDNA_T\n)\n\n\n4nt DNA Sequence:\n\n\nACGT\n\n\n\njulia\n \nappend!\n(\nseq\n,\n \ndna\nAT\n)\n\n\n6nt DNA Sequence:\n\n\nACGTAT\n\n\n\njulia\n \nreverse!\n(\nseq\n)\n\n\n6nt DNA Sequence:\n\n\nTATGCA\n\n\n\njulia\n \ncomplement!\n(\nseq\n)\n\n\n6nt DNA Sequence:\n\n\nATACGT\n\n\n\njulia\n \nreverse_complement!\n(\nseq\n)\n\n\n6nt DNA Sequence:\n\n\nACGTAT\n\n\n\n\n\n\n\n\nTranslation\n\n\nTranslation is a slightly more complex transformation for RNA Sequences and so we describe it here in more detail.\n\n\nThe \ntranslate\n funtion translates a sequence of codons in a RNA sequence to a amino acid sequence besed on a genetic code mapping. The \nBio.Seq\n module contains all NCBI defined genetic codes and they are registered in \nncbi_trans_table\n.\n\n\n#\n\n\nBio.Seq.translate\n \n \nFunction\n.\n\n\ntranslate(rna_seq, code=standard_genetic_code, allow_ambiguous_codons=true)\n\n\n\n\n\nTranslate an \nRNASequence\n to an \nAminoAcidSequence\n.\n\n\nTranslation uses genetic code \ncode\n to map codons to amino acids. See \nncbi_trans_table\n for available genetic codes. If codons in the given RNA sequence cannot determine a unique amino acid, they will be translated to \nAA_X\n if \nallow_ambiguous_codons\n is \ntrue\n and otherwise result in an error.\n\n\nsource\n\n\n#\n\n\nBio.Seq.ncbi_trans_table\n \n \nConstant\n.\n\n\nGenetic code list of NCBI.\n\n\nThe standard genetic code is \nncbi_trans_table[1]\n and others can be shown by \nshow(ncbi_trans_table)\n. For more details, consult the next link: http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes.\n\n\nsource\n\n\njulia\n \nncbi_trans_table\n\n\nTranslation Tables:\n\n\n  1. The Standard Code (standard_genetic_code)\n\n\n  2. The Vertebrate Mitochondrial Code (vertebrate_mitochondrial_genetic_code)\n\n\n  3. The Yeast Mitochondrial Code (yeast_mitochondrial_genetic_code)\n\n\n  4. The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code (mold_mitochondrial_genetic_code)\n\n\n  5. The Invertebrate Mitochondrial Code (invertebrate_mitochondrial_genetic_code)\n\n\n  6. The Ciliate, Dasycladacean and Hexamita Nuclear Code (ciliate_nuclear_genetic_code)\n\n\n  9. The Echinoderm and Flatworm Mitochondrial Code (echinoderm_mitochondrial_genetic_code)\n\n\n 10. The Euplotid Nuclear Code (euplotid_nuclear_genetic_code)\n\n\n 11. The Bacterial, Archaeal and Plant Plastid Code (bacterial_plastid_genetic_code)\n\n\n 12. The Alternative Yeast Nuclear Code (alternative_yeast_nuclear_genetic_code)\n\n\n 13. The Ascidian Mitochondrial Code (ascidian_mitochondrial_genetic_code)\n\n\n 14. The Alternative Flatworm Mitochondrial Code (alternative_flatworm_mitochondrial_genetic_code)\n\n\n 16. Chlorophycean Mitochondrial Code (chlorophycean_mitochondrial_genetic_code)\n\n\n 21. Trematode Mitochondrial Code (trematode_mitochondrial_genetic_code)\n\n\n 22. Scenedesmus obliquus Mitochondrial Code (scenedesmus_obliquus_mitochondrial_genetic_code)\n\n\n 23. Thraustochytrium Mitochondrial Code (thraustochytrium_mitochondrial_genetic_code)\n\n\n 24. Pterobranchia Mitochondrial Code (pterobrachia_mitochondrial_genetic_code)\n\n\n 25. Candidate Division SR1 and Gracilibacteria Code (candidate_division_sr1_genetic_code)\n\n\n\n\n\n\nhttp://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes\n\n\n\n\nIteration\n\n\nSequences also work as iterators over symbols:\n\n\njulia\n \nn\n \n=\n \n0\n\n\n0\n\n\n\njulia\n \nfor\n \nnt\n \nin\n \ndna\nATNGNNT\n\n           \nif\n \nnt\n \n==\n \nDNA_N\n\n               \nn\n \n+=\n \n1\n\n           \nend\n\n       \nend\n\n\n\njulia\n \nn\n\n\n3\n\n\n\n\n\n\n\n\nUsing a more compact sequence representation\n\n\nAs we saw above, DNA and RNA sequences can store any ambiguous nucleotides like 'N'.  If you are sure that nucleotide sequences store unambiguous nucleotides only, you can save the memory space of sequences. \nDNAAlphabet{2}\n is an alphabet that uses two bits per base and limits to only unambiguous nucleotide symbols (ACGT in DNA and ACGU in RNA). To create a sequence of this alphabet, you need to explicitly pass \nDNAAlphabet{2}\n to \nBioSequence\n as its type parameter:\n\n\njulia\n \nseq\n \n=\n \nBioSequence\n{\nDNAAlphabet\n{\n2\n}}(\nACGT\n)\n\n\n4nt DNA Sequence:\n\n\nACGT\n\n\n\n\n\n\nRecall that \nDNASequence\n is a type alias of \nBioSequence{DNAAlphabet{4}}\n, which uses four bits per base. That is, \nBioSequence{DNAAlphabet{2}}\n saves half of memory footprint compared to \nBioSequence{DNAAlphabet{4}}\n. If you need to handle reference genomes that are composed of five nucleotides, ACGTN, consider to use the \nReferenceSequence\n type described in the \nReference sequences\n section.\n\n\n\n\nDefining a new alphabet\n\n\nThe alphabet type parameter \nA\n of \nBioSequence{A}\n enables a user to extend functionality of \nBioSequence\n with minimum effort. As an example, definition of a new alphabet type representing a sequence of boolean values is shown below:\n\n\njulia\n \nimmutable\n \nBoolAlphabet\n \n:\n \nAlphabet\n \nend\n\n\n\njulia\n \nSeq\n.\nbitsof\n(\n::\nType\n{\nBoolAlphabet\n})\n \n=\n \n1\n\n\n\njulia\n \nSeq\n.\neltype\n(\n::\nType\n{\nBoolAlphabet\n})\n \n=\n \nBool\n\n\n\njulia\n \nSeq\n.\nalphabet\n(\n::\nType\n{\nBoolAlphabet\n})\n \n=\n \nfalse\n:\ntrue\n\n\n\njulia\n \nfunction\n \nSeq\n.\nencode\n(\n::\nType\n{\nBoolAlphabet\n},\n \nx\n::\nBool\n)\n\n           \nreturn\n \nUInt64\n(\nifelse\n(\nx\n,\n \n0x01\n,\n \n0x00\n))\n\n       \nend\n\n\n\njulia\n \nfunction\n \nSeq\n.\ndecode\n(\n::\nType\n{\nBoolAlphabet\n},\n \nx\n::\nUInt64\n)\n\n           \nif\n \nx\n \n \n0x01\n\n               \nthrow\n(\nSeq\n.\nDecodeError\n(\nBoolAlphabet\n,\n \nx\n))\n\n           \nend\n\n           \nreturn\n \nifelse\n(\nx\n \n==\n \n0x00\n,\n \nfalse\n,\n \ntrue\n)\n\n       \nend", 
            "title": "BioSequence"
        }, 
        {
            "location": "/man/seq/sequences/bioseq/#general-purpose-sequences", 
            "text": "BioSequence{A}  is a generic sequence type parameterized by an alphabet type  A  that defines the domain (or set) of biological symbols, and each alphabet has an associated symbol type. For example,  AminoAcidAlphabet  is associated with  AminoAcid  and hence an object of the  BioSequence{AminoAcidAlphabet}  type represents a sequence of amino acids.  Symbols from multiple alphabets can't be intermixed in one sequence type.  The following table summarizes common sequence types that are defined in the  Bio.Seq  module:     Type  Symbol type  Type alias      BioSequence{DNAAlphabet{4}}  DNA  DNASequence    BioSequence{RNAAlphabet{4}}  RNA  RNASequence    BioSequence{AminoAcidAlphabet}  AminoAcid  AminoAcidSequence    BioSequence{CharAlphabet}  Char  CharSequence     Parameterized definition of the  BioSequence{A}  type is for the purpose of unifying the data structure and operations of any symbol type. In most cases, users don't have to care about it and can use type aliases listed above. However, the alphabet type fixes the internal memory encoding and plays an important role when optimizing performance of a program (see  Using a more compact sequence representation  section for low-memory encodings).  It also enables a user to define their own alphabet only by defining few numbers of methods. This is described in  Defining a new alphabet  section.", 
            "title": "General-purpose sequences"
        }, 
        {
            "location": "/man/seq/sequences/bioseq/#constructing-sequences", 
            "text": "", 
            "title": "Constructing sequences"
        }, 
        {
            "location": "/man/seq/sequences/bioseq/#using-string-literals", 
            "text": "Most immediately, sequence literals can be constructed using the string macros  dna ,  rna ,  aa , and  char :  julia   dna TACGTANNATC  11nt DNA Sequence:  TACGTANNATC  julia   rna AUUUGNCCANU  11nt RNA Sequence:  AUUUGNCCANU  julia   aa ARNDCQEGHILKMFPSTWYVX  21aa Amino Acid Sequence:  ARNDCQEGHILKMFPSTWYVX  julia   char \u03b1\u03b2\u03b3\u03b4\u03f5  5char Char Sequence:  \u03b1\u03b2\u03b3\u03b4\u03f5   However it should be noted that by default these sequence literals allocate the  BioSequence  object before the code containing the sequence literal is run. This means there may be occasions where your program does not behave as you first expect. For example consider the following code:  julia   function   foo () \n            s   =   dna CTT \n            push! ( s ,   DNA_A ) \n        end  foo (generic function with 1 method)   You might expect that every time you call  foo , that a DNA sequence  CTTA  would be returned. You might expect that this is because every time  foo  is called, a new DNA sequence variable  CTT  is created, and and  A  nucleotide is pushed to it, and the result,  CTTA  is returned. In other words you might expect the following output:  julia   foo ()  4nt DNA Sequence:  CTTA  julia   foo ()  4nt DNA Sequence:  CTTA  julia   foo ()  4nt DNA Sequence:  CTTA   However, this is not what happens, instead the following happens:  julia   foo ()  4nt DNA Sequence:  CTTA  julia   foo ()  5nt DNA Sequence:  CTTAA  julia   foo ()  6nt DNA Sequence:  CTTAAA   The reason for this is because the sequence literal is allocated only once before the first time the function  foo  is called and run. Therefore,  s  in  foo  is always a reference to that one sequence that was allocated. So one sequence is created before  foo  is called, and then it is pushed to every time  foo  is called. Thus, that one allocated sequence grows with every call of  foo .  If you wanted  foo  to create a new sequence each time it is called, then you can add a flag to the end of the sequence literal to dictate behaviour: A flag of 's' means 'static': the sequence will be allocated before code is run, as is the default behaviour described above. However providing 'd' flag changes the behaviour: 'd' means 'dynamic': the sequence will be allocated at whilst the code is running, and not before. So to change  foo  so as it creates a new sequence each time it is called, simply add the 'd' flag to the sequence literal:  julia   function   foo () \n            s   =   dna CTT d       #  d  flag appended to the string literal. \n            push! ( s ,   DNA_A ) \n        end  foo (generic function with 1 method)   Now every time  foo  is called, a new sequence  CTT  is created, and an  A  nucleotide is pushed to it:  julia   foo ()  4nt DNA Sequence:  CTTA  julia   foo ()  4nt DNA Sequence:  CTTA  julia   foo ()  4nt DNA Sequence:  CTTA   So the take home message of sequence literals is this:  Be careful when you are using sequence literals inside of functions, and inside the bodies of things like for loops. And if you use them and are unsure, use the  's' and 'd' flags to ensure the behaviour you get is the behaviour you intend.", 
            "title": "Using string literals"
        }, 
        {
            "location": "/man/seq/sequences/bioseq/#other-constructors-and-conversion", 
            "text": "Sequences can also be constructed from strings or arrays of nucleotide or amino acid symbols using constructors or the  convert  function:  julia   DNASequence ( TTANC )  5nt DNA Sequence:  TTANC  julia   DNASequence ([ DNA_T ,   DNA_T ,   DNA_A ,   DNA_N ,   DNA_C ])  5nt DNA Sequence:  TTANC  julia   convert ( DNASequence ,   [ DNA_T ,   DNA_T ,   DNA_A ,   DNA_N ,   DNA_C ])  5nt DNA Sequence:  TTANC   Using  convert , these operations are reversible: sequences can be converted to strings or arrays:  julia   convert ( String ,   dna TTANGTA )  TTANGTA  julia   convert ( Vector { DNA },   dna TTANGTA )  7-element Array{Bio.Seq.DNA,1}:   DNA_T   DNA_T   DNA_A   DNA_N   DNA_G   DNA_T   DNA_A   Sequences can also be concatenated into longer sequences:  julia   DNASequence ( dna ACGT ,   dna NNNN ,   dna TGCA )  12nt DNA Sequence:  ACGTNNNNTGCA  julia   dna ACGT   *   dna TGCA  8nt DNA Sequence:  ACGTTGCA  julia   repeat ( dna TA ,   10 )  20nt DNA Sequence:  TATATATATATATATATATA  julia   dna TA   ^   10  20nt DNA Sequence:  TATATATATATATATATATA   Despite being separate types,  DNASequence  and  RNASequence  can freely be converted between efficiently without copying the underlying data:  julia   dna   =   dna TTANGTAGACCG  12nt DNA Sequence:  TTANGTAGACCG  julia   rna   =   convert ( RNASequence ,   dna )  12nt RNA Sequence:  UUANGUAGACCG  julia   dna . data   ===   rna . data    # underlying data are same  true   A random sequence can be obtained by the  randdnaseq ,  randrnaseq  and  randaaseq  functions, which generate  DNASequence ,  RNASequence  and  AminoAcidSequence , respectively. Generated sequences are composed of the standard symbols without ambiguity and gap. For example,  randdnaseq(6)  may generate  dna\"TCATAG\"  but never generates  dna\"TNANAG\"  or  dna\"T-ATAG\" .  A translatable  RNASequence  can also be converted to an  AminoAcidSequence  using the  translate  function.", 
            "title": "Other constructors and conversion"
        }, 
        {
            "location": "/man/seq/sequences/bioseq/#indexing-modifying-and-transformations", 
            "text": "", 
            "title": "Indexing, modifying and transformations"
        }, 
        {
            "location": "/man/seq/sequences/bioseq/#getindex", 
            "text": "Sequences for the most part behave like other vector or string types. They can be indexed using integers or ranges:  julia   seq   =   dna ACGTTTANAGTNNAGTACC  19nt DNA Sequence:  ACGTTTANAGTNNAGTACC  julia   seq [ 5 ]  DNA_T  julia   seq [ 6 : end ]  14nt DNA Sequence:  TANAGTNNAGTACC   Note that, indexing a biological sequence by range creates a subsequence of the original sequence. Unlike  Arrays  in the standard library, creating a subsequence is copy-free: a subsequence simply points to the original sequence data with its range. You may think that this is unsafe because modifying subsequences propagates to the original sequence, but this doesn't happen actually:  julia   seq   =   dna AAAA      # create a sequence  4nt DNA Sequence:  AAAA  julia   subseq   =   seq [ 1 : 2 ]    # create a subsequence from `seq`  2nt DNA Sequence:  AA  julia   subseq [ 2 ]   =   DNA_T    # modify the second element of it  DNA_T  julia   subseq               # the subsequence is modified  2nt DNA Sequence:  AT  julia   seq                  # but the original sequence is not  4nt DNA Sequence:  AAAA   This is because modifying a sequence checks whether its underlying data are shared with other sequences under the hood. If and only if the data are shared, the subsequence creates a copy of itself. Any modifying operation does this check. This is called  copy-on-write  strategy and users don't need to care about it because it is transparent: If the user modifies a sequence with or subsequence, the job of managing and protecting the underlying data of sequences is handled for them.", 
            "title": "Getindex"
        }, 
        {
            "location": "/man/seq/sequences/bioseq/#setindex-and-modifying-dna-sequences", 
            "text": "The biological symbol at a given locus in a biological sequence can be set using setindex:  julia   seq   =   dna ACGTTTANAGTNNAGTACC  19nt DNA Sequence:  ACGTTTANAGTNNAGTACC  julia   seq [ 5 ]   =   DNA_A  DNA_A   In addition, many other modifying operations are possible for biological sequences such as  push! ,  pop! , and  insert! , which should be familiar to people used to editing arrays.  push!\npop!\nshift!\nunshift!\ninsert!\ndeleteat!(::Bio.Seq.BioSequence, ::Integer)\nappend!\ncopy!  Here are some examples:  julia   seq   =   dna ACG  3nt DNA Sequence:  ACG  julia   push! ( seq ,   DNA_T )  4nt DNA Sequence:  ACGT  julia   append! ( seq ,   dna AT )  6nt DNA Sequence:  ACGTAT  julia   reverse! ( seq )  6nt DNA Sequence:  TATGCA  julia   complement! ( seq )  6nt DNA Sequence:  ATACGT  julia   reverse_complement! ( seq )  6nt DNA Sequence:  ACGTAT  julia   deleteat! ( seq ,   2 )  5nt DNA Sequence:  AGTAT  julia   deleteat! ( seq ,   2 : 3 )  3nt DNA Sequence:  AAT", 
            "title": "Setindex and modifying DNA sequences"
        }, 
        {
            "location": "/man/seq/sequences/bioseq/#additional-transformations", 
            "text": "In addition to these basic modifying functions, other sequence transformations which are common in bioinformatics are also provided.  #  Base.reverse!     Function .  reverse!(v [, start=1 [, stop=length(v) ]]) -  v  In-place version of  reverse .  source  #  Bio.Seq.complement!     Function .  complement!(seq)  Make a complement sequence of  seq  in place.  source  complement!(seq)  Transform  seq  into it's complement.  source  #  Bio.Seq.reverse_complement!     Function .  reverse_complement!(seq)  Make a reversed complement sequence of  seq  in place.  Ambiguous nucleotides are left as-is.  source  julia   seq   =   dna ACG  3nt DNA Sequence:  ACG  julia   push! ( seq ,   DNA_T )  4nt DNA Sequence:  ACGT  julia   append! ( seq ,   dna AT )  6nt DNA Sequence:  ACGTAT  julia   reverse! ( seq )  6nt DNA Sequence:  TATGCA  julia   complement! ( seq )  6nt DNA Sequence:  ATACGT  julia   reverse_complement! ( seq )  6nt DNA Sequence:  ACGTAT", 
            "title": "Additional transformations"
        }, 
        {
            "location": "/man/seq/sequences/bioseq/#translation", 
            "text": "Translation is a slightly more complex transformation for RNA Sequences and so we describe it here in more detail.  The  translate  funtion translates a sequence of codons in a RNA sequence to a amino acid sequence besed on a genetic code mapping. The  Bio.Seq  module contains all NCBI defined genetic codes and they are registered in  ncbi_trans_table .  #  Bio.Seq.translate     Function .  translate(rna_seq, code=standard_genetic_code, allow_ambiguous_codons=true)  Translate an  RNASequence  to an  AminoAcidSequence .  Translation uses genetic code  code  to map codons to amino acids. See  ncbi_trans_table  for available genetic codes. If codons in the given RNA sequence cannot determine a unique amino acid, they will be translated to  AA_X  if  allow_ambiguous_codons  is  true  and otherwise result in an error.  source  #  Bio.Seq.ncbi_trans_table     Constant .  Genetic code list of NCBI.  The standard genetic code is  ncbi_trans_table[1]  and others can be shown by  show(ncbi_trans_table) . For more details, consult the next link: http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes.  source  julia   ncbi_trans_table  Translation Tables:    1. The Standard Code (standard_genetic_code)    2. The Vertebrate Mitochondrial Code (vertebrate_mitochondrial_genetic_code)    3. The Yeast Mitochondrial Code (yeast_mitochondrial_genetic_code)    4. The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code (mold_mitochondrial_genetic_code)    5. The Invertebrate Mitochondrial Code (invertebrate_mitochondrial_genetic_code)    6. The Ciliate, Dasycladacean and Hexamita Nuclear Code (ciliate_nuclear_genetic_code)    9. The Echinoderm and Flatworm Mitochondrial Code (echinoderm_mitochondrial_genetic_code)   10. The Euplotid Nuclear Code (euplotid_nuclear_genetic_code)   11. The Bacterial, Archaeal and Plant Plastid Code (bacterial_plastid_genetic_code)   12. The Alternative Yeast Nuclear Code (alternative_yeast_nuclear_genetic_code)   13. The Ascidian Mitochondrial Code (ascidian_mitochondrial_genetic_code)   14. The Alternative Flatworm Mitochondrial Code (alternative_flatworm_mitochondrial_genetic_code)   16. Chlorophycean Mitochondrial Code (chlorophycean_mitochondrial_genetic_code)   21. Trematode Mitochondrial Code (trematode_mitochondrial_genetic_code)   22. Scenedesmus obliquus Mitochondrial Code (scenedesmus_obliquus_mitochondrial_genetic_code)   23. Thraustochytrium Mitochondrial Code (thraustochytrium_mitochondrial_genetic_code)   24. Pterobranchia Mitochondrial Code (pterobrachia_mitochondrial_genetic_code)   25. Candidate Division SR1 and Gracilibacteria Code (candidate_division_sr1_genetic_code)   http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes", 
            "title": "Translation"
        }, 
        {
            "location": "/man/seq/sequences/bioseq/#iteration", 
            "text": "Sequences also work as iterators over symbols:  julia   n   =   0  0  julia   for   nt   in   dna ATNGNNT \n            if   nt   ==   DNA_N \n                n   +=   1 \n            end \n        end  julia   n  3", 
            "title": "Iteration"
        }, 
        {
            "location": "/man/seq/sequences/bioseq/#using-a-more-compact-sequence-representation", 
            "text": "As we saw above, DNA and RNA sequences can store any ambiguous nucleotides like 'N'.  If you are sure that nucleotide sequences store unambiguous nucleotides only, you can save the memory space of sequences.  DNAAlphabet{2}  is an alphabet that uses two bits per base and limits to only unambiguous nucleotide symbols (ACGT in DNA and ACGU in RNA). To create a sequence of this alphabet, you need to explicitly pass  DNAAlphabet{2}  to  BioSequence  as its type parameter:  julia   seq   =   BioSequence { DNAAlphabet { 2 }}( ACGT )  4nt DNA Sequence:  ACGT   Recall that  DNASequence  is a type alias of  BioSequence{DNAAlphabet{4}} , which uses four bits per base. That is,  BioSequence{DNAAlphabet{2}}  saves half of memory footprint compared to  BioSequence{DNAAlphabet{4}} . If you need to handle reference genomes that are composed of five nucleotides, ACGTN, consider to use the  ReferenceSequence  type described in the  Reference sequences  section.", 
            "title": "Using a more compact sequence representation"
        }, 
        {
            "location": "/man/seq/sequences/bioseq/#defining-a-new-alphabet", 
            "text": "The alphabet type parameter  A  of  BioSequence{A}  enables a user to extend functionality of  BioSequence  with minimum effort. As an example, definition of a new alphabet type representing a sequence of boolean values is shown below:  julia   immutable   BoolAlphabet   :   Alphabet   end  julia   Seq . bitsof ( :: Type { BoolAlphabet })   =   1  julia   Seq . eltype ( :: Type { BoolAlphabet })   =   Bool  julia   Seq . alphabet ( :: Type { BoolAlphabet })   =   false : true  julia   function   Seq . encode ( :: Type { BoolAlphabet },   x :: Bool ) \n            return   UInt64 ( ifelse ( x ,   0x01 ,   0x00 )) \n        end  julia   function   Seq . decode ( :: Type { BoolAlphabet },   x :: UInt64 ) \n            if   x     0x01 \n                throw ( Seq . DecodeError ( BoolAlphabet ,   x )) \n            end \n            return   ifelse ( x   ==   0x00 ,   false ,   true ) \n        end", 
            "title": "Defining a new alphabet"
        }, 
        {
            "location": "/man/seq/sequences/refseq/", 
            "text": "Reference sequences\n\n\nDNASequence\n (alias of \nBioSequence{DNAAlphabet{4}}\n) is a flexible data structure but always consumes 4 bits per base, which will waste a large part of the memory space when storing reference genome sequences.  In such a case, \nReferenceSequence\n is helpful because it compresses positions of 'N' symbols so that long DNA sequences are stored with almost 2 bits per base. An important limitation is that the \nReferenceSequence\n type is immutable due to the compression. Other sequence-like operations are supported:\n\n\njulia\n \nseq\n \n=\n \nReferenceSequence\n(\ndna\nNNCGTATTTTCN\n)\n\n\n12nt Reference Sequence:\n\n\nNNCGTATTTTCN\n\n\n\njulia\n \nseq\n[\n1\n]\n\n\nDNA_N\n\n\n\njulia\n \nseq\n[\n5\n]\n\n\nDNA_T\n\n\n\njulia\n \nseq\n[\n2\n:\n6\n]\n\n\n5nt Reference Sequence:\n\n\nNCGTA\n\n\n\njulia\n \nReferenceSequence\n(\ndna\nATGM\n)\n  \n# DNA_M is not accepted\n\n\nERROR: ArgumentError: invalid symbol M \u2209 {A,C,G,T,N} at 4\n\n\n in convert at /Users/kenta/.julia/v0.4/Bio/src/seq/refseq.jl:58\n\n\n in call at essentials.jl:56", 
            "title": "Reference Sequences"
        }, 
        {
            "location": "/man/seq/sequences/refseq/#reference-sequences", 
            "text": "DNASequence  (alias of  BioSequence{DNAAlphabet{4}} ) is a flexible data structure but always consumes 4 bits per base, which will waste a large part of the memory space when storing reference genome sequences.  In such a case,  ReferenceSequence  is helpful because it compresses positions of 'N' symbols so that long DNA sequences are stored with almost 2 bits per base. An important limitation is that the  ReferenceSequence  type is immutable due to the compression. Other sequence-like operations are supported:  julia   seq   =   ReferenceSequence ( dna NNCGTATTTTCN )  12nt Reference Sequence:  NNCGTATTTTCN  julia   seq [ 1 ]  DNA_N  julia   seq [ 5 ]  DNA_T  julia   seq [ 2 : 6 ]  5nt Reference Sequence:  NCGTA  julia   ReferenceSequence ( dna ATGM )    # DNA_M is not accepted  ERROR: ArgumentError: invalid symbol M \u2209 {A,C,G,T,N} at 4   in convert at /Users/kenta/.julia/v0.4/Bio/src/seq/refseq.jl:58   in call at essentials.jl:56", 
            "title": "Reference sequences"
        }, 
        {
            "location": "/man/seq/sequences/kmer/", 
            "text": "Nucleic acid k-mers\n\n\nA common strategy to simplify the analysis of sequence data is to operate or short k-mers, for size fixed size \nk\n. These can be packed into machine integers allowing extremely efficient code. The \nBio.Seq\n module has built in support for representing short sequences in 64-bit integers. Besides being fixed length, \nKmer\n types, unlike other sequence types cannot contain ambiguous symbols like 'N'.\n\n\nThe \nKmer{T,k}\n type parameterized on symbol type (\nT\n, either \nDNA\n, or \nRNA\n) and size \nk\n. For ease of writing code, two type aliases for each nucleotide type are defined and named as \nDNAKmer{k}\n and \nRNAKmer{k}\n:\n\n\njulia\n \nDNAKmer\n(\nACGT\n)\n  \n# create a DNA 4-mer from a string\n\n\nDNA 4-mer:\n\n\nACGT\n\n\n\njulia\n \nRNAKmer\n(\nACGU\n)\n  \n# create an RNA 4-mer from a string\n\n\nRNA 4-mer:\n\n\nACGU\n\n\n\njulia\n \ntypeof\n(\nDNAKmer\n(\nACGT\n))\n\n\nBio.Seq.Kmer{Bio.Seq.DNA,4}\n\n\n\n\n\n\n#\n\n\nBio.Seq.each\n \n \nFunction\n.\n\n\neach(::Type{Kmer{T,k}}, seq::Sequence[, step=1])\n\n\n\n\n\nInitialize an iterator over all k-mers in a sequence \nseq\n skipping ambiguous nucleotides without changing the reading frame.\n\n\nArguments\n\n\n\n\nKmer{T,k}\n: k-mer type to enumerate.\n\n\nseq\n: a nucleotide sequence.\n\n\nstep=1\n: the number of positions between iterated k-mers\n\n\n\n\nExamples\n\n\n# iterate over DNA codons\nfor (pos, codon) in each(DNAKmer{3}, dna\nATCCTANAGNTACT\n, 3)\n    @show pos, codon\nend\n\n\n\n\n\nsource\n\n\n#\n\n\nBio.Seq.canonical\n \n \nFunction\n.\n\n\ncanonical(kmer::Kmer)\n\n\n\n\n\nReturn the canonical k-mer of \nx\n.\n\n\nA canonical k-mer is the numerical lesser of a k-mer and its reverse complement. This is useful in hashing/counting k-mers in data that is not strand specific, and thus observing k-mer is equivalent to observing its reverse complement.\n\n\nsource\n\n\n#\n\n\nBio.Seq.neighbors\n \n \nFunction\n.\n\n\nneighbors(kmer::Kmer)\n\n\n\n\n\nReturn an iterator through k-mers neighboring \nkmer\n on a de Bruijn graph.\n\n\nsource", 
            "title": "Nucleic acid k-mers"
        }, 
        {
            "location": "/man/seq/sequences/kmer/#nucleic-acid-k-mers", 
            "text": "A common strategy to simplify the analysis of sequence data is to operate or short k-mers, for size fixed size  k . These can be packed into machine integers allowing extremely efficient code. The  Bio.Seq  module has built in support for representing short sequences in 64-bit integers. Besides being fixed length,  Kmer  types, unlike other sequence types cannot contain ambiguous symbols like 'N'.  The  Kmer{T,k}  type parameterized on symbol type ( T , either  DNA , or  RNA ) and size  k . For ease of writing code, two type aliases for each nucleotide type are defined and named as  DNAKmer{k}  and  RNAKmer{k} :  julia   DNAKmer ( ACGT )    # create a DNA 4-mer from a string  DNA 4-mer:  ACGT  julia   RNAKmer ( ACGU )    # create an RNA 4-mer from a string  RNA 4-mer:  ACGU  julia   typeof ( DNAKmer ( ACGT ))  Bio.Seq.Kmer{Bio.Seq.DNA,4}   #  Bio.Seq.each     Function .  each(::Type{Kmer{T,k}}, seq::Sequence[, step=1])  Initialize an iterator over all k-mers in a sequence  seq  skipping ambiguous nucleotides without changing the reading frame.  Arguments   Kmer{T,k} : k-mer type to enumerate.  seq : a nucleotide sequence.  step=1 : the number of positions between iterated k-mers   Examples  # iterate over DNA codons\nfor (pos, codon) in each(DNAKmer{3}, dna ATCCTANAGNTACT , 3)\n    @show pos, codon\nend  source  #  Bio.Seq.canonical     Function .  canonical(kmer::Kmer)  Return the canonical k-mer of  x .  A canonical k-mer is the numerical lesser of a k-mer and its reverse complement. This is useful in hashing/counting k-mers in data that is not strand specific, and thus observing k-mer is equivalent to observing its reverse complement.  source  #  Bio.Seq.neighbors     Function .  neighbors(kmer::Kmer)  Return an iterator through k-mers neighboring  kmer  on a de Bruijn graph.  source", 
            "title": "Nucleic acid k-mers"
        }, 
        {
            "location": "/man/seq/search/", 
            "text": "Sequence search\n\n\nThree kinds of on-line search functions are provided:\n\n\n\n\nExact search\n\n\nApproximate search\n\n\nRegular expression search\n\n\n\n\nThese are all specialized for biological sequences and ambiguities of symbols are considered.\n\n\n\n\nExact search\n\n\nExact search functions search for an occurrence of the query symbol or sequence. Four functions, \nsearch\n, \nsearchindex\n, \nrsearch\n, and \nrsearchindex\n are available:\n\n\njulia\n \nseq\n \n=\n \ndna\nACAGCGTAGCT\n;\n\n\n\njulia\n \nsearch\n(\nseq\n,\n \nDNA_G\n)\n  \n# search a query symbol\n\n\n4:4\n\n\n\njulia\n \nquery\n \n=\n \ndna\nAGC\n;\n\n\n\njulia\n \nsearch\n(\nseq\n,\n \nquery\n)\n  \n# search a query sequence\n\n\n3:5\n\n\n\njulia\n \nsearchindex\n(\nseq\n,\n \nquery\n)\n\n\n3\n\n\n\njulia\n \nrsearch\n(\nseq\n,\n \nquery\n)\n  \n# similar to `search` but in the reverse direction\n\n\n8:10\n\n\n\njulia\n \nrsearchindex\n(\nseq\n,\n \nquery\n)\n  \n# similar to `searchindex` but in the reverse direction\n\n\n8\n\n\n\n\n\n\nThese search functions take ambiguous symbols into account. That is, if two symbols are compatible (e.g. \nDNA_A\n and \nDNA_N\n), they match when searching an occurrence. In the following example, 'N' is a wild card that matches any symbols:\n\n\njulia\n \nsearch\n(\ndna\nACNT\n,\n \nDNA_N\n)\n  \n# \nA\n matches \nN\n\n\n1:1\n\n\n\njulia\n \nsearch\n(\ndna\nACNT\n,\n \ndna\nCGT\n)\n  \n# \nN\n matches \nG\n\n\n2:4\n\n\n\njulia\n \nsearch\n(\ndna\nACGT\n,\n \ndna\nCNT\n)\n  \n# \nG\n matches \nN\n\n\n2:4\n\n\n\n\n\n\nThe exact sequence search needs preprocessing phase of query sequence before searching phase. This would be enough fast for most search applications. But when searching a query sequence to large amounts of target sequences, caching the result of preprocessing may save time. The \nExactSearchQuery\n creates such a preprocessed query object and is applicable to the search functions:\n\n\njulia\n \nquery\n \n=\n \nExactSearchQuery\n(\ndna\nATT\n);\n\n\n\njulia\n \nsearch\n(\ndna\nATTTATT\n,\n \nquery\n)\n\n\n1:3\n\n\n\njulia\n \nrsearch\n(\ndna\nATTTATT\n,\n \nquery\n)\n\n\n5:7\n\n\n\n\n\n\n\n\nApproximate search\n\n\nThe approximate search is similar to the exact search but allows a specific number of errors. That is, it tries to find a subsequence of the target sequence within a specific \nLevenshtein distance\n of the query sequence:\n\n\njulia\n \nseq\n \n=\n \ndna\nACAGCGTAGCT\n;\n\n\n\njulia\n \napproxsearch\n(\nseq\n,\n \ndna\nAGGG\n,\n \n0\n)\n  \n# nothing matches with no errors\n\n\n0:-1\n\n\n\njulia\n \napproxsearch\n(\nseq\n,\n \ndna\nAGGG\n,\n \n1\n)\n  \n# seq[3:5] matches with one error\n\n\n3:6\n\n\n\njulia\n \napproxsearch\n(\nseq\n,\n \ndna\nAGGG\n,\n \n2\n)\n  \n# seq[1:4] matches with two errors\n\n\n1:4\n\n\n\n\n\n\nLike the exact search functions, four kinds of functions (\napproxsearch\n, \napproxsearchindex\n, \napproxrsearch\n, and \napproxrsearchindex\n) are available:\n\n\njulia\n \nseq\n \n=\n \ndna\nACAGCGTAGCT\n;\n \npat\n \n=\n \ndna\nAGGG\n;\n\n\n\njulia\n \napproxsearch\n(\nseq\n,\n \npat\n,\n \n2\n)\n        \n# return the range (forward)\n\n\n1:4\n\n\n\njulia\n \napproxsearchindex\n(\nseq\n,\n \npat\n,\n \n2\n)\n   \n# return the starting index (forward)\n\n\n1\n\n\n\njulia\n \napproxrsearch\n(\nseq\n,\n \npat\n,\n \n2\n)\n       \n# return the range (backward)\n\n\n8:11\n\n\n\njulia\n \napproxrsearchindex\n(\nseq\n,\n \npat\n,\n \n2\n)\n  \n# return the starting index (backward)\n\n\n8\n\n\n\n\n\n\nPreprocessing can be cached in an \nApproximateSearchQuery\n object:\n\n\njulia\n \nquery\n \n=\n \nApproximateSearchQuery\n(\ndna\nAGGG\n);\n\n\n\njulia\n \napproxsearch\n(\ndna\nAAGAGG\n,\n \nquery\n,\n \n1\n)\n\n\n2:5\n\n\n\njulia\n \napproxsearch\n(\ndna\nACTACGT\n,\n \nquery\n,\n \n2\n)\n\n\n4:6\n\n\n\n\n\n\n\n\nRegular expression search\n\n\nQuery patterns can be described in regular expressions. The syntax supports a subset of Perl and PROSITE's notation.\n\n\nThe Perl-like syntax starts with \nbiore\n (\nbio\nlogical \nre\ngular expression) and ends with a symbol option: \"dna\", \"rna\" or \"aa\". For example, \nbiore\"A+\"dna\n is a regular expression for DNA sequences and \nbiore\"A+\"aa\n is for amino acid sequences. The symbol options can be abbreviated to its first character: \"d\", \"r\" or \"a\", respectively.\n\n\nHere are examples of using the regular expression for \nBioSequence\ns:\n\n\njulia\n \nmatch\n(\nbiore\nA+C*\ndna\n,\n \ndna\nAAAACC\n)\n\n\nNullable{Bio.Seq.RE.RegexMatch{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}}(RegexMatch(\nAAAACC\n))\n\n\n\njulia\n \nmatch\n(\nbiore\nA+C*\nd\n,\n \ndna\nAAAACC\n)\n\n\nNullable{Bio.Seq.RE.RegexMatch{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}}(RegexMatch(\nAAAACC\n))\n\n\n\njulia\n \nismatch\n(\nbiore\nA+C*\ndna\n,\n \ndna\nAAC\n)\n\n\ntrue\n\n\n\njulia\n \nismatch\n(\nbiore\nA+C*\ndna\n,\n \ndna\nC\n)\n\n\nfalse\n\n\n\n\n\n\nmatch\n always returns a \nNullable\n object and it should be null if no match is found.\n\n\nThe table below summarizes available syntax elements.\n\n\n\n\n\n\n\n\nSyntax\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n\\|\n\n\nalternation\n\n\n\"A\\|T\"\n matches \n\"A\"\n and \n\"T\"\n\n\n\n\n\n\n*\n\n\nzero or more times repeat\n\n\n\"TA*\"\n matches \n\"T\"\n, \n\"TA\"\n and \n\"TAA\"\n\n\n\n\n\n\n+\n\n\none or more times repeat\n\n\n\"TA+\"\n matches \n\"TA\"\n and \n\"TAA\"\n\n\n\n\n\n\n?\n\n\nzero or one time\n\n\n\"TA?\"\n matches \n\"T\"\n and \n\"TA\"\n\n\n\n\n\n\n{n,}\n\n\nn\n or more times repeat\n\n\n\"A{3,}\"\n matches \n\"AAA\"\n and \n\"AAAA\"\n\n\n\n\n\n\n{n,m}\n\n\nn\n-\nm\n times repeat\n\n\n\"A{3,5}\"\n matches \n\"AAA\"\n, \n\"AAAA\"\n and \n\"AAAAA\"\n\n\n\n\n\n\n^\n\n\nthe start of the sequence\n\n\n\"^TAN*\"\n matches \n\"TATGT\"\n\n\n\n\n\n\n$\n\n\nthe end of the sequence\n\n\n\"N*TA$\"\n matches \n\"GCTA\"\n\n\n\n\n\n\n(...)\n\n\npattern grouping\n\n\n\"(TA)+\"\n matches \n\"TA\"\n and \n\"TATA\"\n\n\n\n\n\n\n[...]\n\n\none of symbols\n\n\n\"[ACG]+\"\n matches \n\"AGGC\"\n\n\n\n\n\n\n\n\neachmatch\n, \nmatchall\n, and \nsearch\n are also defined like usual strings:\n\n\njulia\n \nmatchall\n(\nbiore\nTATA*?\nd\n,\n \ndna\nTATTATAATTA\n)\n  \n# overlap (default)\n\n\n4-element Array{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},1}:\n\n\n TAT  \n\n\n TAT  \n\n\n TATA\n\n\n TATAA\n\n\n\njulia\n \nmatchall\n(\nbiore\nTATA*\nd\n,\n \ndna\nTATTATAATTA\n,\n \nfalse\n)\n  \n# no overlap\n\n\n2-element Array{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},1}:\n\n\n TAT  \n\n\n TATAA\n\n\n\njulia\n \nsearch\n(\ndna\nTATTATAATTA\n,\n \nbiore\nTATA*\nd\n)\n\n\n1:3\n\n\n\njulia\n \nsearch\n(\ndna\nTATTATAATTA\n,\n \nbiore\nTATA*\nd\n,\n \n2\n)\n\n\n4:8\n\n\n\n\n\n\nNotewothy differences from strings are:\n\n\n\n\nAmbiguous characters match any compatible characters (e.g. \nbiore\"N\"d\n is equivalent to \nbiore\"[ACGT]\"d\n).\n\n\nWhitespaces are ignored (e.g. \nbiore\"A C G\"d\n is equivalent to \nbiore\"ACG\"d\n).\n\n\n\n\nThe PROSITE notation is described in \nScanProsite - user manual\n. The syntax supports almost all notations including the extended syntax. The PROSITE notation starts with \nprosite\n prefix and no symbol option is needed because it always describes patterns of amino acid sequences:\n\n\njulia\n \nmatch\n(\nprosite\n[AC]-x-V-x(4)-{ED}\n,\n \naa\nCPVPQARG\n)\n\n\nNullable{Bio.Seq.RE.RegexMatch{Bio.Seq.BioSequence{Bio.Seq.AminoAcidAlphabet}}}(RegexMatch(\nCPVPQARG\n))\n\n\n\njulia\n \nmatch\n(\nprosite\n[AC]xVx(4){ED}\n,\n \naa\nCPVPQARG\n)\n\n\nNullable{Bio.Seq.RE.RegexMatch{Bio.Seq.BioSequence{Bio.Seq.AminoAcidAlphabet}}}(RegexMatch(\nCPVPQARG\n))\n\n\n\n\n\n\n\n\nSequence composition\n\n\nSequence composition can be easily calculated using the \ncomposition\n function:\n\n\njulia\n \ncomp\n \n=\n \ncomposition\n(\ndna\nACGAG\n)\n\n\nDNA Composition:\n\n\n  DNA_Gap =\n 0\n\n\n  DNA_A   =\n 2\n\n\n  DNA_C   =\n 1\n\n\n  DNA_M   =\n 0\n\n\n  DNA_G   =\n 2\n\n\n  DNA_R   =\n 0\n\n\n  DNA_S   =\n 0\n\n\n  DNA_V   =\n 0\n\n\n  DNA_T   =\n 0\n\n\n  DNA_W   =\n 0\n\n\n  DNA_Y   =\n 0\n\n\n  DNA_H   =\n 0\n\n\n  DNA_K   =\n 0\n\n\n  DNA_D   =\n 0\n\n\n  DNA_B   =\n 0\n\n\n  DNA_N   =\n 0\n\n\n\njulia\n \ncomp\n[\nDNA_A\n]\n\n\n2\n\n\n\njulia\n \ncomp\n[\nDNA_T\n]\n\n\n0\n\n\n\n\n\n\nTo accumulate composition statistics of multiple sequences, \nmerge!\n can be used as follows:\n\n\njulia\n \n# initiaize an empty composition counter\n\n       \ncomp\n \n=\n \ncomposition\n(\ndna\n);\n\n\nERROR\n:\n \nUndefVarError\n:\n \n@dna_str\n \nnot\n \ndefined\n\n\n\njulia\n \n# iterate over sequences and accumulate composition statistics into `comp`\n\n       \nfor\n \nseq\n \nin\n \nseqs\n\n           \nmerge!\n(\ncomp\n,\n \ncomposition\n(\nseq\n))\n\n       \nend\n\n\nERROR\n:\n \nUndefVarError\n:\n \nseqs\n \nnot\n \ndefined\n\n\n\njulia\n \n# or functional programming style in one line\n\n       \nfoldl\n((\nx\n,\n \ny\n)\n \n-\n \nmerge\n(\nx\n,\n \ncomposition\n(\ny\n)),\n \ncomposition\n(\ndna\n),\n \nseqs\n)\n\n\nERROR\n:\n \nUndefVarError\n:\n \n@dna_str\n \nnot\n \ndefined\n\n\n\n\n\n\ncomposition\n is also applicable to a \nk\n-mer iterator:\n\n\njulia\n \ncomp\n \n=\n \ncomposition\n(\neach\n(\nDNAKmer\n{\n4\n},\n \ndna\nACGT\n^\n100\n));\n\n\n\njulia\n \ncomp\n[\nDNAKmer\n(\nACGT\n)]\n\n\n100\n\n\n\njulia\n \ncomp\n[\nDNAKmer\n(\nCGTA\n)]\n\n\n99", 
            "title": "Searching"
        }, 
        {
            "location": "/man/seq/search/#sequence-search", 
            "text": "Three kinds of on-line search functions are provided:   Exact search  Approximate search  Regular expression search   These are all specialized for biological sequences and ambiguities of symbols are considered.", 
            "title": "Sequence search"
        }, 
        {
            "location": "/man/seq/search/#exact-search", 
            "text": "Exact search functions search for an occurrence of the query symbol or sequence. Four functions,  search ,  searchindex ,  rsearch , and  rsearchindex  are available:  julia   seq   =   dna ACAGCGTAGCT ;  julia   search ( seq ,   DNA_G )    # search a query symbol  4:4  julia   query   =   dna AGC ;  julia   search ( seq ,   query )    # search a query sequence  3:5  julia   searchindex ( seq ,   query )  3  julia   rsearch ( seq ,   query )    # similar to `search` but in the reverse direction  8:10  julia   rsearchindex ( seq ,   query )    # similar to `searchindex` but in the reverse direction  8   These search functions take ambiguous symbols into account. That is, if two symbols are compatible (e.g.  DNA_A  and  DNA_N ), they match when searching an occurrence. In the following example, 'N' is a wild card that matches any symbols:  julia   search ( dna ACNT ,   DNA_N )    #  A  matches  N  1:1  julia   search ( dna ACNT ,   dna CGT )    #  N  matches  G  2:4  julia   search ( dna ACGT ,   dna CNT )    #  G  matches  N  2:4   The exact sequence search needs preprocessing phase of query sequence before searching phase. This would be enough fast for most search applications. But when searching a query sequence to large amounts of target sequences, caching the result of preprocessing may save time. The  ExactSearchQuery  creates such a preprocessed query object and is applicable to the search functions:  julia   query   =   ExactSearchQuery ( dna ATT );  julia   search ( dna ATTTATT ,   query )  1:3  julia   rsearch ( dna ATTTATT ,   query )  5:7", 
            "title": "Exact search"
        }, 
        {
            "location": "/man/seq/search/#approximate-search", 
            "text": "The approximate search is similar to the exact search but allows a specific number of errors. That is, it tries to find a subsequence of the target sequence within a specific  Levenshtein distance  of the query sequence:  julia   seq   =   dna ACAGCGTAGCT ;  julia   approxsearch ( seq ,   dna AGGG ,   0 )    # nothing matches with no errors  0:-1  julia   approxsearch ( seq ,   dna AGGG ,   1 )    # seq[3:5] matches with one error  3:6  julia   approxsearch ( seq ,   dna AGGG ,   2 )    # seq[1:4] matches with two errors  1:4   Like the exact search functions, four kinds of functions ( approxsearch ,  approxsearchindex ,  approxrsearch , and  approxrsearchindex ) are available:  julia   seq   =   dna ACAGCGTAGCT ;   pat   =   dna AGGG ;  julia   approxsearch ( seq ,   pat ,   2 )          # return the range (forward)  1:4  julia   approxsearchindex ( seq ,   pat ,   2 )     # return the starting index (forward)  1  julia   approxrsearch ( seq ,   pat ,   2 )         # return the range (backward)  8:11  julia   approxrsearchindex ( seq ,   pat ,   2 )    # return the starting index (backward)  8   Preprocessing can be cached in an  ApproximateSearchQuery  object:  julia   query   =   ApproximateSearchQuery ( dna AGGG );  julia   approxsearch ( dna AAGAGG ,   query ,   1 )  2:5  julia   approxsearch ( dna ACTACGT ,   query ,   2 )  4:6", 
            "title": "Approximate search"
        }, 
        {
            "location": "/man/seq/search/#regular-expression-search", 
            "text": "Query patterns can be described in regular expressions. The syntax supports a subset of Perl and PROSITE's notation.  The Perl-like syntax starts with  biore  ( bio logical  re gular expression) and ends with a symbol option: \"dna\", \"rna\" or \"aa\". For example,  biore\"A+\"dna  is a regular expression for DNA sequences and  biore\"A+\"aa  is for amino acid sequences. The symbol options can be abbreviated to its first character: \"d\", \"r\" or \"a\", respectively.  Here are examples of using the regular expression for  BioSequence s:  julia   match ( biore A+C* dna ,   dna AAAACC )  Nullable{Bio.Seq.RE.RegexMatch{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}}(RegexMatch( AAAACC ))  julia   match ( biore A+C* d ,   dna AAAACC )  Nullable{Bio.Seq.RE.RegexMatch{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}}(RegexMatch( AAAACC ))  julia   ismatch ( biore A+C* dna ,   dna AAC )  true  julia   ismatch ( biore A+C* dna ,   dna C )  false   match  always returns a  Nullable  object and it should be null if no match is found.  The table below summarizes available syntax elements.     Syntax  Description  Example      \\|  alternation  \"A\\|T\"  matches  \"A\"  and  \"T\"    *  zero or more times repeat  \"TA*\"  matches  \"T\" ,  \"TA\"  and  \"TAA\"    +  one or more times repeat  \"TA+\"  matches  \"TA\"  and  \"TAA\"    ?  zero or one time  \"TA?\"  matches  \"T\"  and  \"TA\"    {n,}  n  or more times repeat  \"A{3,}\"  matches  \"AAA\"  and  \"AAAA\"    {n,m}  n - m  times repeat  \"A{3,5}\"  matches  \"AAA\" ,  \"AAAA\"  and  \"AAAAA\"    ^  the start of the sequence  \"^TAN*\"  matches  \"TATGT\"    $  the end of the sequence  \"N*TA$\"  matches  \"GCTA\"    (...)  pattern grouping  \"(TA)+\"  matches  \"TA\"  and  \"TATA\"    [...]  one of symbols  \"[ACG]+\"  matches  \"AGGC\"     eachmatch ,  matchall , and  search  are also defined like usual strings:  julia   matchall ( biore TATA*? d ,   dna TATTATAATTA )    # overlap (default)  4-element Array{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},1}:   TAT     TAT     TATA   TATAA  julia   matchall ( biore TATA* d ,   dna TATTATAATTA ,   false )    # no overlap  2-element Array{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},1}:   TAT     TATAA  julia   search ( dna TATTATAATTA ,   biore TATA* d )  1:3  julia   search ( dna TATTATAATTA ,   biore TATA* d ,   2 )  4:8   Notewothy differences from strings are:   Ambiguous characters match any compatible characters (e.g.  biore\"N\"d  is equivalent to  biore\"[ACGT]\"d ).  Whitespaces are ignored (e.g.  biore\"A C G\"d  is equivalent to  biore\"ACG\"d ).   The PROSITE notation is described in  ScanProsite - user manual . The syntax supports almost all notations including the extended syntax. The PROSITE notation starts with  prosite  prefix and no symbol option is needed because it always describes patterns of amino acid sequences:  julia   match ( prosite [AC]-x-V-x(4)-{ED} ,   aa CPVPQARG )  Nullable{Bio.Seq.RE.RegexMatch{Bio.Seq.BioSequence{Bio.Seq.AminoAcidAlphabet}}}(RegexMatch( CPVPQARG ))  julia   match ( prosite [AC]xVx(4){ED} ,   aa CPVPQARG )  Nullable{Bio.Seq.RE.RegexMatch{Bio.Seq.BioSequence{Bio.Seq.AminoAcidAlphabet}}}(RegexMatch( CPVPQARG ))", 
            "title": "Regular expression search"
        }, 
        {
            "location": "/man/seq/search/#sequence-composition", 
            "text": "Sequence composition can be easily calculated using the  composition  function:  julia   comp   =   composition ( dna ACGAG )  DNA Composition:    DNA_Gap =  0    DNA_A   =  2    DNA_C   =  1    DNA_M   =  0    DNA_G   =  2    DNA_R   =  0    DNA_S   =  0    DNA_V   =  0    DNA_T   =  0    DNA_W   =  0    DNA_Y   =  0    DNA_H   =  0    DNA_K   =  0    DNA_D   =  0    DNA_B   =  0    DNA_N   =  0  julia   comp [ DNA_A ]  2  julia   comp [ DNA_T ]  0   To accumulate composition statistics of multiple sequences,  merge!  can be used as follows:  julia   # initiaize an empty composition counter \n        comp   =   composition ( dna );  ERROR :   UndefVarError :   @dna_str   not   defined  julia   # iterate over sequences and accumulate composition statistics into `comp` \n        for   seq   in   seqs \n            merge! ( comp ,   composition ( seq )) \n        end  ERROR :   UndefVarError :   seqs   not   defined  julia   # or functional programming style in one line \n        foldl (( x ,   y )   -   merge ( x ,   composition ( y )),   composition ( dna ),   seqs )  ERROR :   UndefVarError :   @dna_str   not   defined   composition  is also applicable to a  k -mer iterator:  julia   comp   =   composition ( each ( DNAKmer { 4 },   dna ACGT ^ 100 ));  julia   comp [ DNAKmer ( ACGT )]  100  julia   comp [ DNAKmer ( CGTA )]  99", 
            "title": "Sequence composition"
        }, 
        {
            "location": "/man/seq/seqrecords/", 
            "text": "Sequence records\n\n\nThe \nSeqRecord\n type is used to represent a named sequence, optionally with accompanying metadata. It is defined as: sequence. It is as:\n\n\ntype SeqRecord{S, T}\n\n\n    name::String\n\n\n    seq::S\n\n\n    metadata::T\n\n\nend\n\n\n\n\n\n\nThe type of the \nmetadata\n field depends on the source of the sequence record. For example, if a record is read from a FASTA file, metadata contains the description field. If from a FASTQ file, a quality scores assigned to base calls during sequencing.\n\n\nThe following accessors are defined for the \nSeqRecord\n type:\n\n\n#\n\n\nBio.seqname\n \n \nFunction\n.\n\n\nseqname(record)\n\n\n\n\n\nReturn the sequence name of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.sequence\n \n \nFunction\n.\n\n\nsequence(record)\n\n\n\n\n\nReturn the sequence of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBio.metadata\n \n \nFunction\n.\n\n\nmetadata(record)\n\n\n\n\n\nReturn the metadata of \nrecord\n.\n\n\nsource", 
            "title": "Sequence Records"
        }, 
        {
            "location": "/man/seq/seqrecords/#sequence-records", 
            "text": "The  SeqRecord  type is used to represent a named sequence, optionally with accompanying metadata. It is defined as: sequence. It is as:  type SeqRecord{S, T}      name::String      seq::S      metadata::T  end   The type of the  metadata  field depends on the source of the sequence record. For example, if a record is read from a FASTA file, metadata contains the description field. If from a FASTQ file, a quality scores assigned to base calls during sequencing.  The following accessors are defined for the  SeqRecord  type:  #  Bio.seqname     Function .  seqname(record)  Return the sequence name of  record .  source  #  Bio.sequence     Function .  sequence(record)  Return the sequence of  record .  source  #  Bio.metadata     Function .  metadata(record)  Return the metadata of  record .  source", 
            "title": "Sequence records"
        }, 
        {
            "location": "/man/seq/demultiplexer/", 
            "text": "Sequence demultiplexing\n\n\nMultiplex sequencing is a technology to sequence multiple samples at the same time on a high-throughput DNA sequencer. Samples are distinguished by the short prefix of a DNA sequence called DNA barcode. The \nBio.Seq\n offers the \nDemultiplexer\n type and the \ndemultiplex\n function to identify the DNA barcode of a longer DNA sequence allowing small errors.\n\n\nIn the following example, four kinds of DNA sequences of length 4 are used as DNA barcodes. \nDemultiplexer\n takes these barcodes as its first argument with a few options:\n\n\njulia\n \nbarcodes\n \n=\n \nDNASequence\n[\nATGG\n,\n \nCAGA\n,\n \nGGAA\n,\n \nTACG\n];\n\n\n\njulia\n \ndplxr\n \n=\n \nDemultiplexer\n(\nbarcodes\n,\n \nn_max_errors\n=\n1\n,\n \ndistance\n=:\nhamming\n)\n\n\nBio.Seq.Demultiplexer{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:\n\n\n  distance: hamming\n\n\n  number of barcodes: 4\n\n\n  number of correctable errors: 1\n\n\n\n\n\n\nn_max_errors\n specifies the number of maximum correctable errors in a barcode. The type of correctable errors depends on the \ndistance\n parameter. When \ndistance = :hamming\n as shown above only substitutions are correctable. When \ndistance = :levenshtein\n substitutions, deletions, and insertions are correctable. The user is responsible for keeping enough distances among barcodes; \nDemultiplexer\n will throw an exception if two barcodes are within \nn_max_errors * 2\n.\n\n\nThe \ndemultiplex\n function takes a demultiplexer object and a DNA sequence, and returns a tuple of a barcode index and a distance between the original barcode sequence and the prefix sequence:\n\n\njulia\n \ndemultiplex\n(\ndplxr\n,\n \ndna\nATGGCGNT\n)\n  \n# 1st barcode with no errors\n\n\n(1,0)\n\n\n\njulia\n \ndemultiplex\n(\ndplxr\n,\n \ndna\nCAGGCGNT\n)\n  \n# 2nd barcode with one error\n\n\n(2,1)\n\n\n\njulia\n \ndemultiplex\n(\ndplxr\n,\n \ndna\nGGAACGNT\n)\n  \n# 3rd barcode with no errors\n\n\n(3,0)\n\n\n\njulia\n \ndemultiplex\n(\ndplxr\n,\n \ndna\nTGACCGNT\n)\n  \n# no matching barcode\n\n\n(0,-1)\n\n\n\n\n\n\nThe optional third argument controls the search strategy. \ndemultiplex\n uses an index to search the closest barcode within \nn_max_errors\n in the barcode set and returns it if any by default. If the third argument is \ntrue\n it falls back to a linear search after the index search and returns one of the closest barcodes at random. The next example shows the difference of these two strategies:\n\n\njulia\n \ndemultiplex\n(\ndplxr\n,\n \ndna\nTGACCGNT\n,\n \nfalse\n)\n  \n# linear search off (default)\n\n\n(0,-1)\n\n\n\njulia\n \ndemultiplex\n(\ndplxr\n,\n \ndna\nTGACCGNT\n,\n \ntrue\n)\n   \n# linear search on\n\n\n(3,2)", 
            "title": "Demultiplexing"
        }, 
        {
            "location": "/man/seq/demultiplexer/#sequence-demultiplexing", 
            "text": "Multiplex sequencing is a technology to sequence multiple samples at the same time on a high-throughput DNA sequencer. Samples are distinguished by the short prefix of a DNA sequence called DNA barcode. The  Bio.Seq  offers the  Demultiplexer  type and the  demultiplex  function to identify the DNA barcode of a longer DNA sequence allowing small errors.  In the following example, four kinds of DNA sequences of length 4 are used as DNA barcodes.  Demultiplexer  takes these barcodes as its first argument with a few options:  julia   barcodes   =   DNASequence [ ATGG ,   CAGA ,   GGAA ,   TACG ];  julia   dplxr   =   Demultiplexer ( barcodes ,   n_max_errors = 1 ,   distance =: hamming )  Bio.Seq.Demultiplexer{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:    distance: hamming    number of barcodes: 4    number of correctable errors: 1   n_max_errors  specifies the number of maximum correctable errors in a barcode. The type of correctable errors depends on the  distance  parameter. When  distance = :hamming  as shown above only substitutions are correctable. When  distance = :levenshtein  substitutions, deletions, and insertions are correctable. The user is responsible for keeping enough distances among barcodes;  Demultiplexer  will throw an exception if two barcodes are within  n_max_errors * 2 .  The  demultiplex  function takes a demultiplexer object and a DNA sequence, and returns a tuple of a barcode index and a distance between the original barcode sequence and the prefix sequence:  julia   demultiplex ( dplxr ,   dna ATGGCGNT )    # 1st barcode with no errors  (1,0)  julia   demultiplex ( dplxr ,   dna CAGGCGNT )    # 2nd barcode with one error  (2,1)  julia   demultiplex ( dplxr ,   dna GGAACGNT )    # 3rd barcode with no errors  (3,0)  julia   demultiplex ( dplxr ,   dna TGACCGNT )    # no matching barcode  (0,-1)   The optional third argument controls the search strategy.  demultiplex  uses an index to search the closest barcode within  n_max_errors  in the barcode set and returns it if any by default. If the third argument is  true  it falls back to a linear search after the index search and returns one of the closest barcodes at random. The next example shows the difference of these two strategies:  julia   demultiplex ( dplxr ,   dna TGACCGNT ,   false )    # linear search off (default)  (0,-1)  julia   demultiplex ( dplxr ,   dna TGACCGNT ,   true )     # linear search on  (3,2)", 
            "title": "Sequence demultiplexing"
        }, 
        {
            "location": "/man/alignments/", 
            "text": "Align: Sequence Alignments\n\n\nThe \nAlign\n module contains tools for computing and working with sequence alignments.\n\n\n\n\nRepresenting alignments\n\n\nThe \nAlignment\n type can represent a wide variety of global or local sequence alignments while facilitating efficient coordinate transformation.  Alignment are always relative to a possibly unspecified reference sequence and represent a series of \nedit operations\n performed on that reference to transform it to the query sequence.\n\n\nTo represent an alignment we use a series of \"anchors\" stored in the \nAlignmentAnchor\n type. Anchors are form of run-length encoding alignment operations, but rather than store an operation along with a length, we store the end-point of that operation in both reference and query coordinates.\n\n\nimmutable\n \nAlignmentAnchor\n\n    \nseqpos\n::\nInt\n\n    \nrefpos\n::\nInt\n\n    \nop\n::\nOperation\n\n\nend\n\n\n\n\n\n\nEvery alignment starts with a special \nOP_START\n operation which is used to give the position in the reference and query prior to the start of the alignment, or 0, if the alignment starts at position 1.\n\n\nFor example, consider the following alignment:\n\n\n              0   4        9  12 15     19\n              |   |        |  |  |      |\n    query:     TGGC----ATCATTTAACG---CAAG\nreference: AGGGTGGCATTTATCAG---ACGTTTCGAGAC\n              |   |   |    |     |  |   |\n              4   8   12   17    20 23  27\n\n\n\n\n\nUsing anchors we would represent this as the following series of anchors:\n\n\n[\n\n    \nAlignmentAnchor\n(\n \n0\n,\n  \n4\n,\n \nOP_START\n),\n\n    \nAlignmentAnchor\n(\n \n4\n,\n  \n8\n,\n \nOP_MATCH\n),\n\n    \nAlignmentAnchor\n(\n \n4\n,\n \n12\n,\n \nOP_DELETE\n),\n\n    \nAlignmentAnchor\n(\n \n9\n,\n \n17\n,\n \nOP_MATCH\n),\n\n    \nAlignmentAnchor\n(\n12\n,\n \n17\n,\n \nOP_INSERT\n),\n\n    \nAlignmentAnchor\n(\n15\n,\n \n20\n,\n \nOP_MATCH\n),\n\n    \nAlignmentAnchor\n(\n15\n,\n \n23\n,\n \nOP_DELETE\n),\n\n    \nAlignmentAnchor\n(\n19\n,\n \n27\n,\n \nOP_MATCH\n)\n\n\n]\n\n\n\n\n\n\nAn \nAlignment\n object can be created from a series of anchors:\n\n\njulia\n \nAlignment\n([\n\n           \nAlignmentAnchor\n(\n0\n,\n \n4\n,\n \nOP_START\n),\n\n           \nAlignmentAnchor\n(\n4\n,\n \n8\n,\n \nOP_MATCH\n),\n\n           \nAlignmentAnchor\n(\n4\n,\n \n12\n,\n \nOP_DELETE\n)\n\n       \n])\n\n\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n\n\n\u00b7\u00b7\u00b7\u00b7----\n\n\n\n\n\n\n\n\nOperations\n\n\nAlignment operations follow closely from those used in the \nSAM/BAM format\n and are stored in the \nOperation\n bitstype.\n\n\n\n\n\n\n\n\nOperation\n\n\nOperation Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOP_MATCH\n\n\nmatch\n\n\nnon-specific match\n\n\n\n\n\n\nOP_INSERT\n\n\ninsert\n\n\ninsertion into reference sequence\n\n\n\n\n\n\nOP_DELETE\n\n\ndelete\n\n\ndeletion from reference sequence\n\n\n\n\n\n\nOP_SKIP\n\n\ndelete\n\n\n(typically long) deletion from the reference, e.g. due to RNA splicing\n\n\n\n\n\n\nOP_SOFT_CLIP\n\n\ninsert\n\n\nsequence removed from the beginning or end of the query sequence but stored\n\n\n\n\n\n\nOP_HARD_CLIP\n\n\ninsert\n\n\nsequence removed from the beginning or end of the query sequence and not stored\n\n\n\n\n\n\nOP_PAD\n\n\nspecial\n\n\nnot currently supported, but present for SAM/BAM compatibility\n\n\n\n\n\n\nOP_SEQ_MATCH\n\n\nmatch\n\n\nmatch operation with matching sequence positions\n\n\n\n\n\n\nOP_SEQ_MISMATCH\n\n\nmatch\n\n\nmatch operation with mismatching sequence positions\n\n\n\n\n\n\nOP_BACK\n\n\nspecial\n\n\nnot currently supported, but present for SAM/BAM compatibility\n\n\n\n\n\n\nOP_START\n\n\nspecial\n\n\nindicate the start of an alignment within the reference and query sequence\n\n\n\n\n\n\n\n\n\n\nAligned sequence\n\n\nA sequence aligned to another sequence is represented by the \nAlignedSequence\n type, which is a pair of the aligned sequence and an \nAlignment\n object.\n\n\nThe following example creates an aligned sequence object from a sequence and an alignment:\n\n\njulia\n \nAlignedSequence\n(\n  \n# pass an Alignment object\n\n           \ndna\nACGTAT\n,\n\n           \nAlignment\n([\n\n               \nAlignmentAnchor\n(\n0\n,\n \n0\n,\n \nOP_START\n),\n\n               \nAlignmentAnchor\n(\n3\n,\n \n3\n,\n \nOP_MATCH\n),\n\n               \nAlignmentAnchor\n(\n6\n,\n \n3\n,\n \nOP_INSERT\n)\n\n           \n])\n\n       \n)\n\n\n\u00b7\u00b7\u00b7---\n\n\nACGTAT\n\n\n\njulia\n \nAlignedSequence\n(\n  \n# or pass a vector of anchors\n\n           \ndna\nACGTAT\n,\n\n           \n[\n\n               \nAlignmentAnchor\n(\n0\n,\n \n0\n,\n \nOP_START\n),\n\n               \nAlignmentAnchor\n(\n3\n,\n \n3\n,\n \nOP_MATCH\n),\n\n               \nAlignmentAnchor\n(\n6\n,\n \n3\n,\n \nOP_INSERT\n)\n\n           \n]\n\n       \n)\n\n\n\u00b7\u00b7\u00b7---\n\n\nACGTAT\n\n\n\n\n\n\nIf you already have an aligned sequence with gap symbols, it can be converted to an \nAlignedSequence\n object by passing a reference sequence with it:\n\n\njulia\n \nseq\n \n=\n \ndna\nACGT--AAT--\n\n\n11nt DNA Sequence:\n\n\nACGT--AAT--\n\n\n\njulia\n \nref\n \n=\n \ndna\nACGTTTAT-GG\n\n\n11nt DNA Sequence:\n\n\nACGTTTAT-GG\n\n\n\njulia\n \nAlignedSequence\n(\nseq\n,\n \nref\n)\n\n\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7-\u00b7\u00b7\n\n\nACGT--AAT--\n\n\n\n\n\n\n\n\nOperating on alignments\n\n\n#\n\n\nBase.first\n \n \nFunction\n.\n\n\nfirst(coll)\n\n\n\n\n\nGet the first element of an iterable collection. Returns the start point of a \nRange\n even if it is empty.\n\n\nsource\n\n\n#\n\n\nBase.last\n \n \nFunction\n.\n\n\nlast(coll)\n\n\n\n\n\nGet the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling \nendof\n to get the last index. Returns the end point of a \nRange\n even if it is empty.\n\n\nsource\n\n\n#\n\n\nBio.Align.seq2ref\n \n \nFunction\n.\n\n\nseq2ref(aln, i)\n\n\n\n\n\nMap a position from sequence to reference.\n\n\nsource\n\n\n#\n\n\nBio.Align.ref2seq\n \n \nFunction\n.\n\n\nref2seq(aln, i)\n\n\n\n\n\nMap a position from reference to sequence.\n\n\nsource\n\n\n#\n\n\nBio.Align.cigar\n \n \nFunction\n.\n\n\ncigar(aln::Alignment)\n\n\n\n\n\nMake a CIGAR string encoding of \naln\n.\n\n\nThis is not entirely lossless as it discards the alignments start positions.\n\n\nsource\n\n\ncigar(rec::BAMRecord)\n\n\n\n\n\nReturn a CIGAR string of the alignment \nrec\n. See also \ncigar_rle\n.\n\n\nsource\n\n\n\n\nPairwise alignment\n\n\nPairwise alignment is a sequence alignment between two sequences.  The \nBio.Align\n module implements several pairwise alignment methods that maximize alignment score or minimize alignment cost.\n\n\nA pair of optimization type and score (or cost) model determines the best alignments between two sequences. The next example uses a pair of \nGlobalAlignment\n and \nAffineGapScoreModel\n to obtain the best alignment:\n\n\njulia\n \nproblem\n \n=\n \nGlobalAlignment\n()\n\n\nBio.Align.GlobalAlignment()\n\n\n\njulia\n \nscoremodel\n \n=\n \nAffineGapScoreModel\n(\n\n                  \nmatch\n=\n5\n,\n\n                  \nmismatch\n=-\n4\n,\n\n                  \ngap_open\n=-\n4\n,\n\n                  \ngap_extend\n=-\n1\n\n              \n)\n\n\nBio.Align.AffineGapScoreModel{Int64}:\n\n\n       match = 5\n\n\n    mismatch = -4\n\n\n    gap_open = -4\n\n\n  gap_extend = -1\n\n\n\njulia\n \npairalign\n(\nproblem\n,\n \ndna\nCGGATTA\n,\n \ndna\nGGTTTAC\n,\n \nscoremodel\n)\n\n\nBio.Align.PairwiseAlignmentResult{Int64,Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:\n\n\n  score: 11\n\n\n  seq: 1 CGGATTA- 7\n\n\n          || |||\n\n\n  ref: 0 -GGTTTAC 7\n\n\n\n\n\n\npairalign\n takes an alignment type as its first argument, then two sequences to align, and score (or cost) model. Alignment type is one of the following four types:\n\n\n\n\nGlobalAlignment\n: global-to-global alignment\n\n\nSemiGlobalAlignment\n: local-to-global alignment\n\n\nLocalAlignment\n: local-to-local alignment\n\n\nOverlapAlignment\n: end-free alignment\n\n\n\n\nFor scoring model, \nAffineGapScoreModel\n is currently supported. It imposes an \naffine gap penalty\n for insertions and deletions: \ngap_open + k * gap_extend\n for a consecutive insertion/deletion of length \nk\n. The affine gap penalty is flexible enough to create a constant and linear scoring model. Setting \ngap_extend = 0\n or \ngap_open = 0\n, they are equivalent to the constant or linear gap penalty, respectively. The first argument of \nAffineGapScoreModel\n can be a substitution matrix like \nAffineGapScoreModel(BLOSUM62, gap_open=-10, gap_extend=-1)\n. For details on substitution matrices, see the \nSubstitution matrices\n section.\n\n\nAlignment type can also be a distance of two sequences:\n\n\n\n\nEditDistance\n\n\nLevenshteinDistance\n\n\nHammingDistance\n\n\n\n\nIn this alignment, \nCostModel\n is used instead of \nAffineGapScoreModel\n to define cost of substitution, insertion, and deletion:\n\n\njulia\n \ncostmodel\n \n=\n \nCostModel\n(\nmatch\n=\n0\n,\n \nmismatch\n=\n1\n,\n \ninsertion\n=\n1\n,\n \ndeletion\n=\n1\n);\n\n\n\njulia\n \npairalign\n(\nEditDistance\n(),\n \nabcd\n,\n \nadcde\n,\n \ncostmodel\n)\n\n\nBio.Align.PairwiseAlignmentResult{Int64,String,String}:\n\n\n  distance: 2\n\n\n  seq: 1 abcd- 4\n\n\n         | ||\n\n\n  ref: 1 adcde 5\n\n\n\n\n\n\n\n\nOperations on pairwise alignment\n\n\npairalign\n returns a \nPairwiseAlignmentResult\n object and some accessors are provided for it.\n\n\n#\n\n\nBio.Align.score\n \n \nFunction\n.\n\n\nscore(alignment_result)\n\n\n\n\n\nReturn score of alignment.\n\n\nsource\n\n\n#\n\n\nBio.distance\n \n \nFunction\n.\n\n\ndistance(alignment_result)\n\n\n\n\n\nRetrun distance of alignment.\n\n\nsource\n\n\nGet the minimum distance between two \nStructuralElementOrList\ns. Additional arguments are atom selector functions - only atoms that return \ntrue\n from the functions are retained.\n\n\nsource\n\n\n#\n\n\nBio.Align.hasalignment\n \n \nFunction\n.\n\n\nhasalignment(alignment_result)\n\n\n\n\n\nCheck if alignment is stored or not.\n\n\nsource\n\n\n#\n\n\nBio.Align.alignment\n \n \nFunction\n.\n\n\nalignment(alignment_result)\n\n\n\n\n\nReturn alignment if any.\n\n\nSee also: \nhasalignment\n\n\nsource\n\n\nalignment(rec::BAMRecord)\n\n\n\n\n\nMake an alignment object from \nrec\n.\n\n\nsource\n\n\nPairwise alignment also implements some useful operations on it.\n\n\n#\n\n\nBio.Align.count_matches\n \n \nFunction\n.\n\n\ncount_matches(aln)\n\n\n\n\n\nCount the number of matching positions.\n\n\nsource\n\n\n#\n\n\nBio.Align.count_mismatches\n \n \nFunction\n.\n\n\ncount_mismatches(aln)\n\n\n\n\n\nCount the number of mismatching positions.\n\n\nsource\n\n\n#\n\n\nBio.Align.count_insertions\n \n \nFunction\n.\n\n\ncount_insertions(aln)\n\n\n\n\n\nCount the number of inserting positions.\n\n\nsource\n\n\n#\n\n\nBio.Align.count_deletions\n \n \nFunction\n.\n\n\ncount_deletions(aln)\n\n\n\n\n\nCount the number of deleting positions.\n\n\nsource\n\n\n#\n\n\nBio.Align.count_aligned\n \n \nFunction\n.\n\n\ncount_aligned(aln)\n\n\n\n\n\nCount the number of aligned positions.\n\n\nsource\n\n\nThe example below shows a use case of these operations:\n\n\njulia\n \ns1\n \n=\n \ndna\nCCTAGGAGGG\n;\n\n\n\njulia\n \ns2\n \n=\n \ndna\nACCTGGTATGATAGCG\n;\n\n\n\njulia\n \nscoremodel\n \n=\n \nAffineGapScoreModel\n(\nEDNAFULL\n,\n \ngap_open\n=-\n5\n,\n \ngap_extend\n=-\n1\n);\n\n\n\njulia\n \nres\n \n=\n \npairalign\n(\nGlobalAlignment\n(),\n \ns1\n,\n \ns2\n,\n \nscoremodel\n)\n  \n# run pairwise alignment\n\n\nBio.Align.PairwiseAlignmentResult{Int64,Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:\n\n\n  score: 13\n\n\n  seq:  0 -CCTAGG------AGGG 10\n\n\n           ||| ||      || |\n\n\n  ref:  1 ACCT-GGTATGATAGCG 16\n\n\n\n\njulia\n \nscore\n(\nres\n)\n  \n# get the achieved score of this alignment\n\n\n13\n\n\n\njulia\n \naln\n \n=\n \nalignment\n(\nres\n)\n\n\nPairwiseAlignment{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:\n\n\n  seq:  0 -CCTAGG------AGGG 10\n\n\n           ||| ||      || |\n\n\n  ref:  1 ACCT-GGTATGATAGCG 16\n\n\n\n\njulia\n \ncount_matches\n(\naln\n)\n\n\n8\n\n\n\njulia\n \ncount_mismatches\n(\naln\n)\n\n\n1\n\n\n\njulia\n \ncount_insertions\n(\naln\n)\n\n\n1\n\n\n\njulia\n \ncount_deletions\n(\naln\n)\n\n\n7\n\n\n\njulia\n \ncount_aligned\n(\naln\n)\n\n\n17\n\n\n\njulia\n \ncollect\n(\naln\n)\n  \n# pairwise alignment is iterable\n\n\n17-element Array{Tuple{Bio.Seq.DNA,Bio.Seq.DNA},1}:\n\n\n (-,A)\n\n\n (C,C)\n\n\n (C,C)\n\n\n (T,T)\n\n\n (A,-)\n\n\n (G,G)\n\n\n (G,G)\n\n\n (-,T)\n\n\n (-,A)\n\n\n (-,T)\n\n\n (-,G)\n\n\n (-,A)\n\n\n (-,T)\n\n\n (A,A)\n\n\n (G,G)\n\n\n (G,C)\n\n\n (G,G)\n\n\n\njulia\n \nDNASequence\n([\nx\n \nfor\n \n(\nx\n,\n \n_\n)\n \nin\n \naln\n])\n  \n# create aligned `s1` with gaps\n\n\n17nt DNA Sequence:\n\n\n-CCTAGG------AGGG\n\n\n\njulia\n \nDNASequence\n([\ny\n \nfor\n \n(\n_\n,\n \ny\n)\n \nin\n \naln\n])\n  \n# create aligned `s2` with gaps\n\n\n17nt DNA Sequence:\n\n\nACCT-GGTATGATAGCG\n\n\n\n\n\n\n\n\nSubstitution matrices\n\n\nA substitution matrix is a function of substitution score (or cost) from one symbol to other. Substitution value of \nsubmat\n from \nx\n to \ny\n can be obtained by writing \nsubmat[x,y]\n. In \nBio.Align\n, \nSubstitutionMatrix\n and \nDichotomousSubstitutionMatrix\n are two distinct types representing substitution matrices.\n\n\nSubstitutionMatrix\n is a general substitution matrix type that is a thin wrapper of regular matrix.\n\n\nSome common substitution matrices are provided. For DNA and RNA, \nEDNAFULL\n is defined:\n\n\njulia\n \nEDNAFULL\n\n\nBio.Align.SubstitutionMatrix{Bio.Seq.DNA,Int64}:\n\n\n     A  C  G  T  M  R  W  S  Y  K  V  H  D  B  N\n\n\n  A  5 -4 -4 -4  1  1  1 -4 -4 -4 -1 -1 -1 -4 -2\n\n\n  C -4  5 -4 -4  1 -4 -4  1  1 -4 -1 -1 -4 -1 -2\n\n\n  G -4 -4  5 -4 -4  1 -4  1 -4  1 -1 -4 -1 -1 -2\n\n\n  T -4 -4 -4  5 -4 -4  1 -4  1  1 -4 -1 -1 -1 -2\n\n\n  M  1  1 -4 -4 -1 -2 -2 -2 -2 -4 -1 -1 -3 -3 -1\n\n\n  R  1 -4  1 -4 -2 -1 -2 -2 -4 -2 -1 -3 -1 -3 -1\n\n\n  W  1 -4 -4  1 -2 -2 -1 -4 -2 -2 -3 -1 -1 -3 -1\n\n\n  S -4  1  1 -4 -2 -2 -4 -1 -2 -2 -1 -3 -3 -1 -1\n\n\n  Y -4  1 -4  1 -2 -4 -2 -2 -1 -2 -3 -1 -3 -1 -1\n\n\n  K -4 -4  1  1 -4 -2 -2 -2 -2 -1 -3 -3 -1 -1 -1\n\n\n  V -1 -1 -1 -4 -1 -1 -3 -1 -3 -3 -1 -2 -2 -2 -1\n\n\n  H -1 -1 -4 -1 -1 -3 -1 -3 -1 -3 -2 -1 -2 -2 -1\n\n\n  D -1 -4 -1 -1 -3 -1 -1 -3 -3 -1 -2 -2 -1 -2 -1\n\n\n  B -4 -1 -1 -1 -3 -3 -3 -1 -1 -1 -2 -2 -2 -1 -1\n\n\n  N -2 -2 -2 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1\n\n\n(underlined values are default ones)\n\n\n\n\n\n\nFor amino acids, PAM (Point Accepted Mutation) and BLOSUM (BLOcks SUbstitution Matrix) matrices are defined:\n\n\njulia\n \nBLOSUM62\n\n\nBio.Align.SubstitutionMatrix{Bio.Seq.AminoAcid,Int64}:\n\n\n     A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V  O  U  B  J  Z  X  *\n\n\n  A  4 -1 -2 -2  0 -1 -1  0 -2 -1 -1 -1 -1 -2 -1  1  0 -3 -2  0  0\u0332  0\u0332 -2  0\u0332 -1  0 -4\n\n\n  R -1  5  0 -2 -3  1  0 -2  0 -3 -2  2 -1 -3 -2 -1 -1 -3 -2 -3  0\u0332  0\u0332 -1  0\u0332  0 -1 -4\n\n\n  N -2  0  6  1 -3  0  0  0  1 -3 -3  0 -2 -3 -2  1  0 -4 -2 -3  0\u0332  0\u0332  3  0\u0332  0 -1 -4\n\n\n  D -2 -2  1  6 -3  0  2 -1 -1 -3 -4 -1 -3 -3 -1  0 -1 -4 -3 -3  0\u0332  0\u0332  4  0\u0332  1 -1 -4\n\n\n  C  0 -3 -3 -3  9 -3 -4 -3 -3 -1 -1 -3 -1 -2 -3 -1 -1 -2 -2 -1  0\u0332  0\u0332 -3  0\u0332 -3 -2 -4\n\n\n  Q -1  1  0  0 -3  5  2 -2  0 -3 -2  1  0 -3 -1  0 -1 -2 -1 -2  0\u0332  0\u0332  0  0\u0332  3 -1 -4\n\n\n  E -1  0  0  2 -4  2  5 -2  0 -3 -3  1 -2 -3 -1  0 -1 -3 -2 -2  0\u0332  0\u0332  1  0\u0332  4 -1 -4\n\n\n  G  0 -2  0 -1 -3 -2 -2  6 -2 -4 -4 -2 -3 -3 -2  0 -2 -2 -3 -3  0\u0332  0\u0332 -1  0\u0332 -2 -1 -4\n\n\n  H -2  0  1 -1 -3  0  0 -2  8 -3 -3 -1 -2 -1 -2 -1 -2 -2  2 -3  0\u0332  0\u0332  0  0\u0332  0 -1 -4\n\n\n  I -1 -3 -3 -3 -1 -3 -3 -4 -3  4  2 -3  1  0 -3 -2 -1 -3 -1  3  0\u0332  0\u0332 -3  0\u0332 -3 -1 -4\n\n\n  L -1 -2 -3 -4 -1 -2 -3 -4 -3  2  4 -2  2  0 -3 -2 -1 -2 -1  1  0\u0332  0\u0332 -4  0\u0332 -3 -1 -4\n\n\n  K -1  2  0 -1 -3  1  1 -2 -1 -3 -2  5 -1 -3 -1  0 -1 -3 -2 -2  0\u0332  0\u0332  0  0\u0332  1 -1 -4\n\n\n  M -1 -1 -2 -3 -1  0 -2 -3 -2  1  2 -1  5  0 -2 -1 -1 -1 -1  1  0\u0332  0\u0332 -3  0\u0332 -1 -1 -4\n\n\n  F -2 -3 -3 -3 -2 -3 -3 -3 -1  0  0 -3  0  6 -4 -2 -2  1  3 -1  0\u0332  0\u0332 -3  0\u0332 -3 -1 -4\n\n\n  P -1 -2 -2 -1 -3 -1 -1 -2 -2 -3 -3 -1 -2 -4  7 -1 -1 -4 -3 -2  0\u0332  0\u0332 -2  0\u0332 -1 -2 -4\n\n\n  S  1 -1  1  0 -1  0  0  0 -1 -2 -2  0 -1 -2 -1  4  1 -3 -2 -2  0\u0332  0\u0332  0  0\u0332  0  0 -4\n\n\n  T  0 -1  0 -1 -1 -1 -1 -2 -2 -1 -1 -1 -1 -2 -1  1  5 -2 -2  0  0\u0332  0\u0332 -1  0\u0332 -1  0 -4\n\n\n  W -3 -3 -4 -4 -2 -2 -3 -2 -2 -3 -2 -3 -1  1 -4 -3 -2 11  2 -3  0\u0332  0\u0332 -4  0\u0332 -3 -2 -4\n\n\n  Y -2 -2 -2 -3 -2 -1 -2 -3  2 -1 -1 -2 -1  3 -3 -2 -2  2  7 -1  0\u0332  0\u0332 -3  0\u0332 -2 -1 -4\n\n\n  V  0 -3 -3 -3 -1 -2 -2 -3 -3  3  1 -2  1 -1 -2 -2  0 -3 -1  4  0\u0332  0\u0332 -3  0\u0332 -2 -1 -4\n\n\n  O  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332\n\n\n  U  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332\n\n\n  B -2 -1  3  4 -3  0  1 -1  0 -3 -4  0 -3 -3 -2  0 -1 -4 -3 -3  0\u0332  0\u0332  4  0\u0332  1 -1 -4\n\n\n  J  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332\n\n\n  Z -1  0  0  1 -3  3  4 -2  0 -3 -3  1 -1 -3 -1  0 -1 -3 -2 -2  0\u0332  0\u0332  1  0\u0332  4 -1 -4\n\n\n  X  0 -1 -1 -1 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -2  0  0 -2 -1 -1  0\u0332  0\u0332 -1  0\u0332 -1 -1 -4\n\n\n  * -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4  0\u0332  0\u0332 -4  0\u0332 -4 -4  1\n\n\n(underlined values are default ones)\n\n\n\n\n\n\n\n\n\n\n\n\nMatrix\n\n\nConstants\n\n\n\n\n\n\n\n\n\n\nPAM\n\n\nPAM30\n, \nPAM70\n, \nPAM250\n\n\n\n\n\n\nBLOSUM\n\n\nBLOSUM45\n, \nBLOSUM50\n, \nBLOSUM62\n, \nBLOSUM80\n, \nBLOSUM90\n\n\n\n\n\n\n\n\nThese matrices are downloaded from: \nftp://ftp.ncbi.nih.gov/blast/matrices/\n.\n\n\nSubstitutionMatrix\n can be modified like a regular matrix:\n\n\njulia\n \nmysubmat\n \n=\n \ncopy\n(\nBLOSUM62\n);\n  \n# create a copy\n\n\n\njulia\n \nmysubmat\n[\nAA_A\n,\nAA_R\n]\n  \n# score of AA_A =\n AA_R substitution is -1\n\n\n-1\n\n\n\njulia\n \nmysubmat\n[\nAA_A\n,\nAA_R\n]\n \n=\n \n-\n3\n  \n# set the score to -3\n\n\n-3\n\n\n\njulia\n \nmysubmat\n[\nAA_A\n,\nAA_R\n]\n  \n# the score is modified\n\n\n-3\n\n\n\n\n\n\nMake sure to create a copy of the original matrix when you create a matrix from a predefined matrix. In the above case, \nBLOSUM62\n is shared in the whole program and modification on it will affect any result that uses \nBLOSUM62\n.\n\n\nDichotomousSubstitutionMatrix\n is a specialized matrix for matching or mismatching substitution.  This is a preferable choice when performance is more important than flexibility because looking up score is faster than \nSubstitutionMatrix\n.\n\n\njulia\n \nsubmat\n \n=\n \nDichotomousSubstitutionMatrix\n(\n1\n,\n \n-\n1\n)\n\n\nBio.Align.DichotomousSubstitutionMatrix{Int64}:\n\n\n     match =  1\n\n\n  mismatch = -1\n\n\n\njulia\n \nsubmat\n[\nA\n,\nA\n]\n  \n# match\n\n\n1\n\n\n\njulia\n \nsubmat\n[\nA\n,\nB\n]\n  \n# mismatch\n\n\n-1\n\n\n\n\n\n\n\n\nAlignment file formats for high-throughput sequencing\n\n\nHigh-throughput sequencing (HTS) technologies generate a large amount of data in the form of a large number of nucleotide sequencing reads. One of the most common tasks in bioinformatics is to align these reads against known reference genomes, chromosomes, or contigs. The \nBio.Align\n module provides several data formats commonly used for this kind of task.\n\n\n\n\nSAM and BAM file formats\n\n\nSAM and BAM are the most popular file formats and have the same reading and writing interface as all other formats in Bio.jl (see \nReading and writing data\n section). A typical code iterating over all records in a file looks like below:\n\n\n# import the SAM and BAM module\n\n\nusing\n \nBio\n.\nAlign\n\n\n\n# open a BAM file\n\n\nreader\n \n=\n \nopen\n(\nBAM\n.\nReader\n,\n \ndata.bam\n)\n\n\n\n# iterate over BAM records\n\n\nfor\n \nrecord\n \nin\n \nreader\n\n    \n# `record` is a BAM.Record object\n\n    \nif\n \nBAM\n.\nismapped\n(\nrecord\n)\n\n        \n# print mapped position\n\n        \nprintln\n(\nBAM\n.\nrefname\n(\nrecord\n),\n \n:\n,\n \nBAM\n.\nposition\n(\nrecord\n))\n\n    \nend\n\n\nend\n\n\n\n# close the BAM file\n\n\nclose\n(\nreader\n)\n\n\n\n\n\n\nAccessor functions are defined in \nSAM\n and \nBAM\n modules.  Lists of these functions to \nSAM.Record\n and \nBAM.Record\n are described in \nSAM\n and \nBAM\n sections, respectively.\n\n\nSAM.Reader\n and \nBAM.Reader\n implement the \nheader\n function, which returns a \nSAM.Header\n object. This is conceptually a sequence of \nSAM.MetaInfo\n objects corresponding to header lines that start with '@' markers. To select \nSAM.MetaInfo\n records with a specific tag, you can use the \nfind\n function:\n\n\njulia\n \nreader\n \n=\n \nopen\n(\nSAM\n.\nReader\n,\n \ndata.sam\n);\n\n\n\njulia\n \nfind\n(\nheader\n(\nreader\n),\n \nSQ\n)\n\n\n7-element Array{Bio.Align.SAM.MetaInfo,1}:\n\n\n Bio.Align.SAM.MetaInfo:\n\n\n    tag: SQ\n\n\n  value: SN=Chr1 LN=30427671\n\n\n Bio.Align.SAM.MetaInfo:\n\n\n    tag: SQ\n\n\n  value: SN=Chr2 LN=19698289\n\n\n Bio.Align.SAM.MetaInfo:\n\n\n    tag: SQ\n\n\n  value: SN=Chr3 LN=23459830\n\n\n Bio.Align.SAM.MetaInfo:\n\n\n    tag: SQ\n\n\n  value: SN=Chr4 LN=18585056\n\n\n Bio.Align.SAM.MetaInfo:\n\n\n    tag: SQ\n\n\n  value: SN=Chr5 LN=26975502\n\n\n Bio.Align.SAM.MetaInfo:\n\n\n    tag: SQ\n\n\n  value: SN=chloroplast LN=154478\n\n\n Bio.Align.SAM.MetaInfo:\n\n\n    tag: SQ\n\n\n  value: SN=mitochondria LN=366924\n\n\n\n\n\n\nA \nSAM.MetaInfo\n object can be created as follows:\n\n\njulia\n \nSAM\n.\nMetaInfo\n(\nSQ\n,\n \n[\nSN\n \n=\n \nchr1\n,\n \nLN\n \n=\n \n1234\n])\n\n\nBio.Align.SAM.MetaInfo:\n\n\n    tag: SQ\n\n\n  value: SN=chr1 LN=1234\n\n\n\njulia\n \nSAM\n.\nMetaInfo\n(\nCO\n,\n \ncomment\n)\n\n\nBio.Align.SAM.MetaInfo:\n\n\n    tag: CO\n\n\n  value: comment\n\n\n\n\n\n\n\n\nPerformance tips\n\n\nThe size of a BAM file is often extremely large. The iterator interface mentioned above allocates an object for each record and that may be a bottleneck of reading data from a BAM file. In-place reading reuses a preallocated object for every record and less memory allocation happens in reading:\n\n\nreader\n \n=\n \nopen\n(\nBAM\n.\nReader\n,\n \ndata.bam\n)\n\n\nrecord\n \n=\n \nBAM\n.\nRecord\n()\n\n\nwhile\n \n!\neof\n(\nreader\n)\n\n    \nread!\n(\nreader\n,\n \nrecord\n)\n\n    \n# do something\n\n\nend\n\n\n\n\n\n\nAccessing optional fields will results in type instability in Julia, which has a significant negative impact on performance. If the user knows the type of a value in advance, specifying it as a type annotation will alleviate the problem:\n\n\nfor\n \nrecord\n \nin\n \nopen\n(\nBAM\n.\nReader\n,\n \ndata.bam\n)\n\n    \nnm\n \n=\n \nrecord\n[\nNM\n]\n::\nUInt8\n\n    \n# do something\n\n\nend", 
            "title": "Alignments"
        }, 
        {
            "location": "/man/alignments/#align-sequence-alignments", 
            "text": "The  Align  module contains tools for computing and working with sequence alignments.", 
            "title": "Align: Sequence Alignments"
        }, 
        {
            "location": "/man/alignments/#representing-alignments", 
            "text": "The  Alignment  type can represent a wide variety of global or local sequence alignments while facilitating efficient coordinate transformation.  Alignment are always relative to a possibly unspecified reference sequence and represent a series of  edit operations  performed on that reference to transform it to the query sequence.  To represent an alignment we use a series of \"anchors\" stored in the  AlignmentAnchor  type. Anchors are form of run-length encoding alignment operations, but rather than store an operation along with a length, we store the end-point of that operation in both reference and query coordinates.  immutable   AlignmentAnchor \n     seqpos :: Int \n     refpos :: Int \n     op :: Operation  end   Every alignment starts with a special  OP_START  operation which is used to give the position in the reference and query prior to the start of the alignment, or 0, if the alignment starts at position 1.  For example, consider the following alignment:                0   4        9  12 15     19\n              |   |        |  |  |      |\n    query:     TGGC----ATCATTTAACG---CAAG\nreference: AGGGTGGCATTTATCAG---ACGTTTCGAGAC\n              |   |   |    |     |  |   |\n              4   8   12   17    20 23  27  Using anchors we would represent this as the following series of anchors:  [ \n     AlignmentAnchor (   0 ,    4 ,   OP_START ), \n     AlignmentAnchor (   4 ,    8 ,   OP_MATCH ), \n     AlignmentAnchor (   4 ,   12 ,   OP_DELETE ), \n     AlignmentAnchor (   9 ,   17 ,   OP_MATCH ), \n     AlignmentAnchor ( 12 ,   17 ,   OP_INSERT ), \n     AlignmentAnchor ( 15 ,   20 ,   OP_MATCH ), \n     AlignmentAnchor ( 15 ,   23 ,   OP_DELETE ), \n     AlignmentAnchor ( 19 ,   27 ,   OP_MATCH )  ]   An  Alignment  object can be created from a series of anchors:  julia   Alignment ([ \n            AlignmentAnchor ( 0 ,   4 ,   OP_START ), \n            AlignmentAnchor ( 4 ,   8 ,   OP_MATCH ), \n            AlignmentAnchor ( 4 ,   12 ,   OP_DELETE ) \n        ])  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  \u00b7\u00b7\u00b7\u00b7----", 
            "title": "Representing alignments"
        }, 
        {
            "location": "/man/alignments/#operations", 
            "text": "Alignment operations follow closely from those used in the  SAM/BAM format  and are stored in the  Operation  bitstype.     Operation  Operation Type  Description      OP_MATCH  match  non-specific match    OP_INSERT  insert  insertion into reference sequence    OP_DELETE  delete  deletion from reference sequence    OP_SKIP  delete  (typically long) deletion from the reference, e.g. due to RNA splicing    OP_SOFT_CLIP  insert  sequence removed from the beginning or end of the query sequence but stored    OP_HARD_CLIP  insert  sequence removed from the beginning or end of the query sequence and not stored    OP_PAD  special  not currently supported, but present for SAM/BAM compatibility    OP_SEQ_MATCH  match  match operation with matching sequence positions    OP_SEQ_MISMATCH  match  match operation with mismatching sequence positions    OP_BACK  special  not currently supported, but present for SAM/BAM compatibility    OP_START  special  indicate the start of an alignment within the reference and query sequence", 
            "title": "Operations"
        }, 
        {
            "location": "/man/alignments/#aligned-sequence", 
            "text": "A sequence aligned to another sequence is represented by the  AlignedSequence  type, which is a pair of the aligned sequence and an  Alignment  object.  The following example creates an aligned sequence object from a sequence and an alignment:  julia   AlignedSequence (    # pass an Alignment object \n            dna ACGTAT , \n            Alignment ([ \n                AlignmentAnchor ( 0 ,   0 ,   OP_START ), \n                AlignmentAnchor ( 3 ,   3 ,   OP_MATCH ), \n                AlignmentAnchor ( 6 ,   3 ,   OP_INSERT ) \n            ]) \n        )  \u00b7\u00b7\u00b7---  ACGTAT  julia   AlignedSequence (    # or pass a vector of anchors \n            dna ACGTAT , \n            [ \n                AlignmentAnchor ( 0 ,   0 ,   OP_START ), \n                AlignmentAnchor ( 3 ,   3 ,   OP_MATCH ), \n                AlignmentAnchor ( 6 ,   3 ,   OP_INSERT ) \n            ] \n        )  \u00b7\u00b7\u00b7---  ACGTAT   If you already have an aligned sequence with gap symbols, it can be converted to an  AlignedSequence  object by passing a reference sequence with it:  julia   seq   =   dna ACGT--AAT--  11nt DNA Sequence:  ACGT--AAT--  julia   ref   =   dna ACGTTTAT-GG  11nt DNA Sequence:  ACGTTTAT-GG  julia   AlignedSequence ( seq ,   ref )  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7-\u00b7\u00b7  ACGT--AAT--", 
            "title": "Aligned sequence"
        }, 
        {
            "location": "/man/alignments/#operating-on-alignments", 
            "text": "#  Base.first     Function .  first(coll)  Get the first element of an iterable collection. Returns the start point of a  Range  even if it is empty.  source  #  Base.last     Function .  last(coll)  Get the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling  endof  to get the last index. Returns the end point of a  Range  even if it is empty.  source  #  Bio.Align.seq2ref     Function .  seq2ref(aln, i)  Map a position from sequence to reference.  source  #  Bio.Align.ref2seq     Function .  ref2seq(aln, i)  Map a position from reference to sequence.  source  #  Bio.Align.cigar     Function .  cigar(aln::Alignment)  Make a CIGAR string encoding of  aln .  This is not entirely lossless as it discards the alignments start positions.  source  cigar(rec::BAMRecord)  Return a CIGAR string of the alignment  rec . See also  cigar_rle .  source", 
            "title": "Operating on alignments"
        }, 
        {
            "location": "/man/alignments/#pairwise-alignment", 
            "text": "Pairwise alignment is a sequence alignment between two sequences.  The  Bio.Align  module implements several pairwise alignment methods that maximize alignment score or minimize alignment cost.  A pair of optimization type and score (or cost) model determines the best alignments between two sequences. The next example uses a pair of  GlobalAlignment  and  AffineGapScoreModel  to obtain the best alignment:  julia   problem   =   GlobalAlignment ()  Bio.Align.GlobalAlignment()  julia   scoremodel   =   AffineGapScoreModel ( \n                   match = 5 , \n                   mismatch =- 4 , \n                   gap_open =- 4 , \n                   gap_extend =- 1 \n               )  Bio.Align.AffineGapScoreModel{Int64}:         match = 5      mismatch = -4      gap_open = -4    gap_extend = -1  julia   pairalign ( problem ,   dna CGGATTA ,   dna GGTTTAC ,   scoremodel )  Bio.Align.PairwiseAlignmentResult{Int64,Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:    score: 11    seq: 1 CGGATTA- 7            || |||    ref: 0 -GGTTTAC 7   pairalign  takes an alignment type as its first argument, then two sequences to align, and score (or cost) model. Alignment type is one of the following four types:   GlobalAlignment : global-to-global alignment  SemiGlobalAlignment : local-to-global alignment  LocalAlignment : local-to-local alignment  OverlapAlignment : end-free alignment   For scoring model,  AffineGapScoreModel  is currently supported. It imposes an  affine gap penalty  for insertions and deletions:  gap_open + k * gap_extend  for a consecutive insertion/deletion of length  k . The affine gap penalty is flexible enough to create a constant and linear scoring model. Setting  gap_extend = 0  or  gap_open = 0 , they are equivalent to the constant or linear gap penalty, respectively. The first argument of  AffineGapScoreModel  can be a substitution matrix like  AffineGapScoreModel(BLOSUM62, gap_open=-10, gap_extend=-1) . For details on substitution matrices, see the  Substitution matrices  section.  Alignment type can also be a distance of two sequences:   EditDistance  LevenshteinDistance  HammingDistance   In this alignment,  CostModel  is used instead of  AffineGapScoreModel  to define cost of substitution, insertion, and deletion:  julia   costmodel   =   CostModel ( match = 0 ,   mismatch = 1 ,   insertion = 1 ,   deletion = 1 );  julia   pairalign ( EditDistance (),   abcd ,   adcde ,   costmodel )  Bio.Align.PairwiseAlignmentResult{Int64,String,String}:    distance: 2    seq: 1 abcd- 4           | ||    ref: 1 adcde 5", 
            "title": "Pairwise alignment"
        }, 
        {
            "location": "/man/alignments/#operations-on-pairwise-alignment", 
            "text": "pairalign  returns a  PairwiseAlignmentResult  object and some accessors are provided for it.  #  Bio.Align.score     Function .  score(alignment_result)  Return score of alignment.  source  #  Bio.distance     Function .  distance(alignment_result)  Retrun distance of alignment.  source  Get the minimum distance between two  StructuralElementOrList s. Additional arguments are atom selector functions - only atoms that return  true  from the functions are retained.  source  #  Bio.Align.hasalignment     Function .  hasalignment(alignment_result)  Check if alignment is stored or not.  source  #  Bio.Align.alignment     Function .  alignment(alignment_result)  Return alignment if any.  See also:  hasalignment  source  alignment(rec::BAMRecord)  Make an alignment object from  rec .  source  Pairwise alignment also implements some useful operations on it.  #  Bio.Align.count_matches     Function .  count_matches(aln)  Count the number of matching positions.  source  #  Bio.Align.count_mismatches     Function .  count_mismatches(aln)  Count the number of mismatching positions.  source  #  Bio.Align.count_insertions     Function .  count_insertions(aln)  Count the number of inserting positions.  source  #  Bio.Align.count_deletions     Function .  count_deletions(aln)  Count the number of deleting positions.  source  #  Bio.Align.count_aligned     Function .  count_aligned(aln)  Count the number of aligned positions.  source  The example below shows a use case of these operations:  julia   s1   =   dna CCTAGGAGGG ;  julia   s2   =   dna ACCTGGTATGATAGCG ;  julia   scoremodel   =   AffineGapScoreModel ( EDNAFULL ,   gap_open =- 5 ,   gap_extend =- 1 );  julia   res   =   pairalign ( GlobalAlignment (),   s1 ,   s2 ,   scoremodel )    # run pairwise alignment  Bio.Align.PairwiseAlignmentResult{Int64,Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:    score: 13    seq:  0 -CCTAGG------AGGG 10             ||| ||      || |    ref:  1 ACCT-GGTATGATAGCG 16  julia   score ( res )    # get the achieved score of this alignment  13  julia   aln   =   alignment ( res )  PairwiseAlignment{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:    seq:  0 -CCTAGG------AGGG 10             ||| ||      || |    ref:  1 ACCT-GGTATGATAGCG 16  julia   count_matches ( aln )  8  julia   count_mismatches ( aln )  1  julia   count_insertions ( aln )  1  julia   count_deletions ( aln )  7  julia   count_aligned ( aln )  17  julia   collect ( aln )    # pairwise alignment is iterable  17-element Array{Tuple{Bio.Seq.DNA,Bio.Seq.DNA},1}:   (-,A)   (C,C)   (C,C)   (T,T)   (A,-)   (G,G)   (G,G)   (-,T)   (-,A)   (-,T)   (-,G)   (-,A)   (-,T)   (A,A)   (G,G)   (G,C)   (G,G)  julia   DNASequence ([ x   for   ( x ,   _ )   in   aln ])    # create aligned `s1` with gaps  17nt DNA Sequence:  -CCTAGG------AGGG  julia   DNASequence ([ y   for   ( _ ,   y )   in   aln ])    # create aligned `s2` with gaps  17nt DNA Sequence:  ACCT-GGTATGATAGCG", 
            "title": "Operations on pairwise alignment"
        }, 
        {
            "location": "/man/alignments/#substitution-matrices", 
            "text": "A substitution matrix is a function of substitution score (or cost) from one symbol to other. Substitution value of  submat  from  x  to  y  can be obtained by writing  submat[x,y] . In  Bio.Align ,  SubstitutionMatrix  and  DichotomousSubstitutionMatrix  are two distinct types representing substitution matrices.  SubstitutionMatrix  is a general substitution matrix type that is a thin wrapper of regular matrix.  Some common substitution matrices are provided. For DNA and RNA,  EDNAFULL  is defined:  julia   EDNAFULL  Bio.Align.SubstitutionMatrix{Bio.Seq.DNA,Int64}:       A  C  G  T  M  R  W  S  Y  K  V  H  D  B  N    A  5 -4 -4 -4  1  1  1 -4 -4 -4 -1 -1 -1 -4 -2    C -4  5 -4 -4  1 -4 -4  1  1 -4 -1 -1 -4 -1 -2    G -4 -4  5 -4 -4  1 -4  1 -4  1 -1 -4 -1 -1 -2    T -4 -4 -4  5 -4 -4  1 -4  1  1 -4 -1 -1 -1 -2    M  1  1 -4 -4 -1 -2 -2 -2 -2 -4 -1 -1 -3 -3 -1    R  1 -4  1 -4 -2 -1 -2 -2 -4 -2 -1 -3 -1 -3 -1    W  1 -4 -4  1 -2 -2 -1 -4 -2 -2 -3 -1 -1 -3 -1    S -4  1  1 -4 -2 -2 -4 -1 -2 -2 -1 -3 -3 -1 -1    Y -4  1 -4  1 -2 -4 -2 -2 -1 -2 -3 -1 -3 -1 -1    K -4 -4  1  1 -4 -2 -2 -2 -2 -1 -3 -3 -1 -1 -1    V -1 -1 -1 -4 -1 -1 -3 -1 -3 -3 -1 -2 -2 -2 -1    H -1 -1 -4 -1 -1 -3 -1 -3 -1 -3 -2 -1 -2 -2 -1    D -1 -4 -1 -1 -3 -1 -1 -3 -3 -1 -2 -2 -1 -2 -1    B -4 -1 -1 -1 -3 -3 -3 -1 -1 -1 -2 -2 -2 -1 -1    N -2 -2 -2 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1  (underlined values are default ones)   For amino acids, PAM (Point Accepted Mutation) and BLOSUM (BLOcks SUbstitution Matrix) matrices are defined:  julia   BLOSUM62  Bio.Align.SubstitutionMatrix{Bio.Seq.AminoAcid,Int64}:       A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V  O  U  B  J  Z  X  *    A  4 -1 -2 -2  0 -1 -1  0 -2 -1 -1 -1 -1 -2 -1  1  0 -3 -2  0  0\u0332  0\u0332 -2  0\u0332 -1  0 -4    R -1  5  0 -2 -3  1  0 -2  0 -3 -2  2 -1 -3 -2 -1 -1 -3 -2 -3  0\u0332  0\u0332 -1  0\u0332  0 -1 -4    N -2  0  6  1 -3  0  0  0  1 -3 -3  0 -2 -3 -2  1  0 -4 -2 -3  0\u0332  0\u0332  3  0\u0332  0 -1 -4    D -2 -2  1  6 -3  0  2 -1 -1 -3 -4 -1 -3 -3 -1  0 -1 -4 -3 -3  0\u0332  0\u0332  4  0\u0332  1 -1 -4    C  0 -3 -3 -3  9 -3 -4 -3 -3 -1 -1 -3 -1 -2 -3 -1 -1 -2 -2 -1  0\u0332  0\u0332 -3  0\u0332 -3 -2 -4    Q -1  1  0  0 -3  5  2 -2  0 -3 -2  1  0 -3 -1  0 -1 -2 -1 -2  0\u0332  0\u0332  0  0\u0332  3 -1 -4    E -1  0  0  2 -4  2  5 -2  0 -3 -3  1 -2 -3 -1  0 -1 -3 -2 -2  0\u0332  0\u0332  1  0\u0332  4 -1 -4    G  0 -2  0 -1 -3 -2 -2  6 -2 -4 -4 -2 -3 -3 -2  0 -2 -2 -3 -3  0\u0332  0\u0332 -1  0\u0332 -2 -1 -4    H -2  0  1 -1 -3  0  0 -2  8 -3 -3 -1 -2 -1 -2 -1 -2 -2  2 -3  0\u0332  0\u0332  0  0\u0332  0 -1 -4    I -1 -3 -3 -3 -1 -3 -3 -4 -3  4  2 -3  1  0 -3 -2 -1 -3 -1  3  0\u0332  0\u0332 -3  0\u0332 -3 -1 -4    L -1 -2 -3 -4 -1 -2 -3 -4 -3  2  4 -2  2  0 -3 -2 -1 -2 -1  1  0\u0332  0\u0332 -4  0\u0332 -3 -1 -4    K -1  2  0 -1 -3  1  1 -2 -1 -3 -2  5 -1 -3 -1  0 -1 -3 -2 -2  0\u0332  0\u0332  0  0\u0332  1 -1 -4    M -1 -1 -2 -3 -1  0 -2 -3 -2  1  2 -1  5  0 -2 -1 -1 -1 -1  1  0\u0332  0\u0332 -3  0\u0332 -1 -1 -4    F -2 -3 -3 -3 -2 -3 -3 -3 -1  0  0 -3  0  6 -4 -2 -2  1  3 -1  0\u0332  0\u0332 -3  0\u0332 -3 -1 -4    P -1 -2 -2 -1 -3 -1 -1 -2 -2 -3 -3 -1 -2 -4  7 -1 -1 -4 -3 -2  0\u0332  0\u0332 -2  0\u0332 -1 -2 -4    S  1 -1  1  0 -1  0  0  0 -1 -2 -2  0 -1 -2 -1  4  1 -3 -2 -2  0\u0332  0\u0332  0  0\u0332  0  0 -4    T  0 -1  0 -1 -1 -1 -1 -2 -2 -1 -1 -1 -1 -2 -1  1  5 -2 -2  0  0\u0332  0\u0332 -1  0\u0332 -1  0 -4    W -3 -3 -4 -4 -2 -2 -3 -2 -2 -3 -2 -3 -1  1 -4 -3 -2 11  2 -3  0\u0332  0\u0332 -4  0\u0332 -3 -2 -4    Y -2 -2 -2 -3 -2 -1 -2 -3  2 -1 -1 -2 -1  3 -3 -2 -2  2  7 -1  0\u0332  0\u0332 -3  0\u0332 -2 -1 -4    V  0 -3 -3 -3 -1 -2 -2 -3 -3  3  1 -2  1 -1 -2 -2  0 -3 -1  4  0\u0332  0\u0332 -3  0\u0332 -2 -1 -4    O  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332    U  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332    B -2 -1  3  4 -3  0  1 -1  0 -3 -4  0 -3 -3 -2  0 -1 -4 -3 -3  0\u0332  0\u0332  4  0\u0332  1 -1 -4    J  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332    Z -1  0  0  1 -3  3  4 -2  0 -3 -3  1 -1 -3 -1  0 -1 -3 -2 -2  0\u0332  0\u0332  1  0\u0332  4 -1 -4    X  0 -1 -1 -1 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -2  0  0 -2 -1 -1  0\u0332  0\u0332 -1  0\u0332 -1 -1 -4    * -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4  0\u0332  0\u0332 -4  0\u0332 -4 -4  1  (underlined values are default ones)      Matrix  Constants      PAM  PAM30 ,  PAM70 ,  PAM250    BLOSUM  BLOSUM45 ,  BLOSUM50 ,  BLOSUM62 ,  BLOSUM80 ,  BLOSUM90     These matrices are downloaded from:  ftp://ftp.ncbi.nih.gov/blast/matrices/ .  SubstitutionMatrix  can be modified like a regular matrix:  julia   mysubmat   =   copy ( BLOSUM62 );    # create a copy  julia   mysubmat [ AA_A , AA_R ]    # score of AA_A =  AA_R substitution is -1  -1  julia   mysubmat [ AA_A , AA_R ]   =   - 3    # set the score to -3  -3  julia   mysubmat [ AA_A , AA_R ]    # the score is modified  -3   Make sure to create a copy of the original matrix when you create a matrix from a predefined matrix. In the above case,  BLOSUM62  is shared in the whole program and modification on it will affect any result that uses  BLOSUM62 .  DichotomousSubstitutionMatrix  is a specialized matrix for matching or mismatching substitution.  This is a preferable choice when performance is more important than flexibility because looking up score is faster than  SubstitutionMatrix .  julia   submat   =   DichotomousSubstitutionMatrix ( 1 ,   - 1 )  Bio.Align.DichotomousSubstitutionMatrix{Int64}:       match =  1    mismatch = -1  julia   submat [ A , A ]    # match  1  julia   submat [ A , B ]    # mismatch  -1", 
            "title": "Substitution matrices"
        }, 
        {
            "location": "/man/alignments/#alignment-file-formats-for-high-throughput-sequencing", 
            "text": "High-throughput sequencing (HTS) technologies generate a large amount of data in the form of a large number of nucleotide sequencing reads. One of the most common tasks in bioinformatics is to align these reads against known reference genomes, chromosomes, or contigs. The  Bio.Align  module provides several data formats commonly used for this kind of task.", 
            "title": "Alignment file formats for high-throughput sequencing"
        }, 
        {
            "location": "/man/alignments/#sam-and-bam-file-formats", 
            "text": "SAM and BAM are the most popular file formats and have the same reading and writing interface as all other formats in Bio.jl (see  Reading and writing data  section). A typical code iterating over all records in a file looks like below:  # import the SAM and BAM module  using   Bio . Align  # open a BAM file  reader   =   open ( BAM . Reader ,   data.bam )  # iterate over BAM records  for   record   in   reader \n     # `record` is a BAM.Record object \n     if   BAM . ismapped ( record ) \n         # print mapped position \n         println ( BAM . refname ( record ),   : ,   BAM . position ( record )) \n     end  end  # close the BAM file  close ( reader )   Accessor functions are defined in  SAM  and  BAM  modules.  Lists of these functions to  SAM.Record  and  BAM.Record  are described in  SAM  and  BAM  sections, respectively.  SAM.Reader  and  BAM.Reader  implement the  header  function, which returns a  SAM.Header  object. This is conceptually a sequence of  SAM.MetaInfo  objects corresponding to header lines that start with '@' markers. To select  SAM.MetaInfo  records with a specific tag, you can use the  find  function:  julia   reader   =   open ( SAM . Reader ,   data.sam );  julia   find ( header ( reader ),   SQ )  7-element Array{Bio.Align.SAM.MetaInfo,1}:   Bio.Align.SAM.MetaInfo:      tag: SQ    value: SN=Chr1 LN=30427671   Bio.Align.SAM.MetaInfo:      tag: SQ    value: SN=Chr2 LN=19698289   Bio.Align.SAM.MetaInfo:      tag: SQ    value: SN=Chr3 LN=23459830   Bio.Align.SAM.MetaInfo:      tag: SQ    value: SN=Chr4 LN=18585056   Bio.Align.SAM.MetaInfo:      tag: SQ    value: SN=Chr5 LN=26975502   Bio.Align.SAM.MetaInfo:      tag: SQ    value: SN=chloroplast LN=154478   Bio.Align.SAM.MetaInfo:      tag: SQ    value: SN=mitochondria LN=366924   A  SAM.MetaInfo  object can be created as follows:  julia   SAM . MetaInfo ( SQ ,   [ SN   =   chr1 ,   LN   =   1234 ])  Bio.Align.SAM.MetaInfo:      tag: SQ    value: SN=chr1 LN=1234  julia   SAM . MetaInfo ( CO ,   comment )  Bio.Align.SAM.MetaInfo:      tag: CO    value: comment", 
            "title": "SAM and BAM file formats"
        }, 
        {
            "location": "/man/alignments/#performance-tips", 
            "text": "The size of a BAM file is often extremely large. The iterator interface mentioned above allocates an object for each record and that may be a bottleneck of reading data from a BAM file. In-place reading reuses a preallocated object for every record and less memory allocation happens in reading:  reader   =   open ( BAM . Reader ,   data.bam )  record   =   BAM . Record ()  while   ! eof ( reader ) \n     read! ( reader ,   record ) \n     # do something  end   Accessing optional fields will results in type instability in Julia, which has a significant negative impact on performance. If the user knows the type of a value in advance, specifying it as a type annotation will alleviate the problem:  for   record   in   open ( BAM . Reader ,   data.bam ) \n     nm   =   record [ NM ] :: UInt8 \n     # do something  end", 
            "title": "Performance tips"
        }, 
        {
            "location": "/man/intervals/", 
            "text": "Intervals: Genomic Interval Manipulation\n\n\nThe \nIntervals\n module consists of tools for working efficiently with genomic intervals.\n\n\n\n\nInterval types\n\n\nIntervals in Bio.jl are consistent with ranges in Julia: \n1-based and end-inclusive\n. When data is read from formats with different representations (i.e. 0-based and/or end-exclusive) they are always converted automatically. Similarly when writing data. You should not have to reason about off-by-one errors due to format differences while using functionality provided in Bio.jl.\n\n\nThe \nInterval\n type is defined as\n\n\ntype\n \nInterval\n{\nT\n}\n \n:\n \nAbstractInterval\n{\nInt64\n}\n\n    \nseqname\n::\nStringField\n\n    \nfirst\n::\nInt64\n\n    \nlast\n::\nInt64\n\n    \nstrand\n::\nStrand\n\n    \nmetadata\n::\nT\n\n\nend\n\n\n\n\n\n\nThe first three fields (\nseqname\n, \nfirst\n, and \nlast\n) are mandatory arguments when constructing an \nInterval\n object. \nseqname\n is the sequence name associated with the interval. The \nfirst\n and \nlast\n fields are the leftmost and rightmost positions of the interval, which can be accessed with \nleftposition\n and \nrightposition\n functions, respectively.\n\n\nThe \nstrand\n field can take four kinds of values listed in the next table:\n\n\n\n\n\n\n\n\nSymbol\n\n\nConstant\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n'?'\n\n\nSTRAND_NA\n\n\nstrand is unknown or inapplicable\n\n\n\n\n\n\n'+'\n\n\nSTRAND_POS\n\n\npositive strand\n\n\n\n\n\n\n'-'\n\n\nSTRAND_NEG\n\n\nnegative strand\n\n\n\n\n\n\n'.'\n\n\nSTRAND_BOTH\n\n\nnon-strand-specific feature\n\n\n\n\n\n\n\n\nSimilarly to the \nSeqRecord\n type in the \nBio.Seq\n module, \nInterval\n is parameterized on metadata type, which lets it efficiently and precisely be specialized to represent intervals from a variety of formats.\n\n\nThe default strand and metadata values are \nSTRAND_BOTH\n and \nnothing\n:\n\n\njulia\n \nInterval\n(\nchr1\n,\n \n10000\n,\n \n20000\n)\n\n\nBio.Intervals.Interval{Void}:\n\n\n  sequence name: chr1\n\n\n  leftmost position: 10000\n\n\n  rightmost position: 20000\n\n\n  strand: .\n\n\n  metadata: nothing\n\n\n\njulia\n \nInterval\n(\nchr1\n,\n \n10000\n,\n \n20000\n,\n \n+\n)\n\n\nBio.Intervals.Interval{Void}:\n\n\n  sequence name: chr1\n\n\n  leftmost position: 10000\n\n\n  rightmost position: 20000\n\n\n  strand: +\n\n\n  metadata: nothing\n\n\n\n\n\n\nThe following example shows all accessor functions for the five fields:\n\n\njulia\n \ni\n \n=\n \nInterval\n(\nchr1\n,\n \n10000\n,\n \n20000\n,\n \n+\n,\n \nsome annotation\n)\n\n\nBio.Intervals.Interval{String}:\n\n\n  sequence name: chr1\n\n\n  leftmost position: 10000\n\n\n  rightmost position: 20000\n\n\n  strand: +\n\n\n  metadata: some annotation\n\n\n\njulia\n \nseqname\n(\ni\n)\n\n\nchr1\n\n\n\njulia\n \nleftposition\n(\ni\n)\n\n\n10000\n\n\n\njulia\n \nrightposition\n(\ni\n)\n\n\n20000\n\n\n\njulia\n \nstrand\n(\ni\n)\n\n\nSTRAND_POS\n\n\n\njulia\n \nmetadata\n(\ni\n)\n\n\nsome annotation\n\n\n\n\n\n\n\n\nCollections of intervals\n\n\nCollections of intervals are represented using the \nIntervalCollection\n type, which is a general purpose indexed container for intervals. It supports fast intersection operations as well as insertion, deletion, and sorted iteration.\n\n\nInterval collections can be initialized by inserting elements one by one using \npush!\n.\n\n\n# The type parameter (Void here) indicates the interval metadata type.\n\n\nincol\n \n=\n \nIntervalCollection\n{\nVoid\n}()\n\n\n\nfor\n \ni\n \nin\n \n1\n:\n100\n:\n10000\n\n    \npush!\n(\nincol\n,\n \nInterval\n(\nchr1\n,\n \ni\n,\n \ni\n \n+\n \n99\n))\n\n\nend\n\n\n\n\n\n\nIncrementally building an interval collection like this works, but \nIntervalCollection\n also has a bulk insertion constructor that is able to build the indexed data structure extremely efficiently from an array of intervals.\n\n\nincol\n \n=\n \nIntervalCollection\n([\nInterval\n(\nchr1\n,\n \ni\n,\n \ni\n \n+\n \n99\n)\n \nfor\n \ni\n \nin\n \n1\n:\n100\n:\n10000\n])\n\n\n\n\n\n\nBulding \nIntervalCollections\n in one shot like this should be preferred when it's convenient or speed in an issue.\n\n\n\n\nIntersection\n\n\nThere are number of \neachoverlap\n function in the Intervals module. They follow two patterns: interval versus collection queries which return an iterator over intervals in the collection that intersect the query, and collection versus collection queries which iterate over all pairs of overlapping intervals.\n\n\n#\n\n\nBio.Intervals.eachoverlap\n \n \nFunction\n.\n\n\neachoverlap(intervals_a, intervals_b, [seqname_isless=Base.isless])\n\n\n\n\n\nCreate an iterator of overlapping intervals between \nintervals_a\n and \nintervals_b\n.\n\n\nThis function assumes elements of \nintervals_a\n and \nintervals_b\n are sorted by its sequence name and left position.  If the element type is not a subtype of \nBio.Intervals.Interval\n, elements are converted to \nInterval\n objects.\n\n\nThe third optional argument is a function that defines the order of sequence names. The default function is \nBase.isless\n, which is the lexicographical order.\n\n\nsource\n\n\nThe order of interval pairs is the same as the following nested loop but \neachoverlap\n is often much faster:\n\n\nfor\n \na\n \nin\n \nintervals_a\n,\n \nb\n \nin\n \nintervals_b\n\n    \nif\n \nisoverlapping\n(\na\n,\n \nb\n)\n\n        \n# do something...\n\n    \nend\n\n\nend\n\n\n\n\n\n\n\n\nInterval streams\n\n\nIntervals need not necessarily stored in an indexed data structure for efficient intersection to be practical. Two collections of intervals need only be both sorted to compute all intersecting pairs. This is particularly useful in genomics where datasets are sometimes so large that loading them entirely into memory is not practical.\n\n\nThe Intervals module is able to intersect any two iterators that yield intervals in sorted order, which we refer to as \"interval streams\". An \nIntervalCollection\n is also an interval stream, but so is a sorted array of intervals, and parsers over interval file formats. This allows for a very general notion of intersection.\n\n\nfor\n \n(\nx\n,\n \ny\n)\n \nin\n \neachoverlap\n(\nopen\n(\nBEDReader\n,\n \nx_features.bed\n),\n \nopen\n(\nBEDReader\n,\n \ny_features.bed\n))\n\n    \nprintln\n(\nIntersection found between \n,\n \nx\n,\n \n and \n,\n \ny\n)\n\n\nend\n\n\n\n\n\n\nAn exception will be thrown if an interval in encountered out of order while processing an interval stream. Ordering of intervals has one complication: there is not necessarily a standardized way to order sequence names. By default in Bio.jl intervals are sorted using a \nBase.isless\n comparison function that is a default order in most command-line tools. The Intervals module also offers \nalphanum_isless\n comparison that compares numbers numerically if they exist in string, so that names like \nchr1, chr2, chr10\n end up in their natural order.\n\n\nThe \neachoverlap\n function takes as an optional parameter an \nisless\n function to use to compare sequence names to account for arbitrary sequence name orderings.\n\n\nfor\n \n(\nx\n,\n \ny\n)\n \nin\n \neachoverlap\n(\nxs\n,\n \nys\n,\n \nBio\n.\nIntervals\n.\nalphanum_isless\n)\n\n    \nprintln\n(\nIntersection found between \n,\n \na\n,\n \n and \n,\n \nb\n)\n\n\nend\n\n\n\n\n\n\nA special sort of intersection can also be performed on an interval stream against itself to produce \"coverage intervals\".\n\n\n#\n\n\nBio.Intervals.coverage\n \n \nFunction\n.\n\n\ncoverage(intervals)\n\n\n\n\n\nCompute the coverage of a collection of intervals and return an \nIntervalCollection\n that contains run-length encoded coverage data.\n\n\nFor example, given intervals like:\n\n\n[------]     [------------]\n\n   \n[---------------]\n\n\n\n\n\n\nThis function would return a new set of disjoint intervals with annotated coverage like:\n\n\n[1][-2-][-1-][--2--][--1--]\n\n\n\n\n\nsource", 
            "title": "Intervals"
        }, 
        {
            "location": "/man/intervals/#intervals-genomic-interval-manipulation", 
            "text": "The  Intervals  module consists of tools for working efficiently with genomic intervals.", 
            "title": "Intervals: Genomic Interval Manipulation"
        }, 
        {
            "location": "/man/intervals/#interval-types", 
            "text": "Intervals in Bio.jl are consistent with ranges in Julia:  1-based and end-inclusive . When data is read from formats with different representations (i.e. 0-based and/or end-exclusive) they are always converted automatically. Similarly when writing data. You should not have to reason about off-by-one errors due to format differences while using functionality provided in Bio.jl.  The  Interval  type is defined as  type   Interval { T }   :   AbstractInterval { Int64 } \n     seqname :: StringField \n     first :: Int64 \n     last :: Int64 \n     strand :: Strand \n     metadata :: T  end   The first three fields ( seqname ,  first , and  last ) are mandatory arguments when constructing an  Interval  object.  seqname  is the sequence name associated with the interval. The  first  and  last  fields are the leftmost and rightmost positions of the interval, which can be accessed with  leftposition  and  rightposition  functions, respectively.  The  strand  field can take four kinds of values listed in the next table:     Symbol  Constant  Meaning      '?'  STRAND_NA  strand is unknown or inapplicable    '+'  STRAND_POS  positive strand    '-'  STRAND_NEG  negative strand    '.'  STRAND_BOTH  non-strand-specific feature     Similarly to the  SeqRecord  type in the  Bio.Seq  module,  Interval  is parameterized on metadata type, which lets it efficiently and precisely be specialized to represent intervals from a variety of formats.  The default strand and metadata values are  STRAND_BOTH  and  nothing :  julia   Interval ( chr1 ,   10000 ,   20000 )  Bio.Intervals.Interval{Void}:    sequence name: chr1    leftmost position: 10000    rightmost position: 20000    strand: .    metadata: nothing  julia   Interval ( chr1 ,   10000 ,   20000 ,   + )  Bio.Intervals.Interval{Void}:    sequence name: chr1    leftmost position: 10000    rightmost position: 20000    strand: +    metadata: nothing   The following example shows all accessor functions for the five fields:  julia   i   =   Interval ( chr1 ,   10000 ,   20000 ,   + ,   some annotation )  Bio.Intervals.Interval{String}:    sequence name: chr1    leftmost position: 10000    rightmost position: 20000    strand: +    metadata: some annotation  julia   seqname ( i )  chr1  julia   leftposition ( i )  10000  julia   rightposition ( i )  20000  julia   strand ( i )  STRAND_POS  julia   metadata ( i )  some annotation", 
            "title": "Interval types"
        }, 
        {
            "location": "/man/intervals/#collections-of-intervals", 
            "text": "Collections of intervals are represented using the  IntervalCollection  type, which is a general purpose indexed container for intervals. It supports fast intersection operations as well as insertion, deletion, and sorted iteration.  Interval collections can be initialized by inserting elements one by one using  push! .  # The type parameter (Void here) indicates the interval metadata type.  incol   =   IntervalCollection { Void }()  for   i   in   1 : 100 : 10000 \n     push! ( incol ,   Interval ( chr1 ,   i ,   i   +   99 ))  end   Incrementally building an interval collection like this works, but  IntervalCollection  also has a bulk insertion constructor that is able to build the indexed data structure extremely efficiently from an array of intervals.  incol   =   IntervalCollection ([ Interval ( chr1 ,   i ,   i   +   99 )   for   i   in   1 : 100 : 10000 ])   Bulding  IntervalCollections  in one shot like this should be preferred when it's convenient or speed in an issue.", 
            "title": "Collections of intervals"
        }, 
        {
            "location": "/man/intervals/#intersection", 
            "text": "There are number of  eachoverlap  function in the Intervals module. They follow two patterns: interval versus collection queries which return an iterator over intervals in the collection that intersect the query, and collection versus collection queries which iterate over all pairs of overlapping intervals.  #  Bio.Intervals.eachoverlap     Function .  eachoverlap(intervals_a, intervals_b, [seqname_isless=Base.isless])  Create an iterator of overlapping intervals between  intervals_a  and  intervals_b .  This function assumes elements of  intervals_a  and  intervals_b  are sorted by its sequence name and left position.  If the element type is not a subtype of  Bio.Intervals.Interval , elements are converted to  Interval  objects.  The third optional argument is a function that defines the order of sequence names. The default function is  Base.isless , which is the lexicographical order.  source  The order of interval pairs is the same as the following nested loop but  eachoverlap  is often much faster:  for   a   in   intervals_a ,   b   in   intervals_b \n     if   isoverlapping ( a ,   b ) \n         # do something... \n     end  end", 
            "title": "Intersection"
        }, 
        {
            "location": "/man/intervals/#interval-streams", 
            "text": "Intervals need not necessarily stored in an indexed data structure for efficient intersection to be practical. Two collections of intervals need only be both sorted to compute all intersecting pairs. This is particularly useful in genomics where datasets are sometimes so large that loading them entirely into memory is not practical.  The Intervals module is able to intersect any two iterators that yield intervals in sorted order, which we refer to as \"interval streams\". An  IntervalCollection  is also an interval stream, but so is a sorted array of intervals, and parsers over interval file formats. This allows for a very general notion of intersection.  for   ( x ,   y )   in   eachoverlap ( open ( BEDReader ,   x_features.bed ),   open ( BEDReader ,   y_features.bed )) \n     println ( Intersection found between  ,   x ,    and  ,   y )  end   An exception will be thrown if an interval in encountered out of order while processing an interval stream. Ordering of intervals has one complication: there is not necessarily a standardized way to order sequence names. By default in Bio.jl intervals are sorted using a  Base.isless  comparison function that is a default order in most command-line tools. The Intervals module also offers  alphanum_isless  comparison that compares numbers numerically if they exist in string, so that names like  chr1, chr2, chr10  end up in their natural order.  The  eachoverlap  function takes as an optional parameter an  isless  function to use to compare sequence names to account for arbitrary sequence name orderings.  for   ( x ,   y )   in   eachoverlap ( xs ,   ys ,   Bio . Intervals . alphanum_isless ) \n     println ( Intersection found between  ,   a ,    and  ,   b )  end   A special sort of intersection can also be performed on an interval stream against itself to produce \"coverage intervals\".  #  Bio.Intervals.coverage     Function .  coverage(intervals)  Compute the coverage of a collection of intervals and return an  IntervalCollection  that contains run-length encoded coverage data.  For example, given intervals like:  [------]     [------------] \n    [---------------]   This function would return a new set of disjoint intervals with annotated coverage like:  [1][-2-][-1-][--2--][--1--]  source", 
            "title": "Interval streams"
        }, 
        {
            "location": "/man/var/", 
            "text": "Bio.Var: Biological Variation.\n\n\n\n\nIdentifying and counting sequence sites\n\n\nYou can identify and count the number of various types of site in a nucleotide sequence, or pair/set of aligned nucleotide sequences.\n\n\n\n\nDifferent types of site\n\n\n\n\nThe abstract Site types\n\n\nSite\nMutation\n\n\n\n\n\n\n\nThe concrete types of site case\n\n\nThe types of mutations that can currently be counted are summarized below:\n\n\n#\n\n\nBio.Var.Gap\n \n \nType\n.\n\n\nAn \nGap\n site describes a site where either of two aligned sites are a gap symbol '-'.\n\n\nsource\n\n\n#\n\n\nBio.Var.Ambiguous\n \n \nType\n.\n\n\nAn \nAmbiguous\n site describes a site where either of two aligned sites are an ambiguity symbol.\n\n\nsource\n\n\n#\n\n\nBio.Var.Certain\n \n \nType\n.\n\n\nA \nCertain\n site describes a site where both of two aligned sites are not an ambiguity symbol or a gap.\n\n\nsource\n\n\n#\n\n\nBio.Var.Match\n \n \nType\n.\n\n\nA \nMatch\n site describes a site where two aligned nucleotides are the same biological symbol.\n\n\nsource\n\n\n#\n\n\nBio.Var.Mismatch\n \n \nType\n.\n\n\nA \nMismatch\n site describes a site where two aligned nucleotides are not the same biological symbol.\n\n\nsource\n\n\n#\n\n\nBio.Var.Conserved\n \n \nType\n.\n\n\nA \nMismatch\n site describes a site where two aligned nucleotides are definately conserved. By definately conserved this means that the symbols of the site are non-ambiguity symbols, and they are the same symbol.\n\n\nsource\n\n\n#\n\n\nBio.Var.Mutated\n \n \nType\n.\n\n\nA \nMutated\n site describes a site where two aligned nucleotides are definately mutated. By definately mutated this means that the symbols of the site are non-ambiguity symbols, and they are not the same symbol.\n\n\nsource\n\n\n#\n\n\nBio.Var.Transition\n \n \nType\n.\n\n\nA \nTransition\n site describes a site where two aligned nucleotides are definately mutated, and the type of mutation is a transition mutation. In other words, the symbols must not be ambiguity symbols, and they must be different such that they constitute a transition mutation: i.e. A\n-\nG, or C\n-\nT.\n\n\nsource\n\n\n#\n\n\nBio.Var.Transversion\n \n \nType\n.\n\n\nA \nTransversion\n site describes a site where two aligned nucleotides are definately mutated, and the type of mutation is a transversion mutation. In other words, the symbols must not be ambiguity symbols, and they must be different such that they constitute a transversion mutation: i.e. A\n-\nC, A\n-\nT, G\n-\nT, G\n-\nC.\n\n\nsource\n\n\n\n\nThe \ncount_sites\n method\n\n\n#\n\n\nBio.Var.count_sites\n \n \nFunction\n.\n\n\ncount_sites{T\n:Site}(::Type{T}, a::BioSequence, b::BioSequence)\n\n\n\n\n\nMutations are counted using the \ncount_sites\n method.\n\n\nIf the concrete site case type inherits from NoPairDel, then the result will be a simple integer value of the number of counts of site.\n\n\nIf the concrete site case type inherits from PairDel, then the result will be a tuple. As a result, counting methods for such types also count and return the number of sites which could not be unambiguously determined. This second count is important for some downstream purposes, for example evolutionary/genetic distance computations in which pairwise deletion of ambiguous sites is necessary.\n\n\nsource\n\n\ncount_sites{T\n:NoPairDel}(::Type{T}, a::EachWindowIterator, b::EachWindowIterator)\n\n\n\n\n\nA method of the count_sites function for counting sites of SiteType \nT\n between two aligned sequences.\n\n\nCrucially, this method accepts two EachWindowIterators as parameters \na\n and \nb\n instead of two \nBioSequence\ns. As a result, the two sequences are iterated over with a sliding window, and a site count computed for each window.\n\n\nThis function returns two vectors, one with the ranges\n\n\nsource\n\n\nCount the number of sites between two nucleotide sequences using a sliding window.\n\n\nsource\n\n\nCount the number of mutations between nucleotide sequences in a pairwise manner.\n\n\nsource\n\n\nCount the number of mutations between nucleotide sequences in a pairwise manner, using a sliding window of a given width and step.\n\n\nsource\n\n\nCount the number of mutations between nucleotide sequences in a pairwise manner.\n\n\nsource\n\n\nCount the number of mutations between nucleotide sequences in a pairwise manner, using a sliding window of a given width and step.\n\n\nsource\n\n\nCount the number of sites of a given SiteType \nT\n in a biological sequence.\n\n\nsource\n\n\ncount_sites\n(\nMatch\n,\n \n[\ndna\nATCGATCG\n,\n \ndna\nACCGATCG\n])\n\n\n\ncount_sites\n(\nMismatch\n,\n \n[\ndna\nATCGATCG\n,\n \ndna\nACCGATCG\n])\n\n\n\ncount_sites\n(\nConserved\n,\n \n[\ndna\nATCGATCG\n,\n \ndna\nACCGATCG\n])\n\n\n\ncount_sites\n(\nMutated\n,\n \n[\ndna\nATCGATCG\n,\n \ndna\nACCGATCG\n])\n\n\n\ncount_sites\n(\nTransition\n,\n \n[\nrna\nAUCGAUCG\n,\n \nrna\nACCGAUCG\n])\n\n\n\ncount_sites\n(\nTransversion\n,\n \n[\nrna\nAUCGAUCG\n,\n \nrna\nACCGAUCG\n])\n\n\n\n\n\n\n\n\nFile formats for representing genetic variation\n\n\nThis module supports some common file formats to read and write genetic variations.\n\n\n\n\nVCF and BCF file formats\n\n\nVCF and BCF file formats can be read using \nVCFReader\n and \nBCFReader\n, respectively:\n\n\nreader\n \n=\n \nopen\n(\nVCFReader\n,\n \nexample.vcf\n)\n\n\nfor\n \nrecord\n \nin\n \nreader\n\n    \n# do something\n\n\nend\n\n\nclose\n(\nreader\n)\n\n\n\n\n\n\nA reader first reads the header section of a file and creates a \nVCFHeader\n object. The \nheader\n function is provided to access the header object of a reader:\n\n\njulia\n \nheader\n(\nreader\n)\n\n\nBio.Var.VCFHeader:\n\n\n  metainfo tags: fileformat fileDate source reference contig phasing INFO FILTER FORMAT\n\n\n     sample IDs: NA00001 NA00002 NA00003\n\n\n\njulia\n \nfind\n(\nheader\n(\nreader\n),\n \nFORMAT\n)\n\n\n4-element Array{Bio.Var.VCFMetaInfo,1}:\n\n\n Bio.Var.VCFMetaInfo:\n\n\n    tag: FORMAT\n\n\n  value: ID=\nGT\n Number=\n1\n Type=\nString\n Description=\nGenotype\n\n\n Bio.Var.VCFMetaInfo:\n\n\n    tag: FORMAT\n\n\n  value: ID=\nGQ\n Number=\n1\n Type=\nInteger\n Description=\nGenotype Quality\n\n\n Bio.Var.VCFMetaInfo:\n\n\n    tag: FORMAT\n\n\n  value: ID=\nDP\n Number=\n1\n Type=\nInteger\n Description=\nRead Depth\n\n\n Bio.Var.VCFMetaInfo:\n\n\n    tag: FORMAT\n\n\n  value: ID=\nHQ\n Number=\n2\n Type=\nInteger\n Description=\nHaplotype Quality\n\n\n\n\n\n\nVCFMetaInfo\n objects in the header support the following accessor functions:\n\n\n\n\n\n\n\n\nAccessor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmetainfotag\n\n\ntag string\n\n\n\n\n\n\nmetainfoval\n\n\nvalue string\n\n\n\n\n\n\nkeys\n\n\nkeys of fields between '\n' and '\n'\n\n\n\n\n\n\nvalues\n\n\nvalues of fields between '\n' and '\n'\n\n\n\n\n\n\n[\nkey\n]\n\n\nvalue of a field with \nkey\n\n\n\n\n\n\n\n\njulia\n \nmetainfo\n \n=\n \nVCFMetaInfo\n(\n##FORMAT=\nID=GT,Number=1,Type=String,Description=\n\\\nGenotype\n\\\n)\n\n\nBio.Var.VCFMetaInfo:\n\n\n    tag: FORMAT\n\n\n  value: ID=\nGT\n Number=\n1\n Type=\nString\n Description=\nGenotype\n\n\n\njulia\n \nmetainfotag\n(\nmetainfo\n)\n\n\nFORMAT\n\n\n\njulia\n \nmetainfoval\n(\nmetainfo\n)\n\n\nID=GT,Number=1,Type=String,Description=\\\nGenotype\\\n\n\n\njulia\n \nkeys\n(\nmetainfo\n)\n\n\n4-element Array{String,1}:\n\n\n \nID\n\n\n \nNumber\n\n\n \nType\n\n\n \nDescription\n\n\n\njulia\n \nmetainfo\n[\nID\n]\n\n\nGT\n\n\n\n\n\n\nVCFRecord\n and \nBCFRecord\n objects support the following accessor functions (see the docstring of each accessor for the details):\n\n\n\n\n\n\n\n\nAccessor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nchromosome\n\n\nchromosome name\n\n\n\n\n\n\nleftposition\n\n\nreference position\n\n\n\n\n\n\nidentifier\n\n\nunique identifiers\n\n\n\n\n\n\nreference\n\n\nreference bases\n\n\n\n\n\n\nalternate\n\n\nalternate bases\n\n\n\n\n\n\nquality\n\n\nPhred-scaled quality score\n\n\n\n\n\n\nfilter_\n\n\nfilter status\n\n\n\n\n\n\ninformation\n\n\nadditional information\n\n\n\n\n\n\ninfokeys\n\n\nkeys of additional information\n\n\n\n\n\n\nformat\n\n\ngenotype format\n\n\n\n\n\n\ngenotype\n\n\ngenotype information\n\n\n\n\n\n\n\n\njulia\n \nrecord\n \n=\n \nVCFRecord\n(\n20\n\\t\n14370\n\\t\nrs6054257\n\\t\nG\n\\t\nA\n\\t\n29\n\\t\nPASS\n\\t\nNS=3;DP=14;AF=0.5;DB;H2\n\\t\nGT:GQ:DP:HQ\n\\t\n0|0:48:1:51,51\n\\t\n1|0:48:8:51,51\n)\n\n\n\nBio.Var.VCFRecord:\n\n\n   chromosome: 20\n\n\n     position: 14370\n\n\n   identifier: rs6054257\n\n\n    reference: G\n\n\n    alternate: A\n\n\n      quality: 29.0\n\n\n       filter: PASS\n\n\n  information: NS=3 DP=14 AF=0.5 DB H2\n\n\n       format: GT GQ DP HQ\n\n\n     genotype: [1] 0|0 48 1 51,51 [2] 1|0 48 8 51,51\n\n\n\njulia\n \nchromosome\n(\nrecord\n)\n\n\nNullable{String}(\n20\n)\n\n\n\njulia\n \nleftposition\n(\nrecord\n)\n\n\nNullable{Int64}(14370)\n\n\n\njulia\n \nidentifier\n(\nrecord\n)\n\n\n1-element Array{String,1}:\n\n\n \nrs6054257\n\n\n\njulia\n \nreference\n(\nrecord\n)\n\n\nNullable{String}(\nG\n)\n\n\n\njulia\n \nalternate\n(\nrecord\n)\n\n\n1-element Array{String,1}:\n\n\n \nA\n\n\n\njulia\n \nquality\n(\nrecord\n)\n\n\nNullable{Float64}(29.0)\n\n\n\njulia\n \nfilter_\n(\nrecord\n)\n\n\n1-element Array{String,1}:\n\n\n \nPASS\n\n\n\njulia\n \ninformation\n(\nrecord\n)\n\n\n5-element Array{Pair{String,String},1}:\n\n\n \nNS\n=\n3\n\n\n \nDP\n=\n14\n\n\n \nAF\n=\n0.5\n\n\n \nDB\n=\n\n\n \nH2\n=\n\n\n\njulia\n \ninformation\n(\nrecord\n,\n \nAF\n)\n\n\n0.5\n\n\n\njulia\n \nformat\n(\nrecord\n)\n\n\n4-element Array{String,1}:\n\n\n \nGT\n\n\n \nGQ\n\n\n \nDP\n\n\n \nHQ\n\n\n\njulia\n \ngenotype\n(\nrecord\n)\n\n\n2-element Array{Array{String,1},1}:\n\n\n String[\n0|0\n,\n48\n,\n1\n,\n51,51\n]\n\n\n String[\n1|0\n,\n48\n,\n8\n,\n51,51\n]\n\n\n\njulia\n \ngenotype\n(\nrecord\n,\n \n1\n)\n\n\n4-element Array{String,1}:\n\n\n \n0|0\n\n\n \n48\n\n\n \n1\n\n\n \n51,51\n\n\n\njulia\n \ngenotype\n(\nrecord\n,\n \n1\n:\n2\n,\n \nGT\n)\n\n\n2-element Array{String,1}:\n\n\n \n0|0\n\n\n \n1|0\n\n\n\n\n\n\n\n\nMASH Distances\n\n\nMASH distances\n, based on MinHash sketches of genome sequences can provide rapid genome-scale sequence comparisons when sequence distance (not specific mutations) are all that's required.\n\n\nA MinHash sketch is made by taking the \ns\n smallest hash values for kmers of length \nk\n for a given sequence. The genome distance for two genomes is then essentially the \nJaccard index\n of the minhashes, with some additional modification to account for the size of the kmers used.\n\n\nYou can generate a MinHash sketch using the \nminhash()\n function in \nBio.seq\n.\n\n\nusing\n \nBio\n.\nSeq\n\n\n\nseq1\n \n=\n \ndna\nAAATAAGGCACAACTATGCAT\n\n\nsketch1\n \n=\n \nminhash\n(\nseq\n,\n \n5\n,\n \n10\n)\n\n\n\n\n\n\nThen, if you have MinHash sketches with the same parameters for two sequences, you can determine the MASH distance between them.\n\n\nseq2\n \n=\n \ndna\nAATTAACGCACGGACTGCGGTAAT\n\n\nsketch2\n \n=\n \nminhash\n(\nseq\n,\n \n5\n,\n \n10\n)\n\n\n\nusing\n \nBio\n.\nVar\n\n\n\nmashdistance\n(\nsketch1\n,\n \nsketch2\n)\n\n\n\n\n\n\nFor more information on what size kmers and what size sketches are appropriate for your use-case, see \nOdnov et. al.\n in \nGenome Biology\n.", 
            "title": "Genetic Variation"
        }, 
        {
            "location": "/man/var/#biovar-biological-variation", 
            "text": "", 
            "title": "Bio.Var: Biological Variation."
        }, 
        {
            "location": "/man/var/#identifying-and-counting-sequence-sites", 
            "text": "You can identify and count the number of various types of site in a nucleotide sequence, or pair/set of aligned nucleotide sequences.", 
            "title": "Identifying and counting sequence sites"
        }, 
        {
            "location": "/man/var/#different-types-of-site", 
            "text": "", 
            "title": "Different types of site"
        }, 
        {
            "location": "/man/var/#the-abstract-site-types", 
            "text": "Site\nMutation", 
            "title": "The abstract Site types"
        }, 
        {
            "location": "/man/var/#the-concrete-types-of-site-case", 
            "text": "The types of mutations that can currently be counted are summarized below:  #  Bio.Var.Gap     Type .  An  Gap  site describes a site where either of two aligned sites are a gap symbol '-'.  source  #  Bio.Var.Ambiguous     Type .  An  Ambiguous  site describes a site where either of two aligned sites are an ambiguity symbol.  source  #  Bio.Var.Certain     Type .  A  Certain  site describes a site where both of two aligned sites are not an ambiguity symbol or a gap.  source  #  Bio.Var.Match     Type .  A  Match  site describes a site where two aligned nucleotides are the same biological symbol.  source  #  Bio.Var.Mismatch     Type .  A  Mismatch  site describes a site where two aligned nucleotides are not the same biological symbol.  source  #  Bio.Var.Conserved     Type .  A  Mismatch  site describes a site where two aligned nucleotides are definately conserved. By definately conserved this means that the symbols of the site are non-ambiguity symbols, and they are the same symbol.  source  #  Bio.Var.Mutated     Type .  A  Mutated  site describes a site where two aligned nucleotides are definately mutated. By definately mutated this means that the symbols of the site are non-ambiguity symbols, and they are not the same symbol.  source  #  Bio.Var.Transition     Type .  A  Transition  site describes a site where two aligned nucleotides are definately mutated, and the type of mutation is a transition mutation. In other words, the symbols must not be ambiguity symbols, and they must be different such that they constitute a transition mutation: i.e. A - G, or C - T.  source  #  Bio.Var.Transversion     Type .  A  Transversion  site describes a site where two aligned nucleotides are definately mutated, and the type of mutation is a transversion mutation. In other words, the symbols must not be ambiguity symbols, and they must be different such that they constitute a transversion mutation: i.e. A - C, A - T, G - T, G - C.  source", 
            "title": "The concrete types of site case"
        }, 
        {
            "location": "/man/var/#the-count_sites-method", 
            "text": "#  Bio.Var.count_sites     Function .  count_sites{T :Site}(::Type{T}, a::BioSequence, b::BioSequence)  Mutations are counted using the  count_sites  method.  If the concrete site case type inherits from NoPairDel, then the result will be a simple integer value of the number of counts of site.  If the concrete site case type inherits from PairDel, then the result will be a tuple. As a result, counting methods for such types also count and return the number of sites which could not be unambiguously determined. This second count is important for some downstream purposes, for example evolutionary/genetic distance computations in which pairwise deletion of ambiguous sites is necessary.  source  count_sites{T :NoPairDel}(::Type{T}, a::EachWindowIterator, b::EachWindowIterator)  A method of the count_sites function for counting sites of SiteType  T  between two aligned sequences.  Crucially, this method accepts two EachWindowIterators as parameters  a  and  b  instead of two  BioSequence s. As a result, the two sequences are iterated over with a sliding window, and a site count computed for each window.  This function returns two vectors, one with the ranges  source  Count the number of sites between two nucleotide sequences using a sliding window.  source  Count the number of mutations between nucleotide sequences in a pairwise manner.  source  Count the number of mutations between nucleotide sequences in a pairwise manner, using a sliding window of a given width and step.  source  Count the number of mutations between nucleotide sequences in a pairwise manner.  source  Count the number of mutations between nucleotide sequences in a pairwise manner, using a sliding window of a given width and step.  source  Count the number of sites of a given SiteType  T  in a biological sequence.  source  count_sites ( Match ,   [ dna ATCGATCG ,   dna ACCGATCG ])  count_sites ( Mismatch ,   [ dna ATCGATCG ,   dna ACCGATCG ])  count_sites ( Conserved ,   [ dna ATCGATCG ,   dna ACCGATCG ])  count_sites ( Mutated ,   [ dna ATCGATCG ,   dna ACCGATCG ])  count_sites ( Transition ,   [ rna AUCGAUCG ,   rna ACCGAUCG ])  count_sites ( Transversion ,   [ rna AUCGAUCG ,   rna ACCGAUCG ])", 
            "title": "The count_sites method"
        }, 
        {
            "location": "/man/var/#file-formats-for-representing-genetic-variation", 
            "text": "This module supports some common file formats to read and write genetic variations.", 
            "title": "File formats for representing genetic variation"
        }, 
        {
            "location": "/man/var/#vcf-and-bcf-file-formats", 
            "text": "VCF and BCF file formats can be read using  VCFReader  and  BCFReader , respectively:  reader   =   open ( VCFReader ,   example.vcf )  for   record   in   reader \n     # do something  end  close ( reader )   A reader first reads the header section of a file and creates a  VCFHeader  object. The  header  function is provided to access the header object of a reader:  julia   header ( reader )  Bio.Var.VCFHeader:    metainfo tags: fileformat fileDate source reference contig phasing INFO FILTER FORMAT       sample IDs: NA00001 NA00002 NA00003  julia   find ( header ( reader ),   FORMAT )  4-element Array{Bio.Var.VCFMetaInfo,1}:   Bio.Var.VCFMetaInfo:      tag: FORMAT    value: ID= GT  Number= 1  Type= String  Description= Genotype   Bio.Var.VCFMetaInfo:      tag: FORMAT    value: ID= GQ  Number= 1  Type= Integer  Description= Genotype Quality   Bio.Var.VCFMetaInfo:      tag: FORMAT    value: ID= DP  Number= 1  Type= Integer  Description= Read Depth   Bio.Var.VCFMetaInfo:      tag: FORMAT    value: ID= HQ  Number= 2  Type= Integer  Description= Haplotype Quality   VCFMetaInfo  objects in the header support the following accessor functions:     Accessor  Description      metainfotag  tag string    metainfoval  value string    keys  keys of fields between ' ' and ' '    values  values of fields between ' ' and ' '    [ key ]  value of a field with  key     julia   metainfo   =   VCFMetaInfo ( ##FORMAT= ID=GT,Number=1,Type=String,Description= \\ Genotype \\ )  Bio.Var.VCFMetaInfo:      tag: FORMAT    value: ID= GT  Number= 1  Type= String  Description= Genotype  julia   metainfotag ( metainfo )  FORMAT  julia   metainfoval ( metainfo )  ID=GT,Number=1,Type=String,Description=\\ Genotype\\  julia   keys ( metainfo )  4-element Array{String,1}:    ID    Number    Type    Description  julia   metainfo [ ID ]  GT   VCFRecord  and  BCFRecord  objects support the following accessor functions (see the docstring of each accessor for the details):     Accessor  Description      chromosome  chromosome name    leftposition  reference position    identifier  unique identifiers    reference  reference bases    alternate  alternate bases    quality  Phred-scaled quality score    filter_  filter status    information  additional information    infokeys  keys of additional information    format  genotype format    genotype  genotype information     julia   record   =   VCFRecord ( 20 \\t 14370 \\t rs6054257 \\t G \\t A \\t 29 \\t PASS \\t NS=3;DP=14;AF=0.5;DB;H2 \\t GT:GQ:DP:HQ \\t 0|0:48:1:51,51 \\t 1|0:48:8:51,51 )  Bio.Var.VCFRecord:     chromosome: 20       position: 14370     identifier: rs6054257      reference: G      alternate: A        quality: 29.0         filter: PASS    information: NS=3 DP=14 AF=0.5 DB H2         format: GT GQ DP HQ       genotype: [1] 0|0 48 1 51,51 [2] 1|0 48 8 51,51  julia   chromosome ( record )  Nullable{String}( 20 )  julia   leftposition ( record )  Nullable{Int64}(14370)  julia   identifier ( record )  1-element Array{String,1}:    rs6054257  julia   reference ( record )  Nullable{String}( G )  julia   alternate ( record )  1-element Array{String,1}:    A  julia   quality ( record )  Nullable{Float64}(29.0)  julia   filter_ ( record )  1-element Array{String,1}:    PASS  julia   information ( record )  5-element Array{Pair{String,String},1}:    NS = 3    DP = 14    AF = 0.5    DB =    H2 =  julia   information ( record ,   AF )  0.5  julia   format ( record )  4-element Array{String,1}:    GT    GQ    DP    HQ  julia   genotype ( record )  2-element Array{Array{String,1},1}:   String[ 0|0 , 48 , 1 , 51,51 ]   String[ 1|0 , 48 , 8 , 51,51 ]  julia   genotype ( record ,   1 )  4-element Array{String,1}:    0|0    48    1    51,51  julia   genotype ( record ,   1 : 2 ,   GT )  2-element Array{String,1}:    0|0    1|0", 
            "title": "VCF and BCF file formats"
        }, 
        {
            "location": "/man/var/#mash-distances", 
            "text": "MASH distances , based on MinHash sketches of genome sequences can provide rapid genome-scale sequence comparisons when sequence distance (not specific mutations) are all that's required.  A MinHash sketch is made by taking the  s  smallest hash values for kmers of length  k  for a given sequence. The genome distance for two genomes is then essentially the  Jaccard index  of the minhashes, with some additional modification to account for the size of the kmers used.  You can generate a MinHash sketch using the  minhash()  function in  Bio.seq .  using   Bio . Seq  seq1   =   dna AAATAAGGCACAACTATGCAT  sketch1   =   minhash ( seq ,   5 ,   10 )   Then, if you have MinHash sketches with the same parameters for two sequences, you can determine the MASH distance between them.  seq2   =   dna AATTAACGCACGGACTGCGGTAAT  sketch2   =   minhash ( seq ,   5 ,   10 )  using   Bio . Var  mashdistance ( sketch1 ,   sketch2 )   For more information on what size kmers and what size sketches are appropriate for your use-case, see  Odnov et. al.  in  Genome Biology .", 
            "title": "MASH Distances"
        }, 
        {
            "location": "/man/phylo/", 
            "text": "Bio.Phylo: Phylogenetic trees and networks\n\n\nThe \nBio.Phylo\n module is for data types and methods for handling phylogenetic trees and networks.\n\n\n\n\nPhylogenies\n\n\n#\n\n\nPhylogenies.Phylogeny\n \n \nType\n.\n\n\nPhylogeny represents a phylogenetic tree.\n\n\nThe type is parametric with two parameters \nC\n and \nB\n.\n\n\nThis is because it is common to want to annotate tips, clades, and branches in a phylogeny with data to create a richer model of evolution of do other things like dictate aesthetic values when plotting.\n\n\nType parameter \nC\n dictates what datatype can be stored in the phylogeny to annotate clades and tips. Type parameter \nB\n dictates what datatype can be stored in the phylogeny to annotate branches. Think \nC\n for clades and \nB\n for branches.\n\n\nsource\n\n\n\n\nConstructors\n\n\nYou can create a very simple unresolved phylogeny (a star phylogeny) by providing the tips as a vector of strings or a vector of symbols.\n\n\ntips\n \n=\n \n[\n:\nA\n,\n \n:\nB\n,\n \n:\nC\n]\n\n\ntree\n \n=\n \nPhylogeny\n(\ntips\n)\n\n\n\n\n\n\nPhylogenies.Phylogeny{Float64,Phylogenies.BasicBranch}({5, 3} directed graph,Phylogenies.Indexer{Int64}(Dict(:C=\n3,:B=\n2,:A=\n1,:Root=\n4),Symbol[:A,:B,:C,:Root]),Float64[],Dict{Pair{Int64,Int64},Phylogenies.BasicBranch}(),3,false,true)\n\n\n\n\n\ntips\n \n=\n \n[\nA\n,\n \nB\n,\n \nC\n]\n\n\ntree\n \n=\n \nPhylogeny\n(\ntips\n)\n\n\n\n\n\n\nPhylogenies.Phylogeny{Float64,Phylogenies.BasicBranch}({5, 3} directed graph,Phylogenies.Indexer{Int64}(Dict(:C=\n3,:B=\n2,:A=\n1,:Root=\n4),Symbol[:A,:B,:C,:Root]),Float64[],Dict{Pair{Int64,Int64},Phylogenies.BasicBranch}(),3,false,true)\n\n\n\n\n\n\n\nRoots\n\n\nYou can test whether such a phylogeny is rooted, is re-rootable, and get the root vertex of a phylogeny. You can also test if a vertex of a phylogeny is a root.\n\n\n#\n\n\nPhylogenies.isrooted\n \n \nFunction\n.\n\n\nisrooted(x::Phylogeny)\n\n\n\n\n\nTest whether a Phylogeny is rooted.\n\n\nExamples\n\n\nisrooted\n(\nmy_phylogeny\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylogenies.isrerootable\n \n \nFunction\n.\n\n\nisrerootable(x::Phylogeny)\n\n\n\n\n\nTest whether a Phylogeny is re-rootable.\n\n\nExamples\n\n\nisrerootable\n(\nmy_phylogeny\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylogenies.root\n \n \nFunction\n.\n\n\nGet the vertex of the tree which represents the root of the tree.\n\n\nsource\n\n\nisrooted\n(\ntree\n)\n\n\n\n\n\n\nfalse\n\n\n\n\n\nisrerootable\n(\ntree\n)\n\n\n\n\n\n\ntrue\n\n\n\n\n\nroot\n(\ntree\n)\n\n\n\n\n\n\n4\n\n\n\n\n\n\n\nDivergence time estimation\n\n\nPhylo\n has a submodule called \nDating\n which contains methods for divergence time estimation between sequences.\n\n\n\n\nDating methods\n\n\nCurrently \nPhylo.Dating\n has two types which are used as function arguments to dictate how to compute coalescence times. They all inherit from the abstract data type \nDatingMethod\n.\n\n\nDating.SimpleEstimate\nDating.SpeedDating", 
            "title": "Phylogenetic Trees"
        }, 
        {
            "location": "/man/phylo/#biophylo-phylogenetic-trees-and-networks", 
            "text": "The  Bio.Phylo  module is for data types and methods for handling phylogenetic trees and networks.", 
            "title": "Bio.Phylo: Phylogenetic trees and networks"
        }, 
        {
            "location": "/man/phylo/#phylogenies", 
            "text": "#  Phylogenies.Phylogeny     Type .  Phylogeny represents a phylogenetic tree.  The type is parametric with two parameters  C  and  B .  This is because it is common to want to annotate tips, clades, and branches in a phylogeny with data to create a richer model of evolution of do other things like dictate aesthetic values when plotting.  Type parameter  C  dictates what datatype can be stored in the phylogeny to annotate clades and tips. Type parameter  B  dictates what datatype can be stored in the phylogeny to annotate branches. Think  C  for clades and  B  for branches.  source", 
            "title": "Phylogenies"
        }, 
        {
            "location": "/man/phylo/#constructors", 
            "text": "You can create a very simple unresolved phylogeny (a star phylogeny) by providing the tips as a vector of strings or a vector of symbols.  tips   =   [ : A ,   : B ,   : C ]  tree   =   Phylogeny ( tips )   Phylogenies.Phylogeny{Float64,Phylogenies.BasicBranch}({5, 3} directed graph,Phylogenies.Indexer{Int64}(Dict(:C= 3,:B= 2,:A= 1,:Root= 4),Symbol[:A,:B,:C,:Root]),Float64[],Dict{Pair{Int64,Int64},Phylogenies.BasicBranch}(),3,false,true)  tips   =   [ A ,   B ,   C ]  tree   =   Phylogeny ( tips )   Phylogenies.Phylogeny{Float64,Phylogenies.BasicBranch}({5, 3} directed graph,Phylogenies.Indexer{Int64}(Dict(:C= 3,:B= 2,:A= 1,:Root= 4),Symbol[:A,:B,:C,:Root]),Float64[],Dict{Pair{Int64,Int64},Phylogenies.BasicBranch}(),3,false,true)", 
            "title": "Constructors"
        }, 
        {
            "location": "/man/phylo/#roots", 
            "text": "You can test whether such a phylogeny is rooted, is re-rootable, and get the root vertex of a phylogeny. You can also test if a vertex of a phylogeny is a root.  #  Phylogenies.isrooted     Function .  isrooted(x::Phylogeny)  Test whether a Phylogeny is rooted.  Examples  isrooted ( my_phylogeny )   source  #  Phylogenies.isrerootable     Function .  isrerootable(x::Phylogeny)  Test whether a Phylogeny is re-rootable.  Examples  isrerootable ( my_phylogeny )   source  #  Phylogenies.root     Function .  Get the vertex of the tree which represents the root of the tree.  source  isrooted ( tree )   false  isrerootable ( tree )   true  root ( tree )   4", 
            "title": "Roots"
        }, 
        {
            "location": "/man/phylo/#divergence-time-estimation", 
            "text": "Phylo  has a submodule called  Dating  which contains methods for divergence time estimation between sequences.", 
            "title": "Divergence time estimation"
        }, 
        {
            "location": "/man/phylo/#dating-methods", 
            "text": "Currently  Phylo.Dating  has two types which are used as function arguments to dictate how to compute coalescence times. They all inherit from the abstract data type  DatingMethod .  Dating.SimpleEstimate\nDating.SpeedDating", 
            "title": "Dating methods"
        }, 
        {
            "location": "/man/structure/", 
            "text": "Bio.Structure: Macromolecular Structures\n\n\nThe \nBio.Structure\n module provides functionality to manipulate macromolecular structures, and in particular to read and write \nProtein Data Bank\n (PDB) files. It is designed to be used for standard structural analysis tasks, as well as acting as a platform on which others can build to create more specific tools. It compares favourably in terms of performance to other PDB parsers - see some \nbenchmarks\n.\n\n\n\n\nParsing PDB files\n\n\nTo download a PDB file:\n\n\ndownloadpdb\n(\n1EN2\n)\n\n\n\n\n\n\nTo parse a PDB file into a Structure-Model-Chain-Residue-Atom framework:\n\n\njulia\n \nstruc\n \n=\n \nread\n(\nfilepath_1EN2\n,\n \nPDB\n)\n\n\nBio\n.\nStructure\n.\nProteinStructure\n\n\nName\n                        \n-\n  \n1\nEN2\n.\npdb\n\n\nNumber\n \nof\n \nmodels\n            \n-\n  \n1\n\n\nChain\n(\ns\n)\n                    \n-\n  \nA\n\n\nNumber\n \nof\n \nresidues\n          \n-\n  \n85\n\n\nNumber\n \nof\n \npoint\n \nmutations\n   \n-\n  \n5\n\n\nNumber\n \nof\n \nother\n \nmolecules\n   \n-\n  \n5\n\n\nNumber\n \nof\n \nwater\n \nmolecules\n   \n-\n  \n76\n\n\nNumber\n \nof\n \natoms\n             \n-\n  \n614\n\n\nNumber\n \nof\n \nhydrogens\n         \n-\n  \n0\n\n\nNumber\n \nof\n \ndisordered\n \natoms\n  \n-\n  \n27\n\n\n\n\n\n\nThe elements of \nstruc\n can be accessed as follows:\n\n\n\n\n\n\n\n\nCommand\n\n\nReturns\n\n\nReturn type\n\n\n\n\n\n\n\n\n\n\nstruc[1]\n\n\nModel 1\n\n\nModel\n\n\n\n\n\n\nstruc[1]['A']\n\n\nModel 1, chain A\n\n\nChain\n\n\n\n\n\n\nstruc['A']\n\n\nThe lowest model (model 1), chain A\n\n\nChain\n\n\n\n\n\n\nstruc['A'][\"50\"]\n\n\nModel 1, chain A, residue 50\n\n\nAbstractResidue\n\n\n\n\n\n\nstruc['A'][50]\n\n\nShortcut to above if it is not a hetero residue and the insertion code is blank\n\n\nAbstractResidue\n\n\n\n\n\n\nstruc['A'][\"H_90\"]\n\n\nModel 1, chain A, hetero residue 90\n\n\nAbstractResidue\n\n\n\n\n\n\nstruc['A'][50][\"CA\"]\n\n\nModel 1, chain A, residue 50, atom name CA\n\n\nAbstractAtom\n\n\n\n\n\n\nstruc['A'][15][\"CG\"]['A']\n\n\nFor disordered atoms, access a specific location\n\n\nAtom\n\n\n\n\n\n\n\n\nDisordered atoms are stored in a \nDisorderedAtom\n container but calls fall back to the default atom, so disorder can be ignored if you are not interested in it.\n\n\nDisordered residues (i.e. point mutations with different residue names) are stored in a \nDisorderedResidue\n container.\n\n\nThe idea is that disorder will only bother you if you want it to. See the \nBiopython discussion\n for more.\n\n\nProperties can be retrieved as follows:\n\n\n\n\n\n\n\n\nFunction\n\n\nReturns\n\n\nReturn type\n\n\n\n\n\n\n\n\n\n\nserial\n\n\nSerial number of an atom\n\n\nInt\n\n\n\n\n\n\natomname\n\n\nName of an atom\n\n\nString\n\n\n\n\n\n\naltlocid\n\n\nAlternative location ID of an atom\n\n\nChar\n\n\n\n\n\n\nx\n\n\nx coordinate of an atom\n\n\nFloat64\n\n\n\n\n\n\ny\n\n\ny coordinate of an atom\n\n\nFloat64\n\n\n\n\n\n\nz\n\n\nz coordinate of an atom\n\n\nFloat64\n\n\n\n\n\n\ncoords\n\n\ncoordinates of an atom\n\n\nArray{Float64,1}\n\n\n\n\n\n\noccupancy\n\n\nOccupancy of an atom (default is \n1.0\n)\n\n\nFloat64\n\n\n\n\n\n\ntempfactor\n\n\nTemperature factor of an atom (default is \n0.0\n)\n\n\nFloat64\n\n\n\n\n\n\nelement\n\n\nElement of an atom (default is \n\"  \"\n)\n\n\nString\n\n\n\n\n\n\ncharge\n\n\nCharge of an atom (default is \n\"  \"\n)\n\n\nString\n\n\n\n\n\n\nresidue\n\n\nResidue an atom belongs to\n\n\nResidue\n\n\n\n\n\n\nishetero\n\n\ntrue\n if the residue or atom is a hetero residue/atom\n\n\nBool\n\n\n\n\n\n\nisdisorderedatom\n\n\ntrue\n if the atom is disordered\n\n\nBool\n\n\n\n\n\n\npdbline\n\n\nPDB ATOM/HETATM record for an atom\n\n\nString\n\n\n\n\n\n\nresname\n\n\nResidue name of a residue or atom\n\n\nString\n\n\n\n\n\n\nresnumber\n\n\nResidue number of a residue or atom\n\n\nInt\n\n\n\n\n\n\ninscode\n\n\nInsertion code of a residue or atom\n\n\nChar\n\n\n\n\n\n\nresid\n\n\nResidue ID of an atom or residue (\nfull=true\n includes chain)\n\n\nString\n\n\n\n\n\n\natomnames\n\n\nAtom names of the atoms in a residue, sorted by serial\n\n\nArray{String,1}\n\n\n\n\n\n\natoms\n\n\nDictionary of atoms in a residue\n\n\nDict{String, AbstractAtom}\n\n\n\n\n\n\nisdisorderedres\n\n\ntrue\n if the residue has multiple residue names\n\n\nBool\n\n\n\n\n\n\ndisorderedres\n\n\nAccess a particular residue name in a \nDisorderedResidue\n\n\nResidue\n\n\n\n\n\n\nchain\n\n\nChain a residue or atom belongs to\n\n\nChain\n\n\n\n\n\n\nchainid\n\n\nChain ID of a chain, residue or atom\n\n\nChar\n\n\n\n\n\n\nresids\n\n\nSorted residue IDs in a chain\n\n\nArray{String,1}\n\n\n\n\n\n\nresidues\n\n\nDictionary of residues in a chain\n\n\nDict{String, AbstractResidue}\n\n\n\n\n\n\nmodel\n\n\nModel a chain, residue or atom belongs to\n\n\nModel\n\n\n\n\n\n\nmodelnumber\n\n\nModel number of a model, chain, residue or atom\n\n\nInt\n\n\n\n\n\n\nchainids\n\n\nSorted chain IDs in a model or structure\n\n\nArray{Char,1}\n\n\n\n\n\n\nchains\n\n\nDictionary of chains in a model or structure\n\n\nDict{Char, Chain}\n\n\n\n\n\n\nstructure\n\n\nStructure a model, chain, residue or atom belongs to\n\n\nProteinStructure\n\n\n\n\n\n\nstructurename\n\n\nName of the structure an element belongs to\n\n\nString\n\n\n\n\n\n\nmodelnumbers\n\n\nSorted model numbers in a structure\n\n\nArray{Int,1}\n\n\n\n\n\n\nmodels\n\n\nDictionary of models in a structure\n\n\nDict{Int, Model}\n\n\n\n\n\n\n\n\nThe \nstrip\n keyword argument determines whether surrounding whitespace is stripped for \natomname\n, \nelement\n, \ncharge\n, \nresname\n and \natomnames\n (default \ntrue\n).\n\n\nThe coordinates of an atom can be set using \nx!\n, \ny!\n, \nz!\n and \ncoords!\n.\n\n\n\n\nManipulating structures\n\n\nElements can be looped over to reveal the sub-elements in the correct order:\n\n\nfor\n \nmod\n \nin\n \nstruc\n\n    \nfor\n \nch\n \nin\n \nmod\n\n        \nfor\n \nres\n \nin\n \nch\n\n            \nfor\n \nat\n \nin\n \nres\n\n                \n# Do something\n\n            \nend\n\n        \nend\n\n    \nend\n\n\nend\n\n\n\n\n\n\nModels are ordered numerically; chains are ordered by character, except the empty chain is last; residues are ordered by residue number and insertion code with hetero residues after standard residues; atoms are ordered by atom serial.\n\n\ncollect\n can be used to get arrays of sub-elements. \ncollectatoms\n, \ncollectresidues\n, \ncollectchains\n and \ncollectmodels\n return arrays of a particular type from a structural element or element array.\n\n\nSelectors are functions passed as additional arguments to these functions. Only elements that return \ntrue\n when passed to the selector are retained. For example:\n\n\n\n\n\n\n\n\nCommand\n\n\nAction\n\n\nReturn type\n\n\n\n\n\n\n\n\n\n\ncollect(struc['A'][50])\n\n\nCollect the sub-elements of an element, e.g. atoms from a residue\n\n\nArray{AbstractAtom,1}\n\n\n\n\n\n\ncollectresidues(struc)\n\n\nCollect the residues of an element\n\n\nArray{AbstractResidue,1}\n\n\n\n\n\n\ncollectatoms(struc)\n\n\nCollect the atoms of an element\n\n\nArray{AbstractAtom,1}\n\n\n\n\n\n\ncollectatoms(struc, calphaselector)\n\n\nCollect the C-alpha atoms of an element\n\n\nArray{AbstractAtom,1}\n\n\n\n\n\n\ncollectatoms(struc, calphaselector, disorderselector)\n\n\nCollect the disordered C-alpha atoms of an element\n\n\nArray{AbstractAtom,1}\n\n\n\n\n\n\n\n\nThe selectors available are:\n\n\n\n\n\n\n\n\nFunction\n\n\nActs on\n\n\nSelects for\n\n\n\n\n\n\n\n\n\n\nstandardselector\n\n\nAbstractAtom\n or \nAbstractResidue\n\n\nAtoms/residues arising from standard (ATOM) records\n\n\n\n\n\n\nheteroselector\n\n\nAbstractAtom\n or \nAbstractResidue\n\n\nAtoms/residues arising from hetero (HETATM) records\n\n\n\n\n\n\natomnameselector\n\n\nAbstractAtom\n\n\nAtoms with atom name in a given list\n\n\n\n\n\n\ncalphaselector\n\n\nAbstractAtom\n\n\nC-alpha atoms\n\n\n\n\n\n\ncbetaselector\n\n\nAbstractAtom\n\n\nC-beta atoms, or C-alpha atoms for glycine residues\n\n\n\n\n\n\nbackboneselector\n\n\nAbstractAtom\n\n\nAtoms in the protein backbone (CA, N and C)\n\n\n\n\n\n\nheavyatomselector\n\n\nAbstractAtom\n\n\nNon-hydrogen atoms\n\n\n\n\n\n\nhydrogenselector\n\n\nAbstractAtom\n\n\nHydrogen atoms\n\n\n\n\n\n\nresnameselector\n\n\nAbstractAtom\n or \nAbstractResidue\n\n\nAtoms/residues with residue name in a given list\n\n\n\n\n\n\nwaterselector\n\n\nAbstractAtom\n or \nAbstractResidue\n\n\nAtoms/residues with residue name HOH\n\n\n\n\n\n\nnotwaterselector\n\n\nAbstractAtom\n or \nAbstractResidue\n\n\nAtoms/residues with residue name not HOH\n\n\n\n\n\n\ndisorderselector\n\n\nAbstractAtom\n or \nAbstractResidue\n\n\nAtoms/residues with alternative locations\n\n\n\n\n\n\n\n\nIt is easy to define your own atom, residue, chain or model selectors. The below will collect all atoms with x coordinate less than 0:\n\n\nxselector\n(\nat\n::\nAbstractAtom\n)\n \n=\n \nx\n(\nat\n)\n \n \n0\n\n\ncollectatoms\n(\nstruc\n,\n \nxselector\n)\n\n\n\n\n\n\nAlternatively, you can use an anonymous function:\n\n\ncollectatoms\n(\nstruc\n,\n \nat\n \n-\n \nx\n(\nat\n)\n \n \n0\n)\n\n\n\n\n\n\ncountatoms\n, \ncountresidues\n, \ncountchains\n and \ncountmodels\n can be used to count elements. For example:\n\n\njulia\n \ncountatoms\n(\nstruc\n)\n\n\n754\n\n\n\njulia\n \ncountatoms\n(\nstruc\n,\n \ncalphaselector\n)\n\n\n85\n\n\n\njulia\n \ncountresidues\n(\nstruc\n,\n \nstandardselector\n)\n\n\n85\n\n\n\n\n\n\nThe sequence of a protein can be retrieved by passing a \nChain\n or array of residues to \nAminoAcidSequence\n:\n\n\njulia\n \nAminoAcidSequence\n(\nstruc\n[\nA\n],\n \nstandardselector\n)\n\n\n85\naa\n \nAmino\n \nAcid\n \nSequence\n:\n\n\nRCGSQGGGSTCPGLRCCSIWGWCGDSEPYCGRTCENKCWSGERSDHRCGAAVGNPPCGQDRCCSVHGWCGGGNDYCSGGNCQYRC\n\n\n\n\n\n\n\n\nWriting PDB files\n\n\nPDB format files can be written:\n\n\nwritepdb\n(\n1EN2_out.pdb\n,\n \nstruc\n)\n\n\n\n\n\n\nAny element type can be given as input to \nwritepdb\n. Atom selectors can also be given as additional arguments:\n\n\nwritepdb\n(\n1EN2_out.pdb\n,\n \nstruc\n,\n \nbackboneselector\n)\n\n\n\n\n\n\n\n\nSpatial calculations\n\n\nVarious functions are provided to calculate spatial quantities for proteins:\n\n\n\n\n\n\n\n\nCommand\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\ndistance\n\n\nMinimum distance between two elements\n\n\n\n\n\n\nsqdistance\n\n\nMinimum square distance between two elements\n\n\n\n\n\n\nbondangle\n\n\nAngle between three atoms\n\n\n\n\n\n\ndihedralangle\n\n\nDihedral angle defined by four atoms\n\n\n\n\n\n\nomegaangle\n\n\nOmega angle between a residue and the previous residue\n\n\n\n\n\n\nphiangle\n\n\nPhi angle between a residue and the previous residue\n\n\n\n\n\n\npsiangle\n\n\nPsi angle between a residue and the next residue\n\n\n\n\n\n\nramachandranangles\n\n\nVector\ns of phi and psi angles of an element\n\n\n\n\n\n\ncontactmap\n\n\nContact map of two elements, or one element with itself\n\n\n\n\n\n\nrmsd\n\n\nRMSD between two elements of the same size - assumes they are superimposed\n\n\n\n\n\n\ndisplacements\n\n\nVector\n of displacements between two elements of the same size - assumes they are superimposed\n\n\n\n\n\n\n\n\nFor example:\n\n\njulia\n \ndistance\n(\nstruc\n[\nA\n][\n10\n],\n \nstruc\n[\nA\n][\n20\n])\n\n\n10.782158874733762\n\n\n\njulia\n \nrad2deg\n(\nbondangle\n(\nstruc\n[\nA\n][\n50\n][\nN\n],\n \nstruc\n[\nA\n][\n50\n][\nCA\n],\n \nstruc\n[\nA\n][\n50\n][\nC\n]))\n\n\n110.77765846083398\n\n\n\njulia\n \nrad2deg\n(\ndihedralangle\n(\nstruc\n[\nA\n][\n50\n][\nN\n],\n \nstruc\n[\nA\n][\n50\n][\nCA\n],\n \nstruc\n[\nA\n][\n50\n][\nC\n],\n \nstruc\n[\nA\n][\n51\n][\nN\n]))\n\n\n-\n177.38288114072924\n\n\n\njulia\n \nrad2deg\n(\npsiangle\n(\nstruc\n[\nA\n][\n50\n],\n \nstruc\n[\nA\n][\n51\n]))\n\n\n-\n177.38288114072924\n\n\n\n\n\n\n\n\nExamples\n\n\nA few further examples of \nBio.Structure\n usage are given below.\n\n\nA)\n To plot the temperature factors of a protein, if you have Gadfly installed:\n\n\nusing\n \nGadfly\n\n\ncalphas\n \n=\n \ncollectatoms\n(\nstruc\n,\n \ncalphaselector\n)\n\n\nplot\n(\nx\n=\nresnumber\n.\n(\ncalphas\n),\n\n     \ny\n=\ntempfactor\n.\n(\ncalphas\n),\n\n     \nGuide\n.\nxlabel\n(\nResidue number\n),\n\n     \nGuide\n.\nylabel\n(\nTemperature factor\n),\n\n     \nGeom\n.\nline\n)\n\n\n\n\n\n\nB)\n To print the PDB records for all C-alpha atoms within 5 Angstroms of residue 38:\n\n\nfor\n \nat\n \nin\n \ncalphas\n\n    \nif\n \ndistance\n(\nstruc\n[\nA\n][\n38\n],\n \nat\n)\n \n \n5.0\n \n \nresnumber\n(\nat\n)\n \n!=\n \n38\n\n        \nprintln\n(\npdbline\n(\nat\n))\n\n    \nend\n\n\nend\n\n\n\n\n\n\nD)\n To view the contact map of a structure:\n\n\ncbetas\n \n=\n \ncollectatoms\n(\nstruc\n,\n \ncbetaselector\n)\n\n\ncontacts\n \n=\n \ncontactmap\n(\ncbetas\n,\n \n7.0\n)\n\n\nfor\n \ni\n \nin\n \n1\n:\nlength\n(\ncbetas\n)\n\n    \nfor\n \nj\n \nin\n \n1\n:\nlength\n(\ncbetas\n)\n\n        \nif\n \ncontacts\n[\ni\n,\nj\n]\n\n            \nprint\n(\n\u2588\n)\n\n        \nelse\n\n            \nprint\n(\n \n)\n\n        \nend\n\n    \nend\n\n    \nprintln\n()\n\n\nend\n\n\n\n\n\n\ncontactmap\n can also be given two structural elements as arguments, in which case a non-symmetrical 2D array is returned showing contacts between the elements.\n\n\nE)\n To show the Ramachandran phi/psi angle plot of a structure, if you have Gadfly installed:\n\n\nusing\n \nGadfly\n\n\nphi_angles\n,\n \npsi_angles\n \n=\n \nramachandranangles\n(\nstruc\n,\n \nstandardselector\n)\n\n\nplot\n(\nx\n=\nrad2deg\n.\n(\nphi_angles\n),\n\n     \ny\n=\nrad2deg\n.\n(\npsi_angles\n),\n\n     \nGuide\n.\nxlabel\n(\nPhi / degrees\n),\n\n     \nGuide\n.\nylabel\n(\nPsi / degrees\n),\n\n     \nGuide\n.\nxticks\n(\nticks\n=\n[\n-\n180\n,\n-\n90\n,\n0\n,\n90\n,\n180\n]),\n\n     \nGuide\n.\nyticks\n(\nticks\n=\n[\n-\n180\n,\n-\n90\n,\n0\n,\n90\n,\n180\n]))\n\n\n\n\n\n\nF)\n To calculate the RMSD and displacements between the heavy (non-hydrogen) atoms of two models in an NMR structure:\n\n\ndownloadpdb\n(\n1SSU\n)\n\n\nstruc_nmr\n \n=\n \nread\n(\n1SSU.pdb\n,\n \nPDB\n)\n\n\nrmsd\n(\nstruc_nmr\n[\n5\n],\n \nstruc_nmr\n[\n10\n],\n \nheavyatomselector\n)\n\n\ndisplacements\n(\nstruc_nmr\n[\n5\n],\n \nstruc_nmr\n[\n10\n],\n \nheavyatomselector\n)", 
            "title": "Structure"
        }, 
        {
            "location": "/man/structure/#biostructure-macromolecular-structures", 
            "text": "The  Bio.Structure  module provides functionality to manipulate macromolecular structures, and in particular to read and write  Protein Data Bank  (PDB) files. It is designed to be used for standard structural analysis tasks, as well as acting as a platform on which others can build to create more specific tools. It compares favourably in terms of performance to other PDB parsers - see some  benchmarks .", 
            "title": "Bio.Structure: Macromolecular Structures"
        }, 
        {
            "location": "/man/structure/#parsing-pdb-files", 
            "text": "To download a PDB file:  downloadpdb ( 1EN2 )   To parse a PDB file into a Structure-Model-Chain-Residue-Atom framework:  julia   struc   =   read ( filepath_1EN2 ,   PDB )  Bio . Structure . ProteinStructure  Name                          -    1 EN2 . pdb  Number   of   models              -    1  Chain ( s )                      -    A  Number   of   residues            -    85  Number   of   point   mutations     -    5  Number   of   other   molecules     -    5  Number   of   water   molecules     -    76  Number   of   atoms               -    614  Number   of   hydrogens           -    0  Number   of   disordered   atoms    -    27   The elements of  struc  can be accessed as follows:     Command  Returns  Return type      struc[1]  Model 1  Model    struc[1]['A']  Model 1, chain A  Chain    struc['A']  The lowest model (model 1), chain A  Chain    struc['A'][\"50\"]  Model 1, chain A, residue 50  AbstractResidue    struc['A'][50]  Shortcut to above if it is not a hetero residue and the insertion code is blank  AbstractResidue    struc['A'][\"H_90\"]  Model 1, chain A, hetero residue 90  AbstractResidue    struc['A'][50][\"CA\"]  Model 1, chain A, residue 50, atom name CA  AbstractAtom    struc['A'][15][\"CG\"]['A']  For disordered atoms, access a specific location  Atom     Disordered atoms are stored in a  DisorderedAtom  container but calls fall back to the default atom, so disorder can be ignored if you are not interested in it.  Disordered residues (i.e. point mutations with different residue names) are stored in a  DisorderedResidue  container.  The idea is that disorder will only bother you if you want it to. See the  Biopython discussion  for more.  Properties can be retrieved as follows:     Function  Returns  Return type      serial  Serial number of an atom  Int    atomname  Name of an atom  String    altlocid  Alternative location ID of an atom  Char    x  x coordinate of an atom  Float64    y  y coordinate of an atom  Float64    z  z coordinate of an atom  Float64    coords  coordinates of an atom  Array{Float64,1}    occupancy  Occupancy of an atom (default is  1.0 )  Float64    tempfactor  Temperature factor of an atom (default is  0.0 )  Float64    element  Element of an atom (default is  \"  \" )  String    charge  Charge of an atom (default is  \"  \" )  String    residue  Residue an atom belongs to  Residue    ishetero  true  if the residue or atom is a hetero residue/atom  Bool    isdisorderedatom  true  if the atom is disordered  Bool    pdbline  PDB ATOM/HETATM record for an atom  String    resname  Residue name of a residue or atom  String    resnumber  Residue number of a residue or atom  Int    inscode  Insertion code of a residue or atom  Char    resid  Residue ID of an atom or residue ( full=true  includes chain)  String    atomnames  Atom names of the atoms in a residue, sorted by serial  Array{String,1}    atoms  Dictionary of atoms in a residue  Dict{String, AbstractAtom}    isdisorderedres  true  if the residue has multiple residue names  Bool    disorderedres  Access a particular residue name in a  DisorderedResidue  Residue    chain  Chain a residue or atom belongs to  Chain    chainid  Chain ID of a chain, residue or atom  Char    resids  Sorted residue IDs in a chain  Array{String,1}    residues  Dictionary of residues in a chain  Dict{String, AbstractResidue}    model  Model a chain, residue or atom belongs to  Model    modelnumber  Model number of a model, chain, residue or atom  Int    chainids  Sorted chain IDs in a model or structure  Array{Char,1}    chains  Dictionary of chains in a model or structure  Dict{Char, Chain}    structure  Structure a model, chain, residue or atom belongs to  ProteinStructure    structurename  Name of the structure an element belongs to  String    modelnumbers  Sorted model numbers in a structure  Array{Int,1}    models  Dictionary of models in a structure  Dict{Int, Model}     The  strip  keyword argument determines whether surrounding whitespace is stripped for  atomname ,  element ,  charge ,  resname  and  atomnames  (default  true ).  The coordinates of an atom can be set using  x! ,  y! ,  z!  and  coords! .", 
            "title": "Parsing PDB files"
        }, 
        {
            "location": "/man/structure/#manipulating-structures", 
            "text": "Elements can be looped over to reveal the sub-elements in the correct order:  for   mod   in   struc \n     for   ch   in   mod \n         for   res   in   ch \n             for   at   in   res \n                 # Do something \n             end \n         end \n     end  end   Models are ordered numerically; chains are ordered by character, except the empty chain is last; residues are ordered by residue number and insertion code with hetero residues after standard residues; atoms are ordered by atom serial.  collect  can be used to get arrays of sub-elements.  collectatoms ,  collectresidues ,  collectchains  and  collectmodels  return arrays of a particular type from a structural element or element array.  Selectors are functions passed as additional arguments to these functions. Only elements that return  true  when passed to the selector are retained. For example:     Command  Action  Return type      collect(struc['A'][50])  Collect the sub-elements of an element, e.g. atoms from a residue  Array{AbstractAtom,1}    collectresidues(struc)  Collect the residues of an element  Array{AbstractResidue,1}    collectatoms(struc)  Collect the atoms of an element  Array{AbstractAtom,1}    collectatoms(struc, calphaselector)  Collect the C-alpha atoms of an element  Array{AbstractAtom,1}    collectatoms(struc, calphaselector, disorderselector)  Collect the disordered C-alpha atoms of an element  Array{AbstractAtom,1}     The selectors available are:     Function  Acts on  Selects for      standardselector  AbstractAtom  or  AbstractResidue  Atoms/residues arising from standard (ATOM) records    heteroselector  AbstractAtom  or  AbstractResidue  Atoms/residues arising from hetero (HETATM) records    atomnameselector  AbstractAtom  Atoms with atom name in a given list    calphaselector  AbstractAtom  C-alpha atoms    cbetaselector  AbstractAtom  C-beta atoms, or C-alpha atoms for glycine residues    backboneselector  AbstractAtom  Atoms in the protein backbone (CA, N and C)    heavyatomselector  AbstractAtom  Non-hydrogen atoms    hydrogenselector  AbstractAtom  Hydrogen atoms    resnameselector  AbstractAtom  or  AbstractResidue  Atoms/residues with residue name in a given list    waterselector  AbstractAtom  or  AbstractResidue  Atoms/residues with residue name HOH    notwaterselector  AbstractAtom  or  AbstractResidue  Atoms/residues with residue name not HOH    disorderselector  AbstractAtom  or  AbstractResidue  Atoms/residues with alternative locations     It is easy to define your own atom, residue, chain or model selectors. The below will collect all atoms with x coordinate less than 0:  xselector ( at :: AbstractAtom )   =   x ( at )     0  collectatoms ( struc ,   xselector )   Alternatively, you can use an anonymous function:  collectatoms ( struc ,   at   -   x ( at )     0 )   countatoms ,  countresidues ,  countchains  and  countmodels  can be used to count elements. For example:  julia   countatoms ( struc )  754  julia   countatoms ( struc ,   calphaselector )  85  julia   countresidues ( struc ,   standardselector )  85   The sequence of a protein can be retrieved by passing a  Chain  or array of residues to  AminoAcidSequence :  julia   AminoAcidSequence ( struc [ A ],   standardselector )  85 aa   Amino   Acid   Sequence :  RCGSQGGGSTCPGLRCCSIWGWCGDSEPYCGRTCENKCWSGERSDHRCGAAVGNPPCGQDRCCSVHGWCGGGNDYCSGGNCQYRC", 
            "title": "Manipulating structures"
        }, 
        {
            "location": "/man/structure/#writing-pdb-files", 
            "text": "PDB format files can be written:  writepdb ( 1EN2_out.pdb ,   struc )   Any element type can be given as input to  writepdb . Atom selectors can also be given as additional arguments:  writepdb ( 1EN2_out.pdb ,   struc ,   backboneselector )", 
            "title": "Writing PDB files"
        }, 
        {
            "location": "/man/structure/#spatial-calculations", 
            "text": "Various functions are provided to calculate spatial quantities for proteins:     Command  Returns      distance  Minimum distance between two elements    sqdistance  Minimum square distance between two elements    bondangle  Angle between three atoms    dihedralangle  Dihedral angle defined by four atoms    omegaangle  Omega angle between a residue and the previous residue    phiangle  Phi angle between a residue and the previous residue    psiangle  Psi angle between a residue and the next residue    ramachandranangles  Vector s of phi and psi angles of an element    contactmap  Contact map of two elements, or one element with itself    rmsd  RMSD between two elements of the same size - assumes they are superimposed    displacements  Vector  of displacements between two elements of the same size - assumes they are superimposed     For example:  julia   distance ( struc [ A ][ 10 ],   struc [ A ][ 20 ])  10.782158874733762  julia   rad2deg ( bondangle ( struc [ A ][ 50 ][ N ],   struc [ A ][ 50 ][ CA ],   struc [ A ][ 50 ][ C ]))  110.77765846083398  julia   rad2deg ( dihedralangle ( struc [ A ][ 50 ][ N ],   struc [ A ][ 50 ][ CA ],   struc [ A ][ 50 ][ C ],   struc [ A ][ 51 ][ N ]))  - 177.38288114072924  julia   rad2deg ( psiangle ( struc [ A ][ 50 ],   struc [ A ][ 51 ]))  - 177.38288114072924", 
            "title": "Spatial calculations"
        }, 
        {
            "location": "/man/structure/#examples", 
            "text": "A few further examples of  Bio.Structure  usage are given below.  A)  To plot the temperature factors of a protein, if you have Gadfly installed:  using   Gadfly  calphas   =   collectatoms ( struc ,   calphaselector )  plot ( x = resnumber . ( calphas ), \n      y = tempfactor . ( calphas ), \n      Guide . xlabel ( Residue number ), \n      Guide . ylabel ( Temperature factor ), \n      Geom . line )   B)  To print the PDB records for all C-alpha atoms within 5 Angstroms of residue 38:  for   at   in   calphas \n     if   distance ( struc [ A ][ 38 ],   at )     5.0     resnumber ( at )   !=   38 \n         println ( pdbline ( at )) \n     end  end   D)  To view the contact map of a structure:  cbetas   =   collectatoms ( struc ,   cbetaselector )  contacts   =   contactmap ( cbetas ,   7.0 )  for   i   in   1 : length ( cbetas ) \n     for   j   in   1 : length ( cbetas ) \n         if   contacts [ i , j ] \n             print ( \u2588 ) \n         else \n             print (   ) \n         end \n     end \n     println ()  end   contactmap  can also be given two structural elements as arguments, in which case a non-symmetrical 2D array is returned showing contacts between the elements.  E)  To show the Ramachandran phi/psi angle plot of a structure, if you have Gadfly installed:  using   Gadfly  phi_angles ,   psi_angles   =   ramachandranangles ( struc ,   standardselector )  plot ( x = rad2deg . ( phi_angles ), \n      y = rad2deg . ( psi_angles ), \n      Guide . xlabel ( Phi / degrees ), \n      Guide . ylabel ( Psi / degrees ), \n      Guide . xticks ( ticks = [ - 180 , - 90 , 0 , 90 , 180 ]), \n      Guide . yticks ( ticks = [ - 180 , - 90 , 0 , 90 , 180 ]))   F)  To calculate the RMSD and displacements between the heavy (non-hydrogen) atoms of two models in an NMR structure:  downloadpdb ( 1SSU )  struc_nmr   =   read ( 1SSU.pdb ,   PDB )  rmsd ( struc_nmr [ 5 ],   struc_nmr [ 10 ],   heavyatomselector )  displacements ( struc_nmr [ 5 ],   struc_nmr [ 10 ],   heavyatomselector )", 
            "title": "Examples"
        }, 
        {
            "location": "/man/services/", 
            "text": "Bio.Services: APIs for Web Services\n\n\nThe \nBio.Services\n module provides APIs for various web services.\n\n\n\n\nE-Utilities\n\n\nE-Utilities provide a interface to Entrez databases at \nNCBI\n.  The APIs are defined in the \nBio.Services.EUtils\n module, which exports nine functions to access its databases:\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\neinfo\n\n\nRetrieve a list of databases or statistics for a database.\n\n\n\n\n\n\nesearch\n\n\nRetrieve a list of UIDs matching a text query.\n\n\n\n\n\n\nepost\n\n\nUpload or append a list of UIDs to the Entrez History server.\n\n\n\n\n\n\nesummary\n\n\nRetrieve document summaries for a list of UIDs.\n\n\n\n\n\n\nefetch\n\n\nRetrieve formatted data records for a list of UIDs.\n\n\n\n\n\n\nelink\n\n\nRetrieve UIDs linked to an input set of UIDs.\n\n\n\n\n\n\negquery\n\n\nRetrieve the number of available records in all databases by a text query.\n\n\n\n\n\n\nespell\n\n\nRetrieve spelling suggestions.\n\n\n\n\n\n\necitmatch\n\n\nRetrieve PubMed IDs that correspond to a set of input citation strings.\n\n\n\n\n\n\n\n\n\"The Nine E-utilities in Brief\"\n summarizes all of the server-side programs corresponding to each function.\n\n\nIn this package, queries for databases are controlled by keyword parameters. For example, some functions take \ndb\n parameter to specify the target database. Functions listed above take these parameters as keyword arguments and return a \nResponse\n object as follows:\n\n\njulia\n \nusing\n \nBio\n.\nServices\n.\nEUtils\n      \n# import the nine functions above\n\n\n\njulia\n \nres\n \n=\n \neinfo\n(\ndb\n=\npubmed\n)\n       \n# retrieve statistics of the PubMed database\n\n\nResponse(200 OK, 18 headers, 27360 bytes in body)\n\n\n\njulia\n \nwrite\n(\npubmed.xml\n,\n \nres\n.\ndata\n)\n  \n# save retrieved data into a file\n\n\n27360\n\n\n\nshell\n head result.xml\n\n?xml version=\n1.0\n encoding=\nUTF-8\n ?\n\n\n!DOCTYPE eInfoResult PUBLIC \n-//NLM//DTD einfo 20130322//EN\n \nhttps://eutils.ncbi.nlm.nih.gov/eutils/dtd/20130322/einfo.dtd\n\n\neInfoResult\n\n\n        \nDbInfo\n\n\n        \nDbName\npubmed\n/DbName\n\n\n        \nMenuName\nPubMed\n/MenuName\n\n\n        \nDescription\nPubMed bibliographic record\n/Description\n\n\n        \nDbBuild\nBuild161024-2207m.1\n/DbBuild\n\n\n        \nCount\n26590895\n/Count\n\n\n        \nLastUpdate\n2016/10/25 02:06\n/LastUpdate\n\n\n\n\n\n\nLet's see a few more examples of parameters.  The \nterm\n parameter specifies a search string (e.g. \nesearch(db=\"gene\", term=\"tumor AND human[ORGN]\")\n).  The \nid\n parameter specifies a UID (or accession number) or a list of UIDs (e.g. \nefetch(db=\"protein\", id=\"NP_000537.3\", rettype=\"fasta\")\n, \nefetch(db=\"snp\", id=[\"rs55863639\", \"rs587780067\"])\n). The complete list of parameters can be found at \n\"The E-utilities In-Depth: Parameters, Syntax and More\"\n.\n\n\nWhen a request succeeds the response object has a \ndata\n field containing formatted data, which can be saved to a file as demonstrated above. However, users are often interested in a part of the response data and may want to extract some fields in it. In such a case, \nEzXML.jl\n is helpful because it offers lots of tools to handle XML documents. The first thing you need to do is converting the response data into an XML document by \nparsexml\n:\n\n\njulia\n \nres\n \n=\n \nefetch\n(\ndb\n=\nnuccore\n,\n \nid\n=\nNM_001126.3\n,\n \nretmode\n=\nxml\n)\n\n\nResponse(200 OK, 19 headers, 41536 bytes in body)\n\n\n\njulia\n \nusing\n \nEzXML\n\n\n\njulia\n \ndoc\n \n=\n \nparsexml\n(\nres\n.\ndata\n)\n\n\nEzXML.Document(EzXML.Node(\nDOCUMENT_NODE@0x00007fdd4cc43770\n))\n\n\n\n\n\n\nAfter that, you can query fields you want using \nXPath\n:\n\n\njulia\n \nseq\n \n=\n \nfindfirst\n(\ndoc\n,\n \n/GBSet/GBSeq\n)\n\n\nEzXML.Node(\nELEMENT_NODE@0x00007fdd49f34b10\n)\n\n\n\njulia\n \ncontent\n(\nfindfirst\n(\nseq\n,\n \nGBSeq_definition\n))\n\n\nHomo sapiens adenylosuccinate synthase (ADSS), mRNA\n\n\n\njulia\n \ncontent\n(\nfindfirst\n(\nseq\n,\n \nGBSeq_accession-version\n))\n\n\nNM_001126.3\n\n\n\njulia\n \nlength\n(\nfind\n(\nseq\n,\n \n//GBReference\n))\n\n\n10\n\n\n\njulia\n \nusing\n \nBio\n.\nSeq\n\n\n\njulia\n \nDNASequence\n(\ncontent\n(\nfindfirst\n(\nseq\n,\n \nGBSeq_sequence\n)))\n\n\n2791nt DNA Sequence:\n\n\nACGGGAGTGGCGCGCCAGGCCGCGGAAGGGGCGTGGCCT\u2026TGATTAAAAGAACCAAATATTTCTAGTATGAAAAAAAAA\n\n\n\n\n\n\nEvery function can take a context dictionary as its first argument to set parameters into a query. Key-value pairs in a context are appended to a query in addition to other parameters passed by keyword arguments.  The default context is an empty dictionary that sets no parameters. This context dictionary is especially useful when temporarily caching query UIDs into the Entrez History server. A request to the Entrez system can be associated with cached data using \"WebEnv\" and \"query_key\" parameters. In the following example, the search results of \nesearch\n is saved in the Entrez History server (note \nusehistory=true\n, which makes the server cache its search results) and then their summaries are retrieved in the next call of \nesummary\n:\n\n\njulia\n \ncontext\n \n=\n \nDict\n()\n  \n# create an empty context\n\n\nDict{Any,Any} with 0 entries\n\n\n\njulia\n \nres\n \n=\n \nesearch\n(\ncontext\n,\n \ndb\n=\npubmed\n,\n \nterm\n=\nasthma[mesh] AND leukotrienes[mesh] AND 2009[pdat]\n,\n \nusehistory\n=\ntrue\n)\n\n\nResponse(200 OK, 18 headers, 1574 bytes in body)\n\n\n\njulia\n \ncontext\n  \n# the context dictionary has been updated\n\n\nDict{Any,Any} with 2 entries:\n\n\n  :query_key =\n \n1\n\n\n  :WebEnv    =\n \nNCID_1_9251987_130.14.22.215_9001_1477389145_1960133\u2026\n\n\n\njulia\n \nres\n \n=\n \nesummary\n(\ncontext\n,\n \ndb\n=\npubmed\n)\n  \n# retrieve summaries in context\n\n\nResponse(200 OK, 18 headers, 135463 bytes in body)\n\n\n\njulia\n \nwrite\n(\nasthma_leukotrienes_2009.xml\n,\n \nres\n.\ndata\n)\n  \n# save data into a file\n\n\n135463\n\n\n\nshell\n head asthma_leukotrienes_2009.xml\n\n?xml version=\n1.0\n encoding=\nUTF-8\n ?\n\n\n!DOCTYPE eSummaryResult PUBLIC \n-//NLM//DTD esummary v1 20041029//EN\n \nhttps://eutils.ncbi.nlm.nih.gov/eutils/dtd/20041029/esummary-v1.dtd\n\n\neSummaryResult\n\n\nDocSum\n\n\n        \nId\n20113659\n/Id\n\n\n        \nItem Name=\nPubDate\n Type=\nDate\n2009 Nov\n/Item\n\n\n        \nItem Name=\nEPubDate\n Type=\nDate\n/Item\n\n\n        \nItem Name=\nSource\n Type=\nString\nZhongguo Dang Dai Er Ke Za Zhi\n/Item\n\n\n        \nItem Name=\nAuthorList\n Type=\nList\n\n\n                \nItem Name=\nAuthor\n Type=\nString\nHe MJ\n/Item", 
            "title": "Services"
        }, 
        {
            "location": "/man/services/#bioservices-apis-for-web-services", 
            "text": "The  Bio.Services  module provides APIs for various web services.", 
            "title": "Bio.Services: APIs for Web Services"
        }, 
        {
            "location": "/man/services/#e-utilities", 
            "text": "E-Utilities provide a interface to Entrez databases at  NCBI .  The APIs are defined in the  Bio.Services.EUtils  module, which exports nine functions to access its databases:     Function  Description      einfo  Retrieve a list of databases or statistics for a database.    esearch  Retrieve a list of UIDs matching a text query.    epost  Upload or append a list of UIDs to the Entrez History server.    esummary  Retrieve document summaries for a list of UIDs.    efetch  Retrieve formatted data records for a list of UIDs.    elink  Retrieve UIDs linked to an input set of UIDs.    egquery  Retrieve the number of available records in all databases by a text query.    espell  Retrieve spelling suggestions.    ecitmatch  Retrieve PubMed IDs that correspond to a set of input citation strings.     \"The Nine E-utilities in Brief\"  summarizes all of the server-side programs corresponding to each function.  In this package, queries for databases are controlled by keyword parameters. For example, some functions take  db  parameter to specify the target database. Functions listed above take these parameters as keyword arguments and return a  Response  object as follows:  julia   using   Bio . Services . EUtils        # import the nine functions above  julia   res   =   einfo ( db = pubmed )         # retrieve statistics of the PubMed database  Response(200 OK, 18 headers, 27360 bytes in body)  julia   write ( pubmed.xml ,   res . data )    # save retrieved data into a file  27360  shell  head result.xml ?xml version= 1.0  encoding= UTF-8  ?  !DOCTYPE eInfoResult PUBLIC  -//NLM//DTD einfo 20130322//EN   https://eutils.ncbi.nlm.nih.gov/eutils/dtd/20130322/einfo.dtd  eInfoResult           DbInfo           DbName pubmed /DbName           MenuName PubMed /MenuName           Description PubMed bibliographic record /Description           DbBuild Build161024-2207m.1 /DbBuild           Count 26590895 /Count           LastUpdate 2016/10/25 02:06 /LastUpdate   Let's see a few more examples of parameters.  The  term  parameter specifies a search string (e.g.  esearch(db=\"gene\", term=\"tumor AND human[ORGN]\") ).  The  id  parameter specifies a UID (or accession number) or a list of UIDs (e.g.  efetch(db=\"protein\", id=\"NP_000537.3\", rettype=\"fasta\") ,  efetch(db=\"snp\", id=[\"rs55863639\", \"rs587780067\"]) ). The complete list of parameters can be found at  \"The E-utilities In-Depth: Parameters, Syntax and More\" .  When a request succeeds the response object has a  data  field containing formatted data, which can be saved to a file as demonstrated above. However, users are often interested in a part of the response data and may want to extract some fields in it. In such a case,  EzXML.jl  is helpful because it offers lots of tools to handle XML documents. The first thing you need to do is converting the response data into an XML document by  parsexml :  julia   res   =   efetch ( db = nuccore ,   id = NM_001126.3 ,   retmode = xml )  Response(200 OK, 19 headers, 41536 bytes in body)  julia   using   EzXML  julia   doc   =   parsexml ( res . data )  EzXML.Document(EzXML.Node( DOCUMENT_NODE@0x00007fdd4cc43770 ))   After that, you can query fields you want using  XPath :  julia   seq   =   findfirst ( doc ,   /GBSet/GBSeq )  EzXML.Node( ELEMENT_NODE@0x00007fdd49f34b10 )  julia   content ( findfirst ( seq ,   GBSeq_definition ))  Homo sapiens adenylosuccinate synthase (ADSS), mRNA  julia   content ( findfirst ( seq ,   GBSeq_accession-version ))  NM_001126.3  julia   length ( find ( seq ,   //GBReference ))  10  julia   using   Bio . Seq  julia   DNASequence ( content ( findfirst ( seq ,   GBSeq_sequence )))  2791nt DNA Sequence:  ACGGGAGTGGCGCGCCAGGCCGCGGAAGGGGCGTGGCCT\u2026TGATTAAAAGAACCAAATATTTCTAGTATGAAAAAAAAA   Every function can take a context dictionary as its first argument to set parameters into a query. Key-value pairs in a context are appended to a query in addition to other parameters passed by keyword arguments.  The default context is an empty dictionary that sets no parameters. This context dictionary is especially useful when temporarily caching query UIDs into the Entrez History server. A request to the Entrez system can be associated with cached data using \"WebEnv\" and \"query_key\" parameters. In the following example, the search results of  esearch  is saved in the Entrez History server (note  usehistory=true , which makes the server cache its search results) and then their summaries are retrieved in the next call of  esummary :  julia   context   =   Dict ()    # create an empty context  Dict{Any,Any} with 0 entries  julia   res   =   esearch ( context ,   db = pubmed ,   term = asthma[mesh] AND leukotrienes[mesh] AND 2009[pdat] ,   usehistory = true )  Response(200 OK, 18 headers, 1574 bytes in body)  julia   context    # the context dictionary has been updated  Dict{Any,Any} with 2 entries:    :query_key =   1    :WebEnv    =   NCID_1_9251987_130.14.22.215_9001_1477389145_1960133\u2026  julia   res   =   esummary ( context ,   db = pubmed )    # retrieve summaries in context  Response(200 OK, 18 headers, 135463 bytes in body)  julia   write ( asthma_leukotrienes_2009.xml ,   res . data )    # save data into a file  135463  shell  head asthma_leukotrienes_2009.xml ?xml version= 1.0  encoding= UTF-8  ?  !DOCTYPE eSummaryResult PUBLIC  -//NLM//DTD esummary v1 20041029//EN   https://eutils.ncbi.nlm.nih.gov/eutils/dtd/20041029/esummary-v1.dtd  eSummaryResult  DocSum           Id 20113659 /Id           Item Name= PubDate  Type= Date 2009 Nov /Item           Item Name= EPubDate  Type= Date /Item           Item Name= Source  Type= String Zhongguo Dang Dai Er Ke Za Zhi /Item           Item Name= AuthorList  Type= List                   Item Name= Author  Type= String He MJ /Item", 
            "title": "E-Utilities"
        }, 
        {
            "location": "/man/util/", 
            "text": "Bio.Util: Utility Functions\n\n\nThe \nBio.Util\n module provides utility functions commonly used in bioinformatics.\n\n\n\n\nLabelled square matrix parsers\n\n\nThis module contains a function \nreadlsm\n, that reads labelled square matrices.\n\n\nSuch matrices are commonly used to store pairwise measures of similarity or dissimilarity between two sets. This format consists of a delimited file, with text labels on the upper and left sides of a square matrix. Such matrices are often but not exclusively symmetric.\n\n\nAn example would be:\n\n\n    A   B\nA   1   2\nB   2   1\n\n\n\n\n\n(Note that we use spaces as a delimiter, where tabs would normally be used)", 
            "title": "Util"
        }, 
        {
            "location": "/man/util/#bioutil-utility-functions", 
            "text": "The  Bio.Util  module provides utility functions commonly used in bioinformatics.", 
            "title": "Bio.Util: Utility Functions"
        }, 
        {
            "location": "/man/util/#labelled-square-matrix-parsers", 
            "text": "This module contains a function  readlsm , that reads labelled square matrices.  Such matrices are commonly used to store pairwise measures of similarity or dissimilarity between two sets. This format consists of a delimited file, with text labels on the upper and left sides of a square matrix. Such matrices are often but not exclusively symmetric.  An example would be:      A   B\nA   1   2\nB   2   1  (Note that we use spaces as a delimiter, where tabs would normally be used)", 
            "title": "Labelled square matrix parsers"
        }, 
        {
            "location": "/man/tools/", 
            "text": "Bio.Tools: Misc tools and function wrappers\n\n\n\n\nBLAST wrapper\n\n\nThe \nBio.Tools.BLAST\n module is a wrapper for the command line interface of \nBLAST+\n from NCBI. It requires that you have BLAST+ \ninstalled\n and accessible in your PATH (eg. you should be able to execute \n$ blastn -h\n from the command line).\n\n\n\n\nThe Basics\n\n\nThis module allows you to run protein and nucleotide BLAST (\nblastp\n and \nblastn\n respectively) within julia and to parse BLAST results into Bio.jl types.\n\n\nusing\n \nBio\n.\nSeq\n,\n\n      \nBio\n.\nTools\n.\nBLAST\n\n\n\nseq1\n \n=\n \ndna\n\n\nCGGACCAGACGGACACAGGGAGAAGCTAGTTTCTTTCATGTGATTGANAT\n\n\nNATGACTCTACTCCTAAAAGGGAAAAANCAATATCCTTGTTTACAGAAGA\n\n\nGAAACAAACAAGCCCCACTCAGCTCAGTCACAGGAGAGAN\n\n\n\n\n\nseq2\n \n=\n \ndna\n\n\nCGGAGCCAGCGAGCATATGCTGCATGAGGACCTTTCTATCTTACATTATG\n\n\nGCTGGGAATCTTACTCTTTCATCTGATACCTTGTTCAGATTTCAAAATAG\n\n\nTTGTAGCCTTATCCTGGTTTTACAGATGTGAAACTTTCAA\n\n\n\n\n\nblastn\n(\nseq1\n,\n \nseq2\n)\n\n\n\n\n\n\nThese functions return a \nVector{BLASTResult}\n. Each element is a hit which includes the sequence of the hit, an \nAlignedSequence\n using the original query as a reference and some additional information (expect vaue, bitscore) for the hit.\n\n\nimmutable\n \nBLASTResult\n\n    \nbitscore\n::\nFloat64\n\n    \nexpect\n::\nFloat64\n\n    \nqueryname\n::\nString\n\n    \nhitname\n::\nString\n\n    \nhit\n::\nBioSequence\n\n    \nalignment\n::\nAlignedSequence\n\n\nend\n\n\n\n\n\n\nIf you've already run a blast analysis or have downloaded blast results in XML format from NCBI you can also pass an XML string to \nreadblastXML()\n in order to obtain an array of \nBLASTResult\ns.\n\n\nresults\n \n=\n \nreadall\n(\nopen\n(\nblast_results.xml\n))\n \n# need to use `readstring` instead of `readall` for v0.5\n\n\nreadblastXML\n(\nresults\n)\n\n\n\n\n\n\nWhen parsing protein blast results, you must include the argument \nseqtype=\"prot\"\n, eg. \nreadblastXML(\"results, seqtype=\"prot\")\n\n\n\n\nOptions for \nblastn\n and \nblastp\n\n\nBoth of the basic BLAST+ commands can accept a single \nBioSequence\n, a \nVector{BioSequence}\n or a sting representing a file path to a fasta formatted file as arguments for both \nquery\n and \nsubject\n.\n\n\nblastn\n([\nseq1\n,\n \nseq2\n],\n \n[\nseq2\n,\n \nseq3\n])\n\n\n\nblastp\n(\naaseq\n,\n \npath/to/sequences.fasta\n)\n\n\n\n\n\n\nIf you have a local blast database (eg through the use of \n$ makeblastdb\n), you can use this database as the \nsubject\n\n\nblastn\n(\nseq1\n,\n \npath/to/blast_db\n,\n \ndb\n=\ntrue\n)\n\n\n\n\n\n\nIf you want to modify the search using additional options (eg. return only results with greater than 90% identity), you may pass a \nVector\n of flags (see \nhere\n for valid arguments - do not use flags that will alter file handling such as \n-outfmt\n)\n\n\nblastn\n(\nseq1\n,\n \nseq2\n,\n \n[\n-perc_identity\n,\n \n90\n,\n \n-evalue\n,\n \n9.0\n])", 
            "title": "Tools"
        }, 
        {
            "location": "/man/tools/#biotools-misc-tools-and-function-wrappers", 
            "text": "", 
            "title": "Bio.Tools: Misc tools and function wrappers"
        }, 
        {
            "location": "/man/tools/#blast-wrapper", 
            "text": "The  Bio.Tools.BLAST  module is a wrapper for the command line interface of  BLAST+  from NCBI. It requires that you have BLAST+  installed  and accessible in your PATH (eg. you should be able to execute  $ blastn -h  from the command line).", 
            "title": "BLAST wrapper"
        }, 
        {
            "location": "/man/tools/#the-basics", 
            "text": "This module allows you to run protein and nucleotide BLAST ( blastp  and  blastn  respectively) within julia and to parse BLAST results into Bio.jl types.  using   Bio . Seq , \n       Bio . Tools . BLAST  seq1   =   dna  CGGACCAGACGGACACAGGGAGAAGCTAGTTTCTTTCATGTGATTGANAT  NATGACTCTACTCCTAAAAGGGAAAAANCAATATCCTTGTTTACAGAAGA  GAAACAAACAAGCCCCACTCAGCTCAGTCACAGGAGAGAN   seq2   =   dna  CGGAGCCAGCGAGCATATGCTGCATGAGGACCTTTCTATCTTACATTATG  GCTGGGAATCTTACTCTTTCATCTGATACCTTGTTCAGATTTCAAAATAG  TTGTAGCCTTATCCTGGTTTTACAGATGTGAAACTTTCAA   blastn ( seq1 ,   seq2 )   These functions return a  Vector{BLASTResult} . Each element is a hit which includes the sequence of the hit, an  AlignedSequence  using the original query as a reference and some additional information (expect vaue, bitscore) for the hit.  immutable   BLASTResult \n     bitscore :: Float64 \n     expect :: Float64 \n     queryname :: String \n     hitname :: String \n     hit :: BioSequence \n     alignment :: AlignedSequence  end   If you've already run a blast analysis or have downloaded blast results in XML format from NCBI you can also pass an XML string to  readblastXML()  in order to obtain an array of  BLASTResult s.  results   =   readall ( open ( blast_results.xml ))   # need to use `readstring` instead of `readall` for v0.5  readblastXML ( results )   When parsing protein blast results, you must include the argument  seqtype=\"prot\" , eg.  readblastXML(\"results, seqtype=\"prot\")", 
            "title": "The Basics"
        }, 
        {
            "location": "/man/tools/#options-for-blastn-and-blastp", 
            "text": "Both of the basic BLAST+ commands can accept a single  BioSequence , a  Vector{BioSequence}  or a sting representing a file path to a fasta formatted file as arguments for both  query  and  subject .  blastn ([ seq1 ,   seq2 ],   [ seq2 ,   seq3 ])  blastp ( aaseq ,   path/to/sequences.fasta )   If you have a local blast database (eg through the use of  $ makeblastdb ), you can use this database as the  subject  blastn ( seq1 ,   path/to/blast_db ,   db = true )   If you want to modify the search using additional options (eg. return only results with greater than 90% identity), you may pass a  Vector  of flags (see  here  for valid arguments - do not use flags that will alter file handling such as  -outfmt )  blastn ( seq1 ,   seq2 ,   [ -perc_identity ,   90 ,   -evalue ,   9.0 ])", 
            "title": "Options for blastn and blastp"
        }, 
        {
            "location": "/man/", 
            "text": "Bio.jl Index\n\n\n\n\nBio.Seq.ncbi_trans_table\n\n\nBio.Seq.AbifReader\n\n\nBio.Seq.FASTQReader\n\n\nBio.Seq.FASTQWriter\n\n\nBio.Seq.canonical\n\n\nBio.Seq.complement!\n\n\nBio.Seq.each\n\n\nBio.Seq.neighbors\n\n\nBio.Seq.reverse_complement!\n\n\nBio.Seq.translate\n\n\nBio.Align.alignment\n\n\nBio.Align.cigar\n\n\nBio.Align.count_aligned\n\n\nBio.Align.count_deletions\n\n\nBio.Align.count_insertions\n\n\nBio.Align.count_matches\n\n\nBio.Align.count_mismatches\n\n\nBio.Align.hasalignment\n\n\nBio.Align.ref2seq\n\n\nBio.Align.score\n\n\nBio.Align.seq2ref\n\n\nBio.Intervals.BigBedReader\n\n\nBio.Intervals.BigBedWriter\n\n\nBio.Intervals.coverage\n\n\nBio.Intervals.eachoverlap\n\n\nBio.Var.Ambiguous\n\n\nBio.Var.Certain\n\n\nBio.Var.Conserved\n\n\nBio.Var.Gap\n\n\nBio.Var.Match\n\n\nBio.Var.Mismatch\n\n\nBio.Var.Mutated\n\n\nBio.Var.Transition\n\n\nBio.Var.Transversion\n\n\nBio.Var.count_sites", 
            "title": "Index"
        }, 
        {
            "location": "/man/#biojl-index", 
            "text": "Bio.Seq.ncbi_trans_table  Bio.Seq.AbifReader  Bio.Seq.FASTQReader  Bio.Seq.FASTQWriter  Bio.Seq.canonical  Bio.Seq.complement!  Bio.Seq.each  Bio.Seq.neighbors  Bio.Seq.reverse_complement!  Bio.Seq.translate  Bio.Align.alignment  Bio.Align.cigar  Bio.Align.count_aligned  Bio.Align.count_deletions  Bio.Align.count_insertions  Bio.Align.count_matches  Bio.Align.count_mismatches  Bio.Align.hasalignment  Bio.Align.ref2seq  Bio.Align.score  Bio.Align.seq2ref  Bio.Intervals.BigBedReader  Bio.Intervals.BigBedWriter  Bio.Intervals.coverage  Bio.Intervals.eachoverlap  Bio.Var.Ambiguous  Bio.Var.Certain  Bio.Var.Conserved  Bio.Var.Gap  Bio.Var.Match  Bio.Var.Mismatch  Bio.Var.Mutated  Bio.Var.Transition  Bio.Var.Transversion  Bio.Var.count_sites", 
            "title": "Bio.jl Index"
        }, 
        {
            "location": "/man/contributing/", 
            "text": "Contributing\n\n\nThe BioJulia organisation has a set of contribution guidelines which apply to all BioJulia projects.\n\n\nThese guidelines are available \nhere\n and it is recommended all new contributors read these guidelines before opening a pull request.", 
            "title": "Contributing"
        }, 
        {
            "location": "/man/contributing/#contributing", 
            "text": "The BioJulia organisation has a set of contribution guidelines which apply to all BioJulia projects.  These guidelines are available  here  and it is recommended all new contributors read these guidelines before opening a pull request.", 
            "title": "Contributing"
        }
    ]
}