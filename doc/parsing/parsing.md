
This document is an overview of how parsers work in Bio.jl, including how to
implement new parsers.

The parsing framework in Bio.jl is unique amongst bioinformatics libraries.
Rather than hand-written parsers, we use grammar specifications that are
compiled into parser code using a tool called
[ragel](http://www.colm.net/open-source/ragel/).

These parsers can generally be as fast or faster than hand-written parsers while
being much more explicit about the syntax of the format they parse. Ragel parses
only regular languages, which means not everything can be written as a ragel
parser, yet most formats can be, including many binary formats.

# Installing ragel

Currently Julia is not an officially supported language in ragel, but is
maintained in a BioJulia fork of the project
[here](https://github.com/BioJulia/ragel). This will change when ragel 7.0 is
released, but for the time being we have to maintain our own Julia backend.

Installing ragel is relatively straightforward. First you must install version
0.12 of colm,
which is the language that the generator backends are implemented in.

```sh
wget http://www.colm.net/files/colm/colm-0.12.0.tar.gz
tar xzf colm-0.12.0.tar.gz
cd colm-0.12.0
./configure
make install
```

Then ragel can be installed.


```sh
git clone https://github.com/BioJulia/ragel.git
cd ragel
./autogen.sh
./configure --disable-manual
make install
```

# Running ragel

Ragel takes as input a `.rl` file and generates regular Julia source code in a
`.jl` file. Ragel source files are a mixture of Julia code and ragel's machine
specification language.

In Bio.jl we use a makefile to generate parsers. The following make recipe is
used to generate ragel parsers, which simply runs ragel, prepending a warning to
the generated file.

```make
%.jl: %.rl
    ragel -U -G2 $< -o $@.tmp
    echo "# WARNING: This file was generated from $< using ragel. Do not edit!" > $@
    sed 's/[[:space:]]*$$//g' $@.tmp >> $@
    rm $@.tmp
```

It runs ragel with the `-U` option which sets Julia as the host language, and
`-G2` which intstructs it to generate a fast goto-based parser. Ragel can
generate other types of parsers generally trading off speed for conciceness:
`-G1` will generate a less agressively unrolled goto based parser, while `-T0`,
`-T1`, `-F0`, `-F1` generate table-based parsers, which are generally less
efficient, but also produce far less code. All of these should otherwise
function the same. Using `-G2` parsers will produce the fastest code, but also
the code with the highest upfront compilation cost.

An easy mistake to make when working on a parser is to make a change to the
`.rl` source file, but forget to regenerate the `.jl` file. One easy way to
avoid this is to use the [entr](http://entrproject.org/) tool, which watches
some files and runs a command when one changes. Running the following command in
directory of some `.rl` files and a corresponding makefile will automatically
keep the `.jl` files up to date until it's killed.

```sh
ls *.rl | entr make
```

# Writing parsers

Throughout this guide we will demonstrate how to add new parsers by implementing
a parser for a very simplistic format: a 3-field BED file, in which each line
contains a sequence name followed by a start and end position. There is already
a more full feature BED parser in Bio, so this is purely pedagogical, but a
useful starting point.

A BED3 file might look like this.

```
chr9    68288114        68330909
chr9    68331023        68424451
chr9    68331037        68419993
chr9    68331055        68426908
chr9    68331083        68390919
chr9    68331113        68424451
```

## Writing a machine specification

Though we are using a newer version of ragel, the specification language has not
significantly changed, so the the [manual for
ragel-6.9](http://www.colm.net/files/ragel/ragel-guide-6.9.pdf) is the best
source to learn the basics of how to write ragel parsers. The main feature of
ragel, compared to other parser generator tools for regular languages, is that
it allows arbitrary code to be executed on transitions in the finite state
machine.

Let's start with a basic specification BED3 in ragel.

```ragel
%%{
    machine bed3;

    seqname = [ -~]*;
    first   = digit+;
    last    = digit+;
    bed3_entry = seqname '\t' first '\t' last '\n';
    main := bed3_entry*;
}%%
```

In `.rl` files, ragel annotations and code are marked with `%%` to separate it
from the host language (Julia, in our case). The first line of the specification
gives a name to the machine, the remaining lines define the language that it
accepts. Each line of the specification assigns a name to some part of the
overall machine, which is itself called `main`. We could write the whole thing
as

```ragel
%%{
    machine bed3;
    main := ([ -~]* '\t' digit+ '\t' digit+ '\t')*;
}%%
```

but assigning names to parts of the machine makes things clearer and will help
us later when we start defining actions for the parser.

The specification language will look familiar to those who have used parser
generators or regular expressions in the past.  Similar to most regular
expression grammars `+` indicates "one or more of", `*` "any number of", and `[
-~]` a range of accepted characters. In this case space through `~`, which is
all printable ASCII characters and space.

## Practical considerations

Parsing data contained in a string in one shot is made quite simple with ragel,
however with many formats we don't have the luxury of reading all the input into
memory before parsing, since the input is simply too large. The BED3 files we
wish to parse may represent short read alignments or other high-throughput data,
so may be hundreds of millions of lines. Instead we have to work from buffered
input streams. This complicates parsing, but most of this complexity is hid in
the `Bio.Ragel` module, which contains macros that generate code to handle
buffer refills, and other details.

## `@mark` and `@unmark`

Along with parsing on buffered streams, `Bio.Ragel` has some tricks to
avoid making unecessary allocations or copies during parsing. These revolve
around "marking" positions in a buffer.

# Optimizing and debugging parsers

A major complication is debugging or optimizing ragel generated parsers is that
with current versions of Julia, line numbers in stack traces and profiler output
will be unreliable. Until this situation improves, profiling parsers using
`@profile` is of limited use. A more fruitful way to improve the speed of
parsers is to work from the state transition diagram.

These diagrams can often illucidate unecessary work being performed by the
parser, or incorrectly specified grammars. Tracing through this diagram
step-by-step, and making sure it agrees with your intention is an important
sanity check when implementing a moderately complex parser.

Unfortunately, there are some issues with generating these state diagrams
with our development version of ragel. To produce these you should install the
[ragel 6.9](http://www.colm.net/files/ragel/ragel-6.9.tar.gz) in a separate
directory. You will also need [graphviz](http://www.graphviz.org/).

The makefile rules we use to generate diagrams are

```make
%.dot: %.rl
    ~/src/ragel-6.9/ragel/ragel -p -V $< > $@

%.svg: %.dot
    dot -Tsvg < $< > $@
```

This assumes ragel 6.9 is compiled in `~/src/ragel-6.9/`. It first runs ragel to
generate `.dot` graphviz specification file, then runs the graphviz `dot`
program to generate an svg file.



